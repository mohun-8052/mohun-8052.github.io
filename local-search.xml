<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>两级运放设计纪实【2】widlar电流镜</title>
    <link href="/2022/10/20/%E4%B8%A4%E7%BA%A7%E8%BF%90%E6%94%BE%E8%AE%BE%E8%AE%A1%E7%BA%AA%E5%AE%9E%E3%80%902%E3%80%91widlar%E7%94%B5%E6%B5%81%E9%95%9C/"/>
    <url>/2022/10/20/%E4%B8%A4%E7%BA%A7%E8%BF%90%E6%94%BE%E8%AE%BE%E8%AE%A1%E7%BA%AA%E5%AE%9E%E3%80%902%E3%80%91widlar%E7%94%B5%E6%B5%81%E9%95%9C/</url>
    
    <content type="html"><![CDATA[<p>该电流镜用于二级运放中，作为偏置电路。</p><p>widlar电流镜所提供的偏置电压和偏置电流和电源电压无关，仅仅有一个电阻和器件尺寸决定。</p><hr><span id="more"></span><h1 id="1-电路图"><a href="#1-电路图" class="headerlink" title="1. 电路图"></a>1. 电路图</h1><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20221020163504038.png" alt="图1 widlar电流镜偏置"></p><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><p>电路提供的<strong>偏置电流</strong>$I_B$与直流电源和MOSFET的开启电压无关。</p><p>更进一步说，被偏置的晶体管的<strong>跨导</strong>$g_m$仅由一个电阻和器件的尺寸决定。</p><h2 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h2><p>偏置电路包括</p><ul><li>$Q_{12}$和$Q_{13}$：两个故意<strong>失配</strong>的晶体管。</li><li>$Q_{10}$和$Q_{11}$：最大程度地降低$Q_{12}$的沟道长度调制效应。用了cascode连接的晶体管$Q_{10}$和<strong>匹配</strong>的连接成二极管的晶体管$Q_{11}$来提供$Q_{10}$的偏置电压。</li><li>$Q_{8}$和$Q_{9}$：由<strong>匹配</strong>的P沟道器件$Q_{8}$和$Q_{9}$构成的镜像电流源将电流$I_B$复制到$Q_{13}$和$Q_{11}$。</li></ul><p>注：</p><ol><li><p>通常$Q_{12}$沟道宽度是$Q_{13}$的<strong>4倍</strong>，即$(\frac{W}{L})<em>{12}&#x3D;4(\frac{W}{L})</em>{13}$。参见（Steininger,1990; Johns and Martin, 1997）</p></li><li><p>电阻$R_B$串联在$Q_{12}$的源极。其中$R_B$决定了偏置电流$I_B$和跨导$g_{m12}$，因此它的值必须是稳定且精确的。故在大多数应用中，$R_B$<strong>都是片外电阻</strong>。</p></li><li><p>失配，即表示$(\frac{W}{L})$不相等；匹配，即表示$(\frac{W}{L})$相等。即<br>$$<br>(\frac{W}{L})<em>{12}&#x3D;4(\frac{W}{L})</em>{13}\tag{1}<br>$$</p><p>$$<br>(\frac{W}{L})<em>{10}&#x3D;4(\frac{W}{L})</em>{11}\tag{2}<br>$$</p><p>$$<br>(\frac{W}{L})<em>{8}&#x3D;4(\frac{W}{L})</em>{9}\tag{3}<br>$$</p></li><li><p>可以认为：只要<strong>所有管子都工作在饱和区</strong>，</p><ul><li>$Q_{12}$、$Q_{13}$和$R_B$：负责产生特定大小的$I_B$</li><li>$Q_{10}$和$Q_{11}$：负责减小$Q_{12}$的沟长调制效应；负责产生一个偏置电压值（如本设计）</li><li>$Q_{8}$和$Q_{9}$：负责镜像电流，使得流过$Q_{12}$、$Q_{13}$相等（因为$V_{GS8}&#x3D;V_{GS9}$、$(\frac{W}{L})<em>{8}&#x3D;4(\frac{W}{L})</em>{9}$）；负责产生一个偏置电压值（如本设计）</li></ul></li></ol><h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><h2 id="2-1-电流-I-B-由-Q-12-、-Q-13-和-R-B-决定"><a href="#2-1-电流-I-B-由-Q-12-、-Q-13-和-R-B-决定" class="headerlink" title="2.1 电流$I_B$由$Q_{12}$、$Q_{13}$和$R_B$决定"></a>2.1 电流$I_B$由$Q_{12}$、$Q_{13}$和$R_B$决定</h2><p>由于$Q_{8}$和$Q_{9}$的作用（$V_{GS8}&#x3D;V_{GS9}$、$(\frac{W}{L})<em>{8}&#x3D;4(\frac{W}{L})</em>{9}$），使得$I_{D12}&#x3D;I_{D13}&#x3D;I_B$，于是有<br>$$<br>I_B&#x3D;\frac{1}{2}·KP·(\frac{W}{L})<em>{12}(V</em>{GS12}-V_{TH})&#x3D;\frac{1}{2}·KP·(\frac{W}{L})<em>{13}(V</em>{GS13}-V_{TH})\tag{4}<br>$$<br>同时，根据直流分析可知<br>$$<br>V_{GS12}+I_BR_B&#x3D;V_{GS13} \tag{5}<br>$$<br>联立（4）（5），可得<br>$$<br>I_B&#x3D;\frac{2}{KP·(W&#x2F;L)<em>{12}R_B^2}(\sqrt{\frac{(W&#x2F;L)</em>{12}}{(W&#x2F;12)_{13}}}-1)^2\tag{6}<br>$$<br>可知，$I_B$<strong>大小由</strong></p><ul><li>$Q_{12}$的尺寸</li><li>$R_B$的大小</li><li>$Q_{12}$和$Q_{13}$的尺寸比</li></ul><p>决定。</p><h2 id="2-1-跨导-g-m-由-Q-12-、-Q-13-和-R-B-决定"><a href="#2-1-跨导-g-m-由-Q-12-、-Q-13-和-R-B-决定" class="headerlink" title="2.1 跨导$g_m$由$Q_{12}$、$Q_{13}$和$R_B$决定"></a>2.1 跨导$g_m$由$Q_{12}$、$Q_{13}$和$R_B$决定</h2><p>将式子（6）重写可得到，<br>$$<br>R_B&#x3D;\frac{2}{\sqrt{2·KP·(W&#x2F;L)<em>{12}I_B}}(\sqrt{\frac{(W&#x2F;L)</em>{12}}{(W&#x2F;12)<em>{13}}}-1)\tag{7}<br>$$<br>而其中，$g</em>{m12}&#x3D;\sqrt{2·KP·(W&#x2F;L)<em>{12}I_B}$，于是<br>$$<br>g</em>{m12}&#x3D;\frac{2}{R_B}(\sqrt{\frac{(W&#x2F;L)<em>{12}}{(W&#x2F;12)</em>{13}}}-1)\tag{8}<br>$$<br>又因为，$g_m$<strong>正比于</strong>$\sqrt{I_D(W&#x2F;L)}$<strong>，而偏置电路中，电流处处相等。</strong></p><p>于是，对于第$i$个NMOS管，<br>$$<br>g_{mi}&#x3D;g_{m12}\sqrt{\frac{I_{Di}(W&#x2F;L)<em>i}{I_B(W&#x2F;L)</em>{12}}} \tag{9}<br>$$<br>对于第$i$个PMOS管，<br>$$<br>g_{mi}&#x3D;g_{m12}\sqrt{\frac{\mu_pI_{Di}(W&#x2F;L)<em>i}{\mu_nI_B(W&#x2F;L)</em>{12}}}\tag{10}<br>$$</p><p>可知，电路中<strong>所有管子的</strong>$g_m$，由</p><ul><li>$R_B$值</li><li>$Q_{12}$和$Q_{13}$的尺寸比</li><li>$Q_{i}$和$Q_{12}$的尺寸比</li><li>迁移率比</li></ul><p><strong>决定，与其他无关</strong>。</p><h1 id="3-偏置电压值"><a href="#3-偏置电压值" class="headerlink" title="3. 偏置电压值"></a>3. 偏置电压值</h1><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20221021084216991.png" alt="图2 两个电压值"></p><p>如上图所示，该电路可以产生两个偏置电压。</p><p>当$Q_{12}$、$Q_{13}$以及$R_B$值确定之后，$I_B$也就确定了。</p><p>当管子均工作在<strong>饱和区</strong>，根据$I_B&#x3D;I_B&#x3D;\frac{1}{2}·KP·(\frac{W}{L})<em>i(V</em>{GSi}-V_{TH})$，<strong>改变另外四个管子（两组管子）的宽长比</strong>，即可得<br>$$<br>V_1&#x3D;V_{DD}-|V_{GS8}|\tag{11}<br>$$</p><p>$$<br>V_2&#x3D;V_{GS13}+V_{GS11}\tag{12}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟IC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两级运放设计纪实【1】参数提取</title>
    <link href="/2022/10/19/%E4%B8%A4%E7%BA%A7%E8%BF%90%E6%94%BE%E8%AE%BE%E8%AE%A1%E7%BA%AA%E5%AE%9E%E3%80%901%E3%80%91%E5%8F%82%E6%95%B0%E6%8F%90%E5%8F%96/"/>
    <url>/2022/10/19/%E4%B8%A4%E7%BA%A7%E8%BF%90%E6%94%BE%E8%AE%BE%E8%AE%A1%E7%BA%AA%E5%AE%9E%E3%80%901%E3%80%91%E5%8F%82%E6%95%B0%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>MOS工艺库参数提取</p><hr><span id="more"></span><h1 id="1-提取参数的必要性"><a href="#1-提取参数的必要性" class="headerlink" title="1. 提取参数的必要性"></a>1. 提取参数的必要性</h1><p>以MOS一阶模型，饱和区公式为例，<br>$$<br>i_D&#x3D; \frac{1}{2} ·KP· \frac{W}{L}·(v_{GS}-V_{th})^2·(1+\lambda v_{DS} )<br>$$<br>其中，$KP$、$V_{TH}$、$\lambda$均是和工艺相关的参数。因此在设计之前，需要先提取工艺参数才可以进行设计。</p><h1 id="2-相关公式"><a href="#2-相关公式" class="headerlink" title="2. 相关公式"></a>2. 相关公式</h1><p>相关公式如下：</p><p>（1）阈值电压</p><p>$$<br>V_{TH}&#x3D;V_{TH0}+\gamma (\sqrt{|2\Phi_F+V_{SB}|}-\sqrt{|2\Phi_F|})<br>$$<br>又有<br>$$<br>|2\Phi_F|&#x3D;2·\frac{kT}{q}·ln(\frac{n_{ch}}{n_i})<br>$$<br>（2）参数因子<br>$$<br>KP&#x3D;\mu C_{ox}&#x3D;\mu \frac{\varepsilon_{ox}}{t_{ox}}<br>$$<br>（3）衬片调制系数<br>$$<br>\gamma &#x3D;\frac{\sqrt{2q·\varepsilon_{Si}·n_{ch}}}{\varepsilon_{ox}&#x2F;{t_{ox}}}<br>$$<br>（4）沟长调制系数<br>$$<br>\frac{1}{\lambda}&#x3D;{L·V_A’}&#x3D;V_A<br>$$<br>目前不太清楚$\lambda$和$P_{CLM}$之间关系</p><p>可知需要提取的参数主要如下</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$V_{TH0}$</td><td align="center">当$v_{BS}&#x3D;0$且$v_{DS}$很小时，长沟道器件的阈值电压</td></tr><tr><td align="center">$\mu_0$</td><td align="center">参数提取温度下的表面迁移率（$\mu \neq \mu_0$，因为温度可能不同）</td></tr><tr><td align="center">$t_{ox}$</td><td align="center">氧化层厚度</td></tr><tr><td align="center">$n_{ch}$</td><td align="center">沟道掺杂浓度</td></tr><tr><td align="center">$P_{CLM}$</td><td align="center">沟长调制系数</td></tr></tbody></table><p>以上参数均可以在<code>.lib</code>、<code>.mdl</code>、<code>.scs</code>（取决于具体工艺）文件中得到。</p><h1 id="3-参数提取"><a href="#3-参数提取" class="headerlink" title="3.参数提取"></a>3.参数提取</h1><p>以smic018 1P6M工艺为例子：</p><table><thead><tr><th align="center">参数</th><th align="center">NMOS（n18）</th><th align="center">PMOS（p18）</th></tr></thead><tbody><tr><td align="center">$V_{TH0}$</td><td align="center">0.390+ $V$</td><td align="center">-0.402+ $V$</td></tr><tr><td align="center">$\mu_0$</td><td align="center">3.4e-02+ $m^2·V^{-1}·s^{-1}$</td><td align="center">3.74e-09+ $m^2·V^{-1}·s^{-1}$</td></tr><tr><td align="center">$t_{ox}$</td><td align="center">3.87e-09+ $cm$</td><td align="center">3.74e-09+ $cm$</td></tr><tr><td align="center">$n_{ch}$</td><td align="center">3.869e+17 $cm^{-3}$</td><td align="center">5.500e+17 $cm^{-3}$</td></tr><tr><td align="center">$P_{CLM}$</td><td align="center">1.2</td><td align="center">0.7</td></tr></tbody></table><p>其他需要的常数</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">$k$</td><td align="center">波尔兹曼常数</td><td align="center">1.381e-23 $J&#x2F;K$</td></tr><tr><td align="center">$n_i$</td><td align="center">本征载流子浓度(@300K)</td><td align="center">1.45e10 $cm^{-3}$</td></tr><tr><td align="center">$\varepsilon_0$</td><td align="center">真空介电常数</td><td align="center">8.854e-14 $F&#x2F;cm$</td></tr><tr><td align="center">$\varepsilon_{Si}&#x3D;11.7 \varepsilon_0$</td><td align="center">硅介电常数</td><td align="center">1.036e-12 $F&#x2F;cm$</td></tr><tr><td align="center">$\varepsilon_{ox}&#x3D;3.9 \varepsilon_0$</td><td align="center">二氧化硅介电常数</td><td align="center">3.453e-13 $F&#x2F;cm$</td></tr><tr><td align="center">$q$</td><td align="center">电子电荷</td><td align="center">1.6e-19 $C$</td></tr></tbody></table><p>根据以上公式，即可<strong>计算或直接</strong>得到</p><p>（1）阈值电压</p><table><thead><tr><th align="center">参数</th><th align="center">NMOS（n18）</th><th align="center">PMOS（p18）</th></tr></thead><tbody><tr><td align="center">$\vert 2\Phi_F \vert$</td><td align="center">0.8855</td><td align="center">0.9037</td></tr><tr><td align="center">$V_{TH}$</td><td align="center">$0.390+0.4014(\sqrt{0.8855+V_{SB}}-\sqrt{0.8855})$</td><td align="center">$0.390+0.4014(\sqrt{0.9037+V_{SB}}-\sqrt{0.9037})$</td></tr></tbody></table><p>一般设计中，直接采用$V_{TH}&#x3D;V_{TH0}$进行设计</p><p>（2）参数因子</p><table><thead><tr><th align="center">参数</th><th align="center">NMOS（n18）</th><th align="center">PMOS（p18）</th></tr></thead><tbody><tr><td align="center">$KP$</td><td align="center">3.0336e-4 $A·V^{-2}$</td><td align="center">7.9964e-5 $A·V^{-2}$</td></tr></tbody></table><p>（3）衬偏调制系数</p><table><thead><tr><th align="center">参数</th><th align="center">NMOS（n18）</th><th align="center">PMOS（p18）</th></tr></thead><tbody><tr><td align="center">$\gamma$</td><td align="center">0.4014 $V^{1&#x2F;2}$</td><td align="center">0.4625 $V^{1&#x2F;2}$</td></tr></tbody></table><p>（3）沟长调制系数</p><table><thead><tr><th align="center">参数</th><th align="center">NMOS（n18）</th><th align="center">PMOS（p18）</th></tr></thead><tbody><tr><td align="center">$P_{CLM}$</td><td align="center">1.2</td><td align="center">0.7</td></tr></tbody></table><p>一般设计中，直接令$L&#x3D;1\mu$进行仿真，然后再进行调试。</p>]]></content>
    
    
    <categories>
      
      <category>模拟IC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟IC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派nas电脑连接网络</title>
    <link href="/2022/09/05/%E6%A0%91%E8%8E%93%E6%B4%BEnas%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/09/05/%E6%A0%91%E8%8E%93%E6%B4%BEnas%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>Linux板子安装完最难受的就是连上网络，只要能连上网络，一切都好办，这里记录一下如何在树莓派下载镜像安装后，连接上网络。</p><hr><span id="more"></span><h1 id="1-下载系统"><a href="#1-下载系统" class="headerlink" title="1. 下载系统"></a>1. 下载系统</h1><h2 id="1-1-系统选择"><a href="#1-1-系统选择" class="headerlink" title="1.1 系统选择"></a>1.1 系统选择</h2><p>由于这个项目就是要做个nas电视，于是不需要特别牛逼的图形界面，于是这里选用简单方便的树莓派lite版本。</p><p>直接下载就行</p><h2 id="1-2-系统烧录"><a href="#1-2-系统烧录" class="headerlink" title="1.2 系统烧录"></a>1.2 系统烧录</h2><p>准备16G的sd卡，一个硬盘</p><p>使用软件将镜像烧录到sd卡里面即可</p><h1 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h1><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><p>网上的方法都不好用</p><p>最好用的方法就是找一个miniHDMI转HDMI，HDMI转VGA的线，将树莓派和一台显示器接起来，然后去设置就行</p><h2 id="2-2-开启无线网络"><a href="#2-2-开启无线网络" class="headerlink" title="2.2 开启无线网络"></a>2.2 开启无线网络</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>此时一般会显示</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">eth0:</span> <br>   ...<br><span class="hljs-symbol">lo:</span><br>   ...<br></code></pre></td></tr></table></figure><p>如果没有看到<code>wlan0</code>，此时需要开启无线网络</p><p>可以使用以下指令进行无线网络的开启</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ifconfig wlan0 up<br><span class="hljs-regexp">//</span>开启无线网络<br>sudo ifconfig wlan0 down<br><span class="hljs-regexp">//</span>关闭无线网络<br></code></pre></td></tr></table></figure><p>此时在使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>就可以看到</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">eth0:</span> <br>   ...<br><span class="hljs-symbol">lo:</span><br>   ...<br><span class="hljs-symbol">wlan0:</span><br>   ...<br></code></pre></td></tr></table></figure><h2 id="2-3-连接无线网络"><a href="#2-3-连接无线网络" class="headerlink" title="2.3 连接无线网络"></a>2.3 连接无线网络</h2><p>使用树莓派官方lite镜像，连接网络是比较方便的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo raspi-config <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220831204523541.png" alt="image-20220831204523541"></p><p>选择第一个<code>System Option</code></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220831204609396.png" alt="image-20220831204609396"></p><p>然后选择第一个<code>Wireless LAN</code></p><p>然后选择地区<code>CN China</code></p><p>然后输入<code>SSID</code>，也就是你的无线WiFi名称</p><p>然后输入<code>password</code>，也就是你的无线WiFi密码</p><p>此时选<code>finish</code>退出即可</p><p>按道理，此时<code>reboot</code>即可</p><h2 id="2-4-连接隐藏的网络"><a href="#2-4-连接隐藏的网络" class="headerlink" title="2.4 连接隐藏的网络"></a>2.4 连接隐藏的网络</h2><p>设置同2.3，然后</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">sudo nano /etc/wp<span class="hljs-built_in">a_supplicant</span>/wp<span class="hljs-built_in">a_supplicant</span>.conf<br></code></pre></td></tr></table></figure><p>此时内容为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ctrl_interface<span class="hljs-operator">=</span>DIR<span class="hljs-operator">=/</span>var/run/wpa_supplicant GROUP<span class="hljs-operator">=</span>netdev<br>update_config<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-attribute">country</span><span class="hljs-operator">=</span>CN<br><br><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br>ssid<span class="hljs-operator">=</span><span class="hljs-string">&quot;Xiaomi_7F3C&quot;</span><br>psk<span class="hljs-operator">=</span><span class="hljs-string">&quot;617dewifi..&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加上</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ctrl_interface<span class="hljs-operator">=</span>DIR<span class="hljs-operator">=/</span>var/run/wpa_supplicant GROUP<span class="hljs-operator">=</span>netdev<br>update_config<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-attribute">country</span><span class="hljs-operator">=</span>CN<br><br><span class="hljs-attribute">network</span><span class="hljs-operator">=</span>&#123;<br>ssid<span class="hljs-operator">=</span><span class="hljs-string">&quot;Xiaomi_7F3C&quot;</span><br>scan_ssid<span class="hljs-operator">=</span><span class="hljs-number">1</span>              //添加，为<span class="hljs-number">1</span>表示该网络为隐藏网络<br>psk<span class="hljs-operator">=</span><span class="hljs-string">&quot;617dewifi..&quot;</span>  <br>key_mgmt<span class="hljs-operator">=</span>WPA-PSK         //添加，根据自己网络的加密方式进行修改<br>&#125;<br></code></pre></td></tr></table></figure><p>然后<code>reboot</code>即可使用</p><h2 id="2-5-如何绑定"><a href="#2-5-如何绑定" class="headerlink" title="2.5 如何绑定"></a>2.5 如何绑定</h2><p>首先使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>查看当前的IP</p><p>比如<code>inet: 192.168.31.140</code></p><p>使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">router</span><br></code></pre></td></tr></table></figure><p>查看当前路由</p><p>比如<code>192.168.31.1</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>dhcpcd.conf<br></code></pre></td></tr></table></figure><p>在末尾添上</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">interface wlan0<br>static <span class="hljs-attribute">ip_address</span>=192.168.31.140/24<br>static <span class="hljs-attribute">routers</span>=192.168.31.1<br></code></pre></td></tr></table></figure><p><code>ip_address</code>代表设置的静态IP地址</p><p><code>routers</code>代表路由器&#x2F;网关IP地址</p><p>然后<code>reboot</code>即可</p><h2 id="2-6-开启ssh"><a href="#2-6-开启ssh" class="headerlink" title="2.6 开启ssh"></a>2.6 开启ssh</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo raspi-config<br></code></pre></td></tr></table></figure><p>选择<code>Interfacing Options</code></p><p>然后选择<code>SSH</code></p><p>选择<code>enabled</code></p><p>然后<code>reboot</code></p><p>即可使用<code>Putty</code>进行SSH连接</p>]]></content>
    
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文理之争——谋生和做自己喜欢的事情不冲突</title>
    <link href="/2022/05/04/%E6%96%87%E7%90%86%E4%B9%8B%E4%BA%89%E2%80%94%E2%80%94%E8%B0%8B%E7%94%9F%E5%92%8C%E5%81%9A%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%8D%E5%86%B2%E7%AA%81/"/>
    <url>/2022/05/04/%E6%96%87%E7%90%86%E4%B9%8B%E4%BA%89%E2%80%94%E2%80%94%E8%B0%8B%E7%94%9F%E5%92%8C%E5%81%9A%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%8D%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p>总觉得孟庆延老师很多话和我观点很吻合，特别触动我，醍醐灌顶，深受启发。我是一个工科生，我也不知道社会学理论，我就单纯以我自己的角度说一下我的看法。</p><hr><span id="more"></span><p>&ensp;&ensp; &ensp; 本文中，提到的视频连接如下：https://www.bilibili.com/video/BV17Z4y1y77V?spm_id_from=333.337.search-card.all.click <p><p>&ensp;&ensp; &ensp; 第一个问题，关于文理之争的问题。我很喜欢文科的，因为我觉得他们像画里的人，温文尔雅，举手投足尽显“大儒”之气，比如b站讲故事讲的很好的玫瑰叔。但是可能因为自己是理科生的原因，基本没有接触到文科生。好不容易接触到文科生，总觉得他们是“工业文科”，和我梦想中的“儒”大相径庭。我不知道其他文科生怎么样，“工业文科”是个例还是普遍情况我也不得而知。我个人妄断这可能还是比较普遍的情况，因为它顺应现代工业的发展，也顺应工科院校的培养方式。总而言之，我喜欢文科，但是不代表我喜欢“工业文科”。</p><p>&ensp;&ensp; &ensp; 第二、第三都可以就是人和人才的问题。这个问题或许可以拆解为“兴趣”和“职业”，“生活”和“工作”。前者是让自己成为人，后者是让自己能活下去（是成为人的基础）。从优先级来看，让自己活下去无疑优先级最高。或许古圣人觉得可以“舍生取义”，但我一介庸人没有那般大志向，活下去，优先级最高。但成为“人”，有古圣人为别人而活的“兼济天下”，也有庸人为自己活的“自由自在”。我显然是后者，也就是活下去，然后才是自由自在活下去。今人有另外一种选择，那就是先自由自在活，“世界这么大，我想去看看”，理由或许是人生苦短不过百年，或许是我家里有矿已经具备活下去的基础了。对我而言，即使自己的百年人生很短，但是我可以选择让小辈延续我的“人生”，让他替我看看精彩的世界；至于“矿”，哈哈哈，我先天就不具备这个条件。</p><p>&ensp;&ensp; &ensp; 工作和生活、兴趣和职业，我觉得将二者彻底分离是很重要的。把兴趣当成职业对于很多人而言是一件开心的事情，但并不适合我。对我一个“庸人”来说，工作上的不如意，都会让我产生极强的挫败感，进而可能放弃这个工作或者职业。在被生活打压的时候，想要寻求兴趣的慰籍，最后发现打压自己的是自己的兴趣，那是一件多么蛋疼的事情呀。工作时，我是工具，压抑人性；生活时，我是人，释放本性。所以说现代人的工具人是真的没错，将“工具”和“人”二者的彻底分开才是最好的！ </p><p>&ensp;&ensp; &ensp; 其实，现代社会和古代采集渔猎社会不一定说哪个生存压力小。现代社会可以通过学习，不断努力，“卷死”别人，得到生存空间。过程很辛苦，把自己变成彻底的“工具”谋求生计，然后觉得自己没有好累，没有思想没有灵魂。但是在采集渔猎社会，科技不发达，靠天吃饭，正如老师说的“运气”和“缘分”，但是脸黑，那可能开局就饿死重开新局了。</p>]]></content>
    
    
    <categories>
      
      <category>庸人妄语录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>孟庆延</tag>
      
      <tag>道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DC lab4和lab6略解</title>
    <link href="/2022/05/04/DC-lab4%E5%92%8Clab6%E7%95%A5%E8%A7%A3/"/>
    <url>/2022/05/04/DC-lab4%E5%92%8Clab6%E7%95%A5%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本文记录了DC LAB4和LAB6实验，表达了个人的一些见解，包括详细的计算方法。</p><p>由于LAB4和LAB6涉及均是很基础的约束设计，且笔者主要跑流程，并未对相关的概念细节和设置进行深究，敬请谅解。</p><hr><span id="more"></span><h1 id="1-面积约束"><a href="#1-面积约束" class="headerlink" title="1. 面积约束"></a>1. 面积约束</h1><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs tcl">set_max_area <span class="hljs-number">0</span>#逻辑综合出来的芯片面积为<span class="hljs-number">0</span><br><span class="hljs-comment">#这是理想化的设置，实际上是让EDA尽可能缩小综合出来的面积大小</span><br>set_max_area <span class="hljs-number">540</span>#芯片面积目标小于<span class="hljs-number">540</span>个单位面积<br></code></pre></td></tr></table></figure><h1 id="2-时序约束"><a href="#2-时序约束" class="headerlink" title="2. 时序约束"></a>2. 时序约束</h1><h2 id="2-1-总论"><a href="#2-1-总论" class="headerlink" title="2.1 总论"></a>2.1 总论</h2><h3 id="1-设计对象"><a href="#1-设计对象" class="headerlink" title="1. 设计对象"></a>1. 设计对象</h3><p>设计对象分类（8种）：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323192414015.png" alt="image-20220323192414015" style="zoom:67%;" /><ul><li>设计（design）：顶层模块（TOP module）</li><li>单元（cell）：各种例化的模块</li><li>引用（reference）：例化单元的原模块（库）</li><li>端口（port）：模块（TOP module）的输入（input）、输出（output）等</li><li>引脚（pin）：模块中，例化单元的各个接口</li><li>连线（net）：模块中用于将端口和引脚、或引脚和引脚互连起来的导线</li><li>时钟（clock）：模块中的时钟端口（port）或者引脚（pin）</li><li>库（library）</li></ul><p>【注意】</p><ol><li>以上的区分并不准确，主要需要理解的是<strong>【port】、【pin】、【clock】</strong></li><li>在设计中，时钟端口的声明和其他普通输入输出的端口并没有区别；时钟端口是在约束文件中进行具体声明，同其他普通端口进行区分的</li></ol><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323193938501.png" alt="image-20220323193938501" style="zoom: 67%;" /><h3 id="2-四种时钟路径"><a href="#2-四种时钟路径" class="headerlink" title="2. 四种时钟路径"></a>2. 四种时钟路径</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323194213987.png" alt="image-20220323194213987"></p><p><strong>每条路径从时序路径起点开始，经过一些组合逻辑，然后在终点被捕获：</strong></p><ul><li><p><strong>Path 1：</strong>从输入端口开始，到达时序元件的数据输入。即（<strong>input-to-register</strong>）</p></li><li><p><strong>Path 2：</strong>从时序元件的时钟引脚开始，到时序元件的数据输入。即（<strong>register-to-register</strong>）</p></li><li><p><strong>Path 3：</strong>从时序元件的时钟引脚开始，到输出端口结束。即（<strong>register-to-output</strong>）</p></li><li><p><strong>Path 4：</strong>从输入端口开始，到输出端口结束。即（<strong>input-to-output</strong>）</p></li></ul><p>本次实验中，将分别对四种时钟路径进行<strong>时序约束</strong></p><h2 id="2-2-整体时序约束和r-to-r约束"><a href="#2-2-整体时序约束和r-to-r约束" class="headerlink" title="2.2 整体时序约束和r-to-r约束"></a>2.2 整体时序约束和r-to-r约束</h2><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323195232323.png" alt="image-20220323195232323" style="zoom: 67%;" /><h3 id="1-时钟定义"><a href="#1-时钟定义" class="headerlink" title="1. 时钟定义"></a>1. 时钟定义</h3><ol><li><p>【题目1.1】时钟频率为333.33$Mhz$：</p><p>【解析】时钟的周期为<br>$$<br>T&#x3D;\frac{1}{333.33×10^6}≈3×10^{-9}s&#x3D;3ns<br>$$<br>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">create_clock -period <span class="hljs-number">3.0</span> [get_ports clk]<br><br><span class="hljs-comment">#在端口clk产生时钟，即设置clk端口为时钟端口</span><br><span class="hljs-comment">#产生周期为3.0ns的时钟</span><br></code></pre></td></tr></table></figure></li><li><p>【题目1.2】外部时钟产生器到时钟端口（port）的最大延迟为700$ps$</p><p>【解析】源时钟延迟，即<code>source_latency=700ps=0.7ns</code>。</p><p>​<strong>源时钟延迟如下图所示。</strong></p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_clock_latency -<span class="hljs-keyword">source</span>  -max <span class="hljs-number">0.7</span> [get_clocks clk] <br><br><span class="hljs-comment">#时钟端口的源时钟延时为0.7ns</span><br></code></pre></td></tr></table></figure></li><li><p>【题目1.3】从时钟端口（port）到所有内部和外部寄存器时钟引脚（pin）的最大延迟为$300±30ps$<br>【解析】时钟网络延时，即<code>network latency=300ps=0.3ns</code>。</p><p>​<strong>时钟网络延时如下图所示。</strong></p><p>​存在时钟偏差（shew）</p><p>​<strong>时钟偏差属于时钟不稳定（uncertainty），后文说明。</strong></p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_clock_latency</span> -max <span class="hljs-number">0</span>.<span class="hljs-number">3</span><span class="hljs-meta"> [get_clocks clk]</span><br><br><span class="hljs-comment">#时钟网络延迟为0.7ns</span><br><span class="hljs-comment">#对比源时钟延迟，少了 -source</span><br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125194853863.png" alt="image-20211125194853863" style="zoom:80%;" /></li><li><p>【题目1.4】略。时钟抖动（jitter）属于时钟不稳定，后文说明。</p></li><li><p>【题目1.5】略。建立时间裕量（setup margin）属于时钟不稳定，后文说明。</p></li><li><p>【题目1.6】时钟引脚（pin）在最坏情况下，上升时间和下降时间是$120ps$</p><p>【解析】无</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_clock_transition <span class="hljs-number">0.12</span> [get_clocks clk]<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-pre-CTS-setup-时钟不确定性（uncertainty）"><a href="#2-pre-CTS-setup-时钟不确定性（uncertainty）" class="headerlink" title="2. pre-CTS setup 时钟不确定性（uncertainty）"></a>2. pre-CTS setup 时钟不确定性（uncertainty）</h3><p>公式：<br>$$<br>setup：clock\ uncertainty&#x3D;|skew|+|jitter|+|margin|<br>$$<br>【注】：</p><ul><li>此处的公式是<strong>前-时钟树</strong>综合：Clock Tree Synthesis （CTS）的<strong>建立时间不确定</strong>公式。适用于DC lab4。</li></ul><ol><li><p><strong>时钟偏差（skew）</strong></p><p>【题目1.3】从时钟端口（port）到所有内部和外部寄存器时钟引脚（pin）的最大延迟为$300±30ps$<br>【解析】存在时钟偏差（shew）</p><p>​如下图所示，寄存时钟引脚的$±30ps$内部时钟偏差变化会<strong>导致$-60ps$的最坏情况偏斜</strong></p><p>​即，晚启动（$+30ps$）和早捕获（$-30ps$）</p><p>​即，<code>|skew|=|-60ps|=0.06ns</code></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323210947228.png" alt="image-20220323210947228"></p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_clock_uncertainty</span> -setup <span class="hljs-number">0</span>.<span class="hljs-number">06</span><span class="hljs-meta"> [get_clocks clk]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>时钟抖动（jitter）</strong>（具体还不好理解，目前知道考虑单倍即可）</p><p>【题目1.4】由于时钟抖动，时钟周期存在±40ps的不确定性</p><p>【解析】存在时钟抖动（jitter）</p><p>​一般情况下，jitter指的是cycle_to_cycle jitter &#x3D; T2 -T1、 T3-T2 …. 即两个相邻周期的差值。</p><p>​<strong>最坏情况下</strong>，$|jitter|&#x3D;|-40ps|&#x3D;0.04ns$</p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_clock_uncertainty</span> -setup <span class="hljs-number">0</span>.<span class="hljs-number">04</span><span class="hljs-meta"> [get_clocks clk]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>建立时间裕量（setup margin）</strong></p><p>【题目1.5】每个时钟周期需要$50ps$的建立时间裕量</p><p>【解析】无</p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_clock_uncertainty</span> -setup <span class="hljs-number">0</span>.<span class="hljs-number">05</span><span class="hljs-meta"> [get_clocks clk]</span><br></code></pre></td></tr></table></figure></li></ol><p>【总结】：<br>$$<br>setup：clock\ uncertainty&#x3D;|skew|+|jitter|+|margin|&#x3D;0.06+0.04+0.05&#x3D;0.15<br>$$<br>于是代码如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_clock_uncertainty</span> -setup <span class="hljs-number">0</span>.<span class="hljs-number">15</span><span class="hljs-meta"> [get_clocks clk]</span><br></code></pre></td></tr></table></figure><p>【注】：</p><ul><li><p>时钟不确定性均是考虑<strong>最坏情况</strong>，即当前所设置的时钟周期下，由于不确定性导致了实际的时钟周期短于所设置的时钟周期，但是logic依然需要在比所设置的时钟周期的实际时钟周期内完成其运算。因为如果完不成其逻辑运算，意味着需要增大我们所设置的时钟周期，这是<strong>我们所不希望看到的</strong>。</p></li><li><p>什么时候考虑uncertainty？</p><p>答：当题目给出<strong>设计(design)内部的组合逻辑的最值</strong>时，我们需要考虑uncertainty。根据uncertainty得到实际的时钟周期$T’$，从而约束端口的时序。</p><p>​如：问题4.2，out2端口<strong>内部</strong>组合逻辑的最大传播延时为$810ps$；问题5.0，Cin1和Cin2端口到Cout端口的最大延时为$2.45ns$（port-to-port，是纯组合逻辑，即<strong>内部</strong>组合逻辑的最大传播延时为$2.45ns$）。</p></li><li><p><strong>skew和jitter：</strong></p><p>在时序约束的时候，我们均是以<strong>【周期period】</strong>为视角，讨论如何在固定的周期内，让逻辑（logic）运算可以满足（逻辑综合，主要就是优化这些组合逻辑）。</p><p>对于skew，由于latency的不确定性，使得<strong>时钟沿</strong>到来产生了不确定性。而对于一个周期，是由两个时钟沿的，于是我们需要综合考虑两个时钟沿对于实际时钟（practical clock）的影响。最坏情况下，晚launch 30 早capture 30，周期变短$60ps$。</p><p>对于jitter，jitter的定义有很多，包括cycle-to-cycle 、Period-jitter。此处指的是cycle-to-cycle，即$±40ps$就是周期级别的不稳定性了。</p></li></ul><h2 id="2-3-输入时序约束（i-to-r）"><a href="#2-3-输入时序约束（i-to-r）" class="headerlink" title="2.3 输入时序约束（i-to-r）"></a>2.3 输入时序约束（i-to-r）</h2><h3 id="1-计算方法"><a href="#1-计算方法" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h3><p><strong>input-to-register</strong> 需要自己构造 外部的逻辑（external logic），我们需要计算出<strong>【input delay】</strong>来约束输入端口的时序。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323230740925.png" alt="image-20220323230740925"></p><p>令，input delay<br>$$<br>input\ delay &#x3D; T_{Clk-q}+T_M<br>$$<br>其中，</p><p>$T_{Clk-q}$：外部电路寄存器的传播延时</p><p>$T_M$：外部组合逻辑电路的最坏传播时间</p><p>如下图，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220323233129352.png" alt="image-20220323233129352"></p><h3 id="2-LAB解读"><a href="#2-LAB解读" class="headerlink" title="2. LAB解读"></a>2. LAB解读</h3><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324144236182.png" alt="image-20220324144236182" style="zoom:50%;" /><ol><li><p>【题目3.1】从端口data1和data2通过内部逻辑S的到达寄存器R1、R2的延时为$2.2ns$</p><p>【解析】由题可知，$T_N&#x3D;2.2ns$</p><p>​“走”的时间$T&#x3D;T_{Clk-q}+T_M+T_N&#x3D;input\ delay +T_N$</p><p>​“允许”的时间$T_允&#x3D;T-uncertainty-T_{setup}$</p><p>​需要满足$T_走≤T_允$，即$input\ delay &lt;T-uncertainty-T_{setup}-T_N$</p><p>​即，$input\ delay&#x3D;3-0.15-0.2-2.2&#x3D;0.45ns$</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_input_delay -max  <span class="hljs-number">0.45</span> -<span class="hljs-keyword">clock</span> clk [get_ports data*]  <br><br><span class="hljs-comment">#注意，此处是对输入的一些特定端口(special port)进行约束，故[get_ports data*]  </span><br></code></pre></td></tr></table></figure></li><li><p>【题目3.2】F3的数据到达<code>sel</code>的绝对时刻是$1.4ns$时刻</p><p>【解析】F3的数据到达<code>sel</code>的绝对时刻是$1.4ns$时刻，即在$ideal \ clock$对应的$t&#x3D;1.4ns$时，数据就要到达<code>sel</code>端口（port）</p><p>​但是F3的时钟同样存在latency，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324145651592.png" alt="image-20220324145651592"></p><p>​source_latency和network_latency加起来，总的latency为$1ns$，即当$t’&#x3D;0$时，$ideal \ clock$对应的$t&#x3D;1ns$</p><p>​因此$input\ delay&#x3D;absolute\ time-latency&#x3D;1.4-1&#x3D;0.4ns$</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_input_delay -max  <span class="hljs-number">0.4</span> -<span class="hljs-keyword">clock</span> clk [get_ports sel]<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-4-输出时序约束（r-to-o）"><a href="#2-4-输出时序约束（r-to-o）" class="headerlink" title="2.4 输出时序约束（r-to-o）"></a>2.4 输出时序约束（r-to-o）</h2><h3 id="1-计算方法-1"><a href="#1-计算方法-1" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h3><p><strong>register-to-output</strong> 需要自己构造 外部的逻辑（external logic），我们需要计算出<strong>【output delay】</strong>来约束输出端口的时序。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324152131449.png" alt="image-20220324152131449"></p><p>令，output delay<br>$$<br>output\ delay &#x3D; T_T+T_{SETUP}<br>$$<br>其中，</p><p>$T_T$：外部组合逻辑的最大传播延时</p><p>$T_{SETUP}$：外部所构造的capture寄存器的建立时间</p><p>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324152521036.png" alt="image-20220324152521036"></p><h3 id="2-LAB解读-1"><a href="#2-LAB解读-1" class="headerlink" title="2.LAB解读"></a>2.LAB解读</h3><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324151925490.png" alt="image-20220324151925490" style="zoom:55%;" /><ol><li><p>【问题4.1】out1端口<strong>外部</strong>组合逻辑的最大传播延时为$420ps$，F6的建立时间为$80ps$</p><p>【解析】外部组合逻辑的最大传播延时$T_&#x3D;420ps&#x3D;0.42ns$</p><p>​外部所构造的capture寄存器的建立时间$T_{SETUP}&#x3D;80ps&#x3D;0.08ns$</p><p>​于是，$output\ delay &#x3D; T_T+T_{SETUP}&#x3D;0.42+0.08&#x3D;0.5ns$</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_output_delay -max  <span class="hljs-number">0.5</span> -<span class="hljs-keyword">clock</span> clk [get_ports out1]<br></code></pre></td></tr></table></figure></li><li><p>【问题4.2】out2端口<strong>内部</strong>组合逻辑的最大传播延时为$810ps$</p><p>【解析】注意，此处涉及到<strong>内部组合逻辑</strong>，计算output delay需要构造如下图所示的<strong>内外部电路</strong></p><p>​因为涉及到<strong>内部电路</strong>，故还需要考虑<strong>uncertainty</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324152131449.png" alt="image-20220324152131449"></p><p>​由题可知，$T_S&#x3D;810ps&#x3D;0.81ns$</p><p>​根据定义，理想条件下，$T&#x3D;T_{Clk-q}+T_S+T_T+T_{SETUP}$（具体见数集（10））</p><p>​由于条件中，$T_{Clk-q}$未给出，可令为0；$output\ delay &#x3D; T_T+T_{SETUP}$</p><p>​于是，$T&#x3D;T_S+output\ delay$</p><p>​由于涉及到<strong>内部的寄存器</strong>，故需要考虑uncertainty，即</p><p>​$T’&#x3D;T-uncertainty&#x3D;3-0.15&#x3D;2.85ns$</p><p>​要让时序满足，则$T_S+output\ delay≤T’$，于是$output\ delay&#x3D;T’-T_S&#x3D;2.85-0.81&#x3D;2.04ns$</p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_output_delay</span> -max <span class="hljs-number">2</span>.<span class="hljs-number">04</span>  -clock clk<span class="hljs-meta"> [get_ports out2]</span><br></code></pre></td></tr></table></figure></li><li><p>【问题4.3】out3端口外的capture寄存器需要$400ps$的建立时间</p><p>【解析】根据电路图，out3端口外无组合逻辑电路，即$T_T&#x3D;0$</p><p>​于是，于是，$output\ delay &#x3D; T_T+T_{SETUP}&#x3D;0+400ps&#x3D;0.4ns$</p><p>【代码】</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_output_delay</span> -max  <span class="hljs-number">0</span>.<span class="hljs-number">4</span> -clock clk<span class="hljs-meta"> [get_ports out3] </span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-5-input-to-output时序约束"><a href="#2-5-input-to-output时序约束" class="headerlink" title="2.5 input-to-output时序约束"></a>2.5 input-to-output时序约束</h2><h3 id="1-计算方法-2"><a href="#1-计算方法-2" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h3><p><strong>input-to-output</strong> 时钟路径采用如下模型，我们需要构造R1、R2作为外部寄存器电路。</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324160753029.png" alt="image-20220324160753029" style="zoom: 60%;" /><p>对于<strong>input-to-output</strong> 时钟路径，进行时序约束的时候，我们需要考虑uncertainty，因为这是此处涉及到了<strong>设计（design）内部的组合逻辑</strong>，故需要考虑。</p><p>根据数集公式，理想情况下，$T&#x3D;T_{Clk-q}+T_S+T_{logic}+T_T+T_{SETUP}&#x3D;input\ delay+T_{logic}+output \ delay$</p><p>非理想情况下，$T’&#x3D;T-uncertainty&#x3D;input\ delay+T_{logic}+output \ delay$</p><p>得，$input\ delay+output \ delay&#x3D;T-uncertainty-T_{logic}$</p><p>根据计算得到的$input\ delay+output \ delay$进行分配。</p><h3 id="2-LAB解读-2"><a href="#2-LAB解读-2" class="headerlink" title="2. LAB解读"></a>2. LAB解读</h3><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324163229384.png" alt="image-20220324163229384" style="zoom:50%;" /><p>【题目5.0】Cin1和Cin2端口到Cout端口的最大延时为$2.45ns$</p><p>【解析】port-to-port，是纯组合逻辑，即<strong>内部</strong>组合逻辑的最大传播延时为$2.45ns$。</p><p>​即$T_{logic}&#x3D;2.45ns$</p><p>​$T’&#x3D;T-uncertainty&#x3D;3-0.15&#x3D;2.85ns$</p><p>​于是，$input\ delay+output \ delay&#x3D;T’-T_{logic}&#x3D;0.4$</p><p>​可以分配 0.2+0.2、0.3+0.1等，答案取0.3+0.1。</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_input_delay -max <span class="hljs-number">0.3</span> -<span class="hljs-keyword">clock</span> clk [get_ports Cin*]<br>set_output_delay -max <span class="hljs-number">0.1</span> -<span class="hljs-keyword">clock</span> clk [get_ports Cout]<br></code></pre></td></tr></table></figure><h1 id="3-环境属性约束"><a href="#3-环境属性约束" class="headerlink" title="3. 环境属性约束"></a>3. 环境属性约束</h1><h2 id="3-1-总论"><a href="#3-1-总论" class="headerlink" title="3.1 总论"></a>3.1 总论</h2><p>环境属性中主要有四个参数</p><ul><li>输入驱动和输入跳变</li><li>输出负载</li><li>线负载模型</li><li>操作条件，即PVT条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504201651495.png" alt="环境属性"></p><h2 id="3-2-输入驱动（input-drive）和输入跳变（transition）"><a href="#3-2-输入驱动（input-drive）和输入跳变（transition）" class="headerlink" title="3.2 输入驱动（input drive）和输入跳变（transition）"></a>3.2 输入驱动（input drive）和输入跳变（transition）</h2><p>如果没有设置输入驱动，则DC在计算输入时间的时候，会认为输入跳变为0，这是理想状态下。但为了更好约束时序，需要进行约束，使用指令如下：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_driving_cell<br><span class="hljs-comment"># 使用特定单元驱动设计，由于单元是库中现实的，因此存在输出跳变，于是得到设计的输入跳变</span><br>set_input_transition<br><span class="hljs-comment"># 直接设置设计的输入跳变</span><br></code></pre></td></tr></table></figure><h3 id="1-LAB解读"><a href="#1-LAB解读" class="headerlink" title="1. LAB解读"></a>1. LAB解读</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504205233383.png" alt="image-20220504205233383"></p><ol><li><p>【题目】：用以特定单元<code>bufbd1</code>，驱动除了<code>clk</code>和<code>Cin*</code>之外的所有输入端口</p><p>【解析】：使用指令1</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_driving_cell -lib_cell bufbd1 -library cb13fs120_tsmc_max \<br> [remove_from_collection [all_inputs] [get_ports <span class="hljs-string">&quot;clk Cin*&quot;</span>]]<br><span class="hljs-comment"># 或</span><br>set_driving_cell -lib_cell bufbd1 -library cb13fs120_tsmc_max \<br> [get_ports <span class="hljs-string">&quot;data* sel*&quot;</span>]]<br></code></pre></td></tr></table></figure></li><li><p>【题目】：<code>Cin*</code>是一个芯片级的输入端口，最大的输入跳变为120ps</p><p>【解析】：使用指令2</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_input_transition <span class="hljs-number">0.12</span> [get_ports Cin*]<br><span class="hljs-comment"># 如何知道时间单位？</span><br><span class="hljs-comment"># # 使用指令: report_lib &lt;lib_name&gt; 即可看到对应库的单位</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-3-输出负载（load）"><a href="#3-3-输出负载（load）" class="headerlink" title="3.3 输出负载（load）"></a>3.3 输出负载（load）</h2><p>约束设计最多可以负载多大的电容值，使用指令如下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">set_load</span><br></code></pre></td></tr></table></figure><h3 id="1-常见情况"><a href="#1-常见情况" class="headerlink" title="1. 常见情况"></a>1. 常见情况</h3><ol><li><p>负载特定值的电容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set_load</span> <span class="hljs-number">5</span><span class="hljs-meta"> [get_ports OUT1]</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504203221141.png" alt="image-20220504203221141"></p></li><li><p>负载相当与某单元某个引脚的电容值</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_load [load_of(my_lib/and2a0/A)] [get_ports OUT1]<br><span class="hljs-comment"># 注意: load_of 的使用</span><br><span class="hljs-comment"># OUT1驱动相当与and2a0单元A引脚的电容值</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504203247943.png" alt="image-20220504203247943"></p></li><li><p>负载相当与多个某单元某个引脚的电容值</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_load [<span class="hljs-keyword">expr</span> [load_of(my_lib/inv1a0/A) * <span class="hljs-number">3</span>]] [get_ports OUT1]<br><span class="hljs-comment"># 注意: expr 的使用</span><br><span class="hljs-comment"># OUT1驱动相当与inv1a0单元A引脚的3倍的电容值</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504203754758.png" alt="image-20220504203754758"></p></li></ol><h3 id="2-LAB解读-3"><a href="#2-LAB解读-3" class="headerlink" title="2. LAB解读"></a>2. LAB解读</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504202236089.png" alt="image-20220504202236089"></p><ol><li><p>【题目】：除了<code>Cout</code>，其他输出端口最大可以负载2倍<code>bufbd7</code>的<code>I</code>端口的电容</p><p>【解析】：除了<code>Cout</code>端口，其他的输出端口为<code>out1</code>、<code>out2</code>、<code>out3</code>，即其他端口可以使用<code>out*</code>表示</p><p>​   该题目要求，同上文所述的情况3</p><p>【代码】</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">set_load <span class="hljs-comment">[expr 2 * <span class="hljs-comment">[load_of cb13fs120_tsmc_max/bufbd7/I]</span>]</span> <span class="hljs-comment">[get_ports out*]</span><br></code></pre></td></tr></table></figure></li><li><p>【题目】：<code>Cout</code>端口，最大可以负载25fF的电容值</p><p>【解析】：属于情况1</p><p>【指令】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">set_load <span class="hljs-number">0.025</span> [get_ports Cout*]<br><span class="hljs-comment"># 如何看电容“单位”？同上问所述</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-4-线负载模型"><a href="#3-4-线负载模型" class="headerlink" title="3.4 线负载模型"></a>3.4 线负载模型</h2><h3 id="1-如何选定合适的线负载模型"><a href="#1-如何选定合适的线负载模型" class="headerlink" title="1. 如何选定合适的线负载模型"></a>1. 如何选定合适的线负载模型</h3><p>设定线负载模型，需要根据<strong>DC综合出来的面积进行设置</strong>。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># set_max_area 0</span><br><span class="hljs-comment"># compile</span><br>report_area<br><span class="hljs-comment"># 报出DC综合之后面积</span><br><span class="hljs-comment"># 根据面积，在report_lib.rpt中寻找合适的线负载模型</span><br></code></pre></td></tr></table></figure><p>部分<code>report_lib.rpt</code>内容如下：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TCL">Wire Loading Model Selection Group:<br><br>   Name           : predcaps<br>   <br>        Selection             Wire <span class="hljs-keyword">load</span> name<br>    min area   max area<br>   -------------------------------------------<br>        <span class="hljs-number">0.00</span>     <span class="hljs-number">200.00</span>          ForQA<br>      <span class="hljs-number">200.00</span>    <span class="hljs-number">8000.00</span>          <span class="hljs-number">8000</span><br>     <span class="hljs-number">8000.00</span>   <span class="hljs-number">16000.00</span>          <span class="hljs-number">16000</span><br>    <span class="hljs-number">16000.00</span>   <span class="hljs-number">35000.00</span>          <span class="hljs-number">35000</span><br>    <span class="hljs-number">35000.00</span>   <span class="hljs-number">70000.00</span>          <span class="hljs-number">70000</span><br>    <span class="hljs-number">70000.00</span>   <span class="hljs-number">140000.00</span>         <span class="hljs-number">140000</span><br>    <span class="hljs-number">140000.00</span>  <span class="hljs-number">280000.00</span>         <span class="hljs-number">280000</span><br>    <span class="hljs-number">280000.00</span>  <span class="hljs-number">540000.00</span>         <span class="hljs-number">540000</span><br>    <span class="hljs-number">540000.00</span>  <span class="hljs-number">1000000.00</span>        <span class="hljs-number">1000000</span><br>    <span class="hljs-number">1000000.00</span> <span class="hljs-number">2000000.00</span>        <span class="hljs-number">2000000</span><br>    <span class="hljs-number">2000000.00</span> <span class="hljs-number">4000000.00</span>        <span class="hljs-number">4000000</span><br>    <span class="hljs-number">4000000.00</span> <span class="hljs-number">8000000.00</span>        <span class="hljs-number">8000000</span><br></code></pre></td></tr></table></figure><p>关于<strong>线负载模型的模式</strong>，笔者目前没有用到，不在赘述。</p><h3 id="2-LAB解读-4"><a href="#2-LAB解读-4" class="headerlink" title="2. LAB解读"></a>2. LAB解读</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504211816320.png" alt="image-20220504211816320"></p><p>【题目】：根据面积选定合适的线负载模型</p><p>【代码】</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># DC综合之后，面积大约在3000~4000左右，于是选择线负载模型“8000”</span><br><span class="hljs-keyword">set</span> auto_wire_load_selection false<br><span class="hljs-comment"># 需要先取消掉系统自动设置的线负载模型，才能人为重新设置</span><br>set_wire_load_model -name <span class="hljs-number">8000</span><br><span class="hljs-comment"># 设置线负载模型为8000</span><br></code></pre></td></tr></table></figure><h2 id="3-5-操作条件（PVT条件）"><a href="#3-5-操作条件（PVT条件）" class="headerlink" title="3.5 操作条件（PVT条件）"></a>3.5 操作条件（PVT条件）</h2><p>所谓PVT，即<code>process</code>制程、<code>voltage</code>电压、<code>temperature</code>温度</p><p>不同的PVT条件下，DC计算出来的延时是不一样的。通常，制程越慢（<code>ss</code>）、温度越高、电压越低，单元延时越高，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504210154363.png" alt="image-20220504210154363"></p><p>我们希望，芯片在各种各样的PVT情况<strong>均可以正常工作</strong>。</p><h3 id="1-如何知道有哪些PVT条件"><a href="#1-如何知道有哪些PVT条件" class="headerlink" title="1. 如何知道有哪些PVT条件"></a>1. 如何知道有哪些PVT条件</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl">list_lib<br><span class="hljs-comment"># 列出所有的库，需要注意的library下面名字，即所对应.db库的库名&lt;lib_name&gt;</span><br>report_lib &lt;lib_name&gt; &gt; &lt;lib_name&gt;.rpt<br><span class="hljs-comment"># 查看&lt;lib_name&gt;.rpt文件，利用ctrl+F搜索Operation Condition即可找到.db提供的所有PVT条件</span><br><span class="hljs-comment"># 选择你需要的PVT条件进行设置即可</span><br>set_operating_condition &lt;PVT_name&gt;<br></code></pre></td></tr></table></figure><p>部分<code>report_lib.rpt</code>内容如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Operating Conditions</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>    <span class="hljs-attribute">Operating Condition Name</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">cb13fs120_tsmc_max</span><br>    <span class="hljs-attribute">Library</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">cb13fs120_tsmc_max</span><br>    <span class="hljs-attribute">Process</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">  1.20</span><br>    <span class="hljs-attribute">Temperature</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">125.00</span><br>    <span class="hljs-attribute">Voltage</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">  1.08</span><br>    <span class="hljs-attribute">Interconnect Model</span><span class="hljs-punctuation"> :</span> <span class="hljs-string">worst_case_tree</span><br></code></pre></td></tr></table></figure><p>可知，PVT条件名为<code>cb13fs120_tsmc_max</code></p><h3 id="2-LAB解读-5"><a href="#2-LAB解读-5" class="headerlink" title="2. LAB解读"></a>2. LAB解读</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504211318262.png" alt="image-20220504211318262"></p><p>【题目】：该<code>.db</code>库只有一个PVT条件，设置此PVT条件为当前的PVT条件</p><p>【代码】</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">set_operating_condition -<span class="hljs-built_in">max</span> cb13fs120_tsmc_max<br></code></pre></td></tr></table></figure><h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="1-电路图"><a href="#1-电路图" class="headerlink" title="1. 电路图"></a>1. 电路图</h2><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324164338943.png" alt="image-20220324164338943" style="zoom: 67%;" /><h2 id="2-题干要求"><a href="#2-题干要求" class="headerlink" title="2. 题干要求"></a>2. 题干要求</h2><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220324164437493.png" alt="时序和面积约束"></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220504212747617.png" alt="环境属性约束条件"></p><h2 id="3-完整指令代码"><a href="#3-完整指令代码" class="headerlink" title="3. 完整指令代码"></a>3. 完整指令代码</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment">#.con file</span><br><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   CLOCK DEFINITION              #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><span class="hljs-comment"># A 333Mhz clock is a 3.0ns period:</span><br><span class="hljs-comment">#</span><br>create_clock -period <span class="hljs-number">3.0</span> [get_ports clk]<br><br><br><span class="hljs-comment"># External clock source latency is 700ps or 0.7ns</span><br><span class="hljs-comment">#</span><br>set_clock_latency -<span class="hljs-keyword">source</span>  -max <span class="hljs-number">0.7</span> [get_clocks clk] <br><br><br><span class="hljs-comment"># The maximum internal clock network insertion delay or latency is 300ps or 0.3 ns:</span><br><span class="hljs-comment">#</span><br>set_clock_latency -max <span class="hljs-number">0.3</span> [get_clocks clk]<br><br><br><span class="hljs-comment"># The +/-30ps internal clock delay variation to register clock pins results in a 60ps worst case skew or uncertainty, if you launch</span><br><span class="hljs-comment"># late (+30ps) and capture early (-30ps)r; Add 40ps due to jitter and 50ps for setup margin;</span><br><span class="hljs-comment"># This equals 150ps or 0.15 ns of total uncertainty.</span><br><span class="hljs-comment">#</span><br>set_clock_uncertainty -setup <span class="hljs-number">0.15</span> [get_clocks clk]<br><br><br><span class="hljs-comment"># The maximum clock transition is 120ps or 0.12ns</span><br><span class="hljs-comment">#</span><br>set_clock_transition <span class="hljs-number">0.12</span> [get_clocks clk]<br><br><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   INPUT TIMING                  #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><span class="hljs-comment"># The maximum &quot;input delay&quot; (external) on ports data1 and data2 is: </span><br><span class="hljs-comment"># clock period - clock uncertainty - delay of S - register setup time = </span><br><span class="hljs-comment">#     3.0      -      0.15         -     2.2   -      0.2            = 0.45ns</span><br><span class="hljs-comment"># </span><br>set_input_delay -max  <span class="hljs-number">0.45</span> -<span class="hljs-keyword">clock</span> clk [get_ports data*]  <br><br><br><span class="hljs-comment"># The latest arrival time at port sel is 1.4ns (absolute time). The total clock insertion delay or latency to the external </span><br><span class="hljs-comment"># registers is 700ps + 300ps or 1.0ns. Therefore, the relative input delay on the port is 1.4 -1.0 = 0.4ns</span><br><span class="hljs-comment">#</span><br>set_input_delay -max  <span class="hljs-number">0.4</span> -<span class="hljs-keyword">clock</span> clk [get_ports sel]<br><br><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   OUTPUT TIMING                 #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><span class="hljs-comment"># The output delay at port out1 is 420ps + 80ps = 500ps or 0.5ns</span><br><span class="hljs-comment">#</span><br>set_output_delay -max  <span class="hljs-number">0.5</span> -<span class="hljs-keyword">clock</span> clk [get_ports out1]<br><br><br><span class="hljs-comment"># The internal delay to out2 is 810ps. The external capturing clock edge happens 3ns after the launch edge, </span><br><span class="hljs-comment"># minus the uncertainty of 0.15ns, or 2.85ns after launch. To constrain the internal delay to 0.81ns the </span><br><span class="hljs-comment"># output delay must therefore be constrained to 2.85ns - 0.81ns = 2.04ns.</span><br><span class="hljs-comment">#</span><br>set_output_delay -max <span class="hljs-number">2.04</span>  -<span class="hljs-keyword">clock</span> clk [get_ports out2]<br><br><br><span class="hljs-comment"># The setup time requirement on port out3 is 400ps or 0.4ns with respect to the capturing register&#x27;s clock. </span><br><span class="hljs-comment"># This is, by definition, the &quot;set_output_delay&quot; value</span><br><span class="hljs-comment">#</span><br>set_output_delay -max  <span class="hljs-number">0.4</span> -<span class="hljs-keyword">clock</span> clk [get_ports out3] <br><br><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   COMBINATIONAL LOGIC TIMING    #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><span class="hljs-comment"># The maximum delay through the combinational logic is 2.45ns. This can be constrained by pretending that there are </span><br><span class="hljs-comment"># launching registers on the input ports Cin1 and Cin2 and capturing registers on the output port Cout, and applying </span><br><span class="hljs-comment"># corresponding input and output delays. The sum of the external input and output delay values must be equal to the </span><br><span class="hljs-comment"># clock period minus the clock uncertainty minus the maximum combo delay = 3ns - 0.15ns - 2.45ns = 0.4ns. </span><br><span class="hljs-comment"># This means that the input and output delay values can be 0.4 and 0.0, or 0.2 and 0.2, or 0.1 and 0.3, etc., respectively.</span><br><span class="hljs-comment">#</span><br>set_input_delay -max <span class="hljs-number">0.3</span> -<span class="hljs-keyword">clock</span> clk [get_ports Cin*]<br>set_output_delay -max <span class="hljs-number">0.1</span> -<span class="hljs-keyword">clock</span> clk [get_ports Cout]<br><br> <br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   DESIGN AREA                   #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><span class="hljs-comment"># Area Constraint</span><br><span class="hljs-comment">#</span><br>set_max_area <span class="hljs-number">0</span><br><br><span class="hljs-comment">###################################</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">#   ENVIRONMENTAL ATTRIBUTES      #</span><br><span class="hljs-comment">#                                 #</span><br><span class="hljs-comment">###################################</span><br><br><br><span class="hljs-comment"># All input ports, except clk and Cin, are driven by bufbd1 buffers</span><br><span class="hljs-comment">#</span><br>set_driving_cell -lib_cell bufbd1 -library cb13fs120_tsmc_max \<br> [remove_from_collection [all_inputs] [get_ports <span class="hljs-string">&quot;clk Cin*&quot;</span>]]<br><br><br><span class="hljs-comment"># Port Cin is a chip level input and has an input transition of 120ps or 0.12 ns</span><br><span class="hljs-comment">#</span><br>set_input_transition <span class="hljs-number">0.12</span> [get_ports Cin*]<br><br><br><span class="hljs-comment"># All outputs, except Cout, drive 2x bufbd7 loads</span><br><span class="hljs-comment">#</span><br>set_load [<span class="hljs-keyword">expr</span> <span class="hljs-number">2</span> * [load_of cb13fs120_tsmc_max/bufbd7/I]] [get_ports out*]<br><br><br><span class="hljs-comment"># Cout drives 25fF, or .025 pF</span><br><span class="hljs-comment">#</span><br>set_load <span class="hljs-number">0.025</span> [get_ports Cout*]<br><br><br><span class="hljs-comment"># From the wireload model selection table, a design size between 200 and </span><br><span class="hljs-comment"># 8000 area units uses the model called &quot;8000&quot;; The default wireload </span><br><span class="hljs-comment"># mode in this library in &quot;enclosed&quot;</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">set</span> auto_wire_load_selection false<br>set_wire_load_model -name <span class="hljs-number">8000</span><br><br><br><span class="hljs-comment"># operating condition use to scale cell and net delays.</span><br><span class="hljs-comment">#</span><br>set_operating_condition -max cb13fs120_tsmc_max<br><br><br>compile<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
      <tag>DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的scenario脚本</title>
    <link href="/2022/05/03/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84scenario%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/05/03/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84scenario%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>本文记录了ICC实验中所需要用到的一个scenario脚本，脚本十分简单，仅作为学习练习使用。</p><hr><span id="more"></span><h1 id="1-工程目录"><a href="#1-工程目录" class="headerlink" title="1. 工程目录"></a>1. 工程目录</h1><figure class="highlight gherkin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs gherkin">./·········································工程根目录<br>|<span class="hljs-string">——用户.mw设计库</span><br><span class="hljs-string"></span>|<span class="hljs-string">——ref</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——db··································物理/逻辑库(.db)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——design_data·························设计相关文件(.v .sdc .def .tdf)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——mw_lib······························mw库(宏单元、IO单元等)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——tech································工艺文件(.tf)</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——tlup································TLU+模型(.tlup .map)</span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string">——scripts</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<span class="hljs-string">——scenario.tcl························本scenario脚本文件</span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string">——.synopsys_dc.setup</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h1 id="2-库和操作环境-PVT"><a href="#2-库和操作环境-PVT" class="headerlink" title="2. 库和操作环境(PVT)"></a>2. 库和操作环境(PVT)</h1><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># 如何查看库</span><br>icc_shell&gt; list_libs<br>Logical Libraries:<br>-------------------------------------------------------------------------<br>Library         File                    Path<br>-------         ----                    ----<br>M smic18_ss_1p62v_125c smic18_ss_1p62v_125c.db  &lt;prj_path&gt;/ref/db<br>m smic18_ff_1p98v_0c smic18_ff_1p98v_0c.db      &lt;prj_path&gt;/ref/db<br>...<br>...<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># 注意上文的Library, 即所对应的.db文件的库名</span><br><span class="hljs-comment"># 最大库: smic18_ss_1p62v_125c.db; 库名: smic18_ss_1p62v_125c</span><br><span class="hljs-comment"># 最小库: smic18_ff_1p98v_0c.db; 库名: smic18_ff_1p98v_0c</span><br><br><span class="hljs-comment"># 如何查看操作环境(PVT)</span><br>icc_shell&gt; report_lib smic18_ss_1p62v_125c &gt; smic18_ss_1p62v_125c.log<br>icc_shell&gt; report_lib smic18_ff_1p98v_0c &gt; smic18_ff_1p98v_0c.log<br><br><span class="hljs-comment"># 在./下面即可找到smic18_ss_1p62v_125c.log和smic18_ff_1p98v_0c.log, 打开</span><br><span class="hljs-comment"># smic18_ss_1p62v_125c.log部分内容如下: </span><br>****************************************<br>Report : library<br>Library: smic18_ss_1p62v_125c<br>Version: D<span class="hljs-number">-2010.03</span>-ICC-SP5<span class="hljs-number">-2</span><br>Date   : Tue May  <span class="hljs-number">3</span> <span class="hljs-number">20</span>:<span class="hljs-number">09</span>:<span class="hljs-number">59</span> <span class="hljs-number">2022</span><br>****************************************<br>...<br>...<br><br>Operating Conditions:<br><br><br>    Operating Condition Name : ss_1p62v_125c<br>    Library : smic18_ss_1p62v_125c<br>    Process :   <span class="hljs-number">1.00</span><br>    Temperature : <span class="hljs-number">125.00</span><br>    Voltage :   <span class="hljs-number">1.62</span><br>    Interconnect Model : balanced_tree<br><br>    Power Rails:<br>         Rail Voltage Value<br>    -------------------------<br>         VDD           <span class="hljs-number">1.62</span><br>         VSS           <span class="hljs-number">0.00</span><br>...<br>...<br><span class="hljs-comment"># smic18_ss_1p62v_125c.log部分内容如下: </span><br>****************************************<br>Report : library<br>Library: smic18_ff_1p98v_0c<br>Version: D<span class="hljs-number">-2010.03</span>-ICC-SP5<span class="hljs-number">-2</span><br>Date   : Tue May  <span class="hljs-number">3</span> <span class="hljs-number">20</span>:<span class="hljs-number">11</span>:<span class="hljs-number">05</span> <span class="hljs-number">2022</span><br>****************************************<br>...<br>...<br>Operating Conditions:<br><br><br>    Operating Condition Name : ff_1p98v_0c<br>    Library : smic18_ff_1p98v_0c<br>    Process :   <span class="hljs-number">1.00</span><br>    Temperature :   <span class="hljs-number">0.00</span><br>    Voltage :   <span class="hljs-number">1.98</span><br>    Interconnect Model : balanced_tree<br><br>    Power Rails:<br>         Rail Voltage Value<br>    -------------------------<br>         VDD           <span class="hljs-number">1.98</span><br>         VSS           <span class="hljs-number">0.00</span><br>...<br>...<br><br><span class="hljs-comment"># 可以利用crtl+F查找&quot;Operating Conditions&quot;找到对应的操作环境(PVT)</span><br><span class="hljs-comment"># 根据上文可知, smic18_ss_1p62v_125c库【只有一个】操作环境(PVT):ss_1p62v_125c</span><br><span class="hljs-comment"># 同理, 可知smic18_ff_1p98v_0c【只有一个】操作环境(PVT):ff_1p98v_0c</span><br></code></pre></td></tr></table></figure><h1 id="3-scenario脚本编写"><a href="#3-scenario脚本编写" class="headerlink" title="3. scenario脚本编写"></a>3. scenario脚本编写</h1><p>此处，设置4个<code>scenario</code></p><p>即：<code>func_ss_rcmax test_ss_rcmax func_ff_rcmin test_ff_rcmin</code></p><p>我们知道：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">scenario = mode × delay corner = mode × PVT × RC corner<br><span class="hljs-comment"># mode(模式): 常见的有功能模式(正常工作模式)、扫描链模式(测试模式)</span><br><span class="hljs-comment"># PVT(工艺角):常见有ff、tt、ss</span><br><span class="hljs-comment"># RC corner(RC寄生参数延时模型):tlup模型, 有max.tlup和min.tlup</span><br></code></pre></td></tr></table></figure><p>解释如下</p><ul><li><code>func_ss_rcmax</code>：功能模式、最差工艺角（PVT）<code>ss</code>、最大RC延迟<code>max.tlup</code></li><li><code>test_ss_rcmax </code>：扫描链模式、最差工艺角（PVT）<code>ss</code>、最大RC延迟<code>max.tlup</code></li><li><code>func_ff_rcmin </code>：功能模式、最好工艺角（PVT）<code>ff</code>、最小RC延迟<code>min.tlup</code></li><li><code>test_ff_rcmin</code>：扫描链模式、最好工艺角（PVT）<code>ff</code>、最小RC延迟<code>min.tlup</code></li></ul><p>脚本如下：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs tcl">remove_scenario -all<br><span class="hljs-comment"># 移除之前设置的所有的scenario</span><br><br><span class="hljs-comment"># scenario 1</span><br>create_scenario func_ss_rcmax<br><span class="hljs-comment"># scenario命名格式:mode_PVT_RC corner</span><br><br>set_scenario_options -setup true -hold false<br><span class="hljs-comment"># 用于CTS之前, CTS之前考虑hold time是没有意义的</span><br><span class="hljs-comment">#set_scenario_options -setup true -hold true</span><br><span class="hljs-comment"># 用于CTS之后, CTS之后需要考虑hold time</span><br><br><span class="hljs-comment"># 低端工艺, 如本文中的.18工艺, past_CTS只需要考虑hold time</span><br><span class="hljs-comment"># 而高端工艺, past_CTS需要考虑hold time和setup time</span><br><span class="hljs-comment"># 此处, 笔者在past_CTS阶段hold time和setup time均考虑了</span><br><br><span class="hljs-comment"># 设置.tlup和.map文件 -&gt; RC corner</span><br>set_tlu_plus_files  \<br>    -max_tluplus ./ref/tlup/mcu_max.tluplus \<br>    -min_tluplus ./ref/tlup/mcu_min.tluplus \<br>    -tech2itf_map ./ref/tlup/SmicSPM8RR7R_018_mixRF_p1mt6_cell_1833.map<br><br><span class="hljs-comment"># 设置PVT, 也可在.sdc文件中设置</span><br>set_operating_conditions  \<br>    -analysis_type on_chip_variation \<br>    -max ss_1p62v_125c \<br>    -min ss_1p62v_125c \<br>    -library smic18_ss_1p62v_125c<br>    <br>set_timing_derate -early <span class="hljs-number">0.95</span><br><span class="hljs-comment"># 设置时钟比率, 此处涉及到OCV相关知识, 此处不展开讲</span><br><span class="hljs-comment"># 需要注意的是，不同的PVT有不同的设置:</span><br><span class="hljs-comment"># worst case corners(ss): 只能设置-early 0.95(&lt;1, 具体数值看设计要求)</span><br><span class="hljs-comment"># best case corners(ff): 只能设置-late 1.05(&gt;1, 具体数值看设计要求)</span><br><span class="hljs-comment"># type case corners(tt): 可以设置-early和-late</span><br>    <br><span class="hljs-comment"># 读入.sdc files -&gt; constraints和mode</span><br><span class="hljs-comment"># .sdc文件中设置了对应的模式(功能/测试)</span><br>read_sdc ./ref/design_data/fdnoflash_scan.sdc<br><span class="hljs-comment"># func_mode.sdc的名字为fdnoflash_scan.sdc</span><br><br><span class="hljs-comment"># scenario 2</span><br>create_scenario test_ss_rcmax<br>set_scenario_options -setup true -hold false<br><span class="hljs-comment">#set_scenario_options -setup true -hold true</span><br><br>set_tlu_plus_files  \<br>    -max_tluplus ./ref/tlup/mcu_max.tluplus \<br>    -min_tluplus ./ref/tlup/mcu_min.tluplus \<br>    -tech2itf_map ./ref/tlup/SmicSPM8RR7R_018_mixRF_p1mt6_cell_1833.map<br><br>set_operating_conditions  \<br>    -analysis_type on_chip_variation \<br>    -max ss_1p62v_125c \<br>    -min ss_1p62v_125c \<br>    -library smic18_ss_1p62v_125c<br>set_timing_derate -early <span class="hljs-number">0.95</span><br>    <br>read_sdc ./ref/design_data/test_mode.sdc<br><br><br><span class="hljs-comment"># scenario 3</span><br>create_scenario func_ff_rcmin<br>set_scenario_options -setup true -hold false<br><span class="hljs-comment">#set_scenario_options -setup true -hold true</span><br><br>set_tlu_plus_files  \<br>    -max_tluplus ./ref/tlup/mcu_min.tluplus \<br>    -tech2itf_map ./ref/tlup/SmicSPM8RR7R_018_mixRF_p1mt6_cell_1833.map<br><br>set_operating_conditions  \<br>    -analysis_type on_chip_variation \<br>    -max ff_1p98v_0c \<br>    -min ff_1p98v_0c \<br>    -library smic18_ff_1p98v_0c<br>set_timing_derate -late <span class="hljs-number">1.05</span><br><br>read_sdc ./ref/design_data/fdnoflash_scan.sdc<br><br><br><span class="hljs-comment"># scenario 4</span><br>create_scenario test_ff_rcmin<br>set_scenario_options -setup true -hold false<br><span class="hljs-comment">#set_scenario_options -setup true -hold true</span><br><br>set_tlu_plus_files  \<br>    -max_tluplus ./ref/tlup/mcu_min.tluplus \<br>    -tech2itf_map ./ref/tlup/SmicSPM8RR7R_018_mixRF_p1mt6_cell_1833.map<br><br>set_operating_conditions  \<br>    -analysis_type on_chip_variation \<br>    -max ff_1p98v_0c \<br>    -min ff_1p98v_0c \<br>    -library smic18_ff_1p98v_0c<br>set_timing_derate -late <span class="hljs-number">1.05</span><br><br>read_sdc ./ref/design_data/test_mode.sdc<br><br><br>set_active_scenarios &#123;func_ss_rcmax test_ss_rcmax func_ff_rcmin test_ff_rcmin&#125;<br><span class="hljs-comment"># 激活所有设置的scenario</span><br>set_app_var timing_remove_clock_reconvergence_pessimism true<br><span class="hljs-comment"># 公共时钟路径不应用timing_derate, 公共路径如果应用, 则太悲观了</span><br>current_scenario func_ss_rcmax<br><span class="hljs-comment"># 设置当前的scenario为func_ss_rcmax</span><br></code></pre></td></tr></table></figure><h1 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h1><h2 id="4-1-pre-CTS阶段"><a href="#4-1-pre-CTS阶段" class="headerlink" title="4.1 pre-CTS阶段"></a>4.1 pre-CTS阶段</h2><p>pre-CTS，<strong>即CTS之前的阶段，包括平面规划和布局设计等</strong></p><p>在完成【<code>.v</code>文件的导入之后】即可执行</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">source</span> ./scripts/scenario.tcl<br></code></pre></td></tr></table></figure><p>接下来进行的所有操作和优化均会考虑到<code>scenario.tcl</code>中设置的4个<code>scenario</code></p><h2 id="4-2-post-CTS阶段"><a href="#4-2-post-CTS阶段" class="headerlink" title="4.2 post-CTS阶段"></a>4.2 post-CTS阶段</h2><p>post-CTS，<strong>即CTS之后的阶段，包括CTS布线、布线设计等</strong></p><p>在完成【<code>clock_opt -only_cts -no_clock_route</code>指令，且执行无误】即执行</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">source</span> ./scripts/scenario.tcl<br></code></pre></td></tr></table></figure><p>注意，此时的<code>scenario.tcl</code>中的<code>set_scenario_options -setup true -hold false</code>应该被注释，而<code>set_scenario_options -setup true -hold true</code>被激活，如下所示：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># set_scenario_options -setup true -hold false</span><br>set_scenario_options -setup true -hold true<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ICC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
      <tag>ICC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（13）导线互连</title>
    <link href="/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8813%EF%BC%89%E5%AF%BC%E7%BA%BF%E4%BA%92%E8%BF%9E/"/>
    <url>/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8813%EF%BC%89%E5%AF%BC%E7%BA%BF%E4%BA%92%E8%BF%9E/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述数字集成电路中的互连问题，包括串绕、寄生、电迁移、电压降等问题。</p><hr><span id="more"></span><h1 id="第四章-导线"><a href="#第四章-导线" class="headerlink" title="第四章 导线"></a>第四章 导线</h1><h2 id="1-互连参数"><a href="#1-互连参数" class="headerlink" title="1. 互连参数"></a>1. 互连参数</h2><h3 id="1-导线材料"><a href="#1-导线材料" class="headerlink" title="1. 导线材料"></a>1. 导线材料</h3><ul><li>金属层</li><li>多晶硅层</li><li>n+或p+扩散层</li></ul><h3 id="2-互连参数——电容"><a href="#2-互连参数——电容" class="headerlink" title="2. 互连参数——电容"></a>2. 互连参数——电容</h3><ul><li>平板电容模型</li><li>边缘电容模型</li></ul><h3 id="3-互连参数——电阻"><a href="#3-互连参数——电阻" class="headerlink" title="3. 互连参数——电阻"></a>3. 互连参数——电阻</h3><p>方块电阻：<br>$$<br>R_\Box&#x3D;\frac{\rho}{H}<br>$$<br>其中，$H$​为工艺常数</p><p>知道了方块电阻$R_\Box$，可求得电阻$R$，有<br>$$<br>R&#x3D;R_\Box\frac{L}{W}<br>$$</p><p><strong>扩展：</strong></p><p>​芯片中的互连，一般高层的金属层一般$W$​较大，于是电阻更小。</p><p>​即$W↑\ →\ R↓\ →\ 功耗P↓,\ RC↓ $</p><p>​因此高层金属层，如$M_4、M_5$​，常用于时钟、电源等关键信号的布线</p><p>​中间层金属用作于信号线。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211126205131401.png"></p><h3 id="4-互连参数——电感"><a href="#4-互连参数——电感" class="headerlink" title="4. 互连参数——电感"></a>4. 互连参数——电感</h3><p>当频率上$GHz$的时候，才会去考虑电感的作用。</p><h2 id="2-导线模型"><a href="#2-导线模型" class="headerlink" title="2. 导线模型"></a>2. 导线模型</h2><h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h3><ul><li><p>理想导线</p><p>​一般用于较大尺寸的工艺中</p></li><li><p>集总模型</p><ul><li>适用情况：电阻小；开关频率中低水平</li><li>内容：将一条导线上的电容集总成一个电容</li></ul></li><li><p>集总$RC$​模型</p><ul><li>适用情况：电阻较大，不可忽略；开关频率中低水平</li><li>内容：将一条导线上的电容集总成一个电容，电阻集总成一个电阻</li><li>不足：当互连线<strong>太长</strong>时，该模型当变得保守</li></ul></li><li><p>分布$RC$​模型</p><ul><li>适用情况：互连线长；导线电阻、电容不可忽略</li><li>根据推导可知，<strong>一条导线的延时同他的长度呈现二次方关系</strong></li><li>和集总$RC$模型对比<ul><li>分布$RC$模型得到的**延时是集总$RC$模型的$1&#x2F;2$**​</li><li>适用于<strong>长互连线</strong></li></ul></li></ul></li><li><p>传输线模型</p><ul><li>适用情况：高频、射频、微波；互连材料好，其导线电阻保持在一定范围内。</li><li>内容：高频情况下，需要考虑<strong>电感</strong>的作用</li></ul></li></ul><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>如何减小【长导线】使得【延时变长】的作用：</p><ul><li><p>使用更好互连材料（$Al→Cu$​）和绝缘材料，集成宽度和低电容是关键。</p></li><li><p>区分局部和全局导线，保证电阻大小能被控制是主要的。</p><p>（高层金属导线走关键信号、时钟、电源等全局信号，底层金属导线走普通信号）</p></li></ul><h1 id="第九章-互连问题"><a href="#第九章-互连问题" class="headerlink" title="第九章 互连问题"></a>第九章 互连问题</h1><p>寄生参数对于电路的危害：</p><ul><li>影响信号的完整性</li><li>降低信号的性能<ul><li>增加延时</li><li>增加功耗</li></ul></li></ul><p>寄生的类型——电容、电阻、电感</p><h2 id="1-电容寄生效应"><a href="#1-电容寄生效应" class="headerlink" title="1. 电容寄生效应"></a>1. 电容寄生效应</h2><p>此处讨论电容寄生主要是<font color=red><b>串扰</b></font></p><h3 id="1-串扰的定义："><a href="#1-串扰的定义：" class="headerlink" title="1. 串扰的定义："></a>1. 串扰的定义：</h3><p>由相邻的信号线之间不希望有的耦合引起的干扰</p><p><strong>小贴士：</strong></p><ul><li><p>耦合有多种，常常是电容性的耦合</p></li><li><p>串扰引起的噪声难以捕捉</p></li></ul><h3 id="2-串扰的危害"><a href="#2-串扰的危害" class="headerlink" title="2. 串扰的危害"></a>2. 串扰的危害</h3><ul><li>串扰将使得导线的延时难以预见，故产生了下文<strong>“可预见的导线延时设计”</strong></li></ul><h3 id="3-可预见的导线设计"><a href="#3-可预见的导线设计" class="headerlink" title="3. 可预见的导线设计"></a>3. 可预见的导线设计</h3><ul><li><p><font color=red><b>估计改进</b></font></p><ul><li>方法：不断参数提取，不断仿真，不断优化</li><li>缺点：设计过程需要多次重复，时间长</li><li>备注：最常用</li></ul></li><li><p><font color=red><b>能动性的版图生成</b></font></p><ul><li>布线<strong>程序</strong>考虑相邻导线的作用</li><li>缺点：主要由EDA工具完成，在如今EDA工具的要求高</li><li>备注：有吸引力；已经有一些EDA工具具备该功能</li></ul></li><li><p><font color=red><b>可预测的结构</b></font></p><ul><li><p>方法：<strong>密集型布线结构</strong>——同层信号线使用电源线隔离，相邻层采用垂直布线。</p></li><li><p>缺点：面积和电容增加了+5%，功耗和延时增加</p></li><li><p>优点：减小了电容串扰，延时差别也下降到不超过2%</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211126214746698.png"></p></li></ul></li><li><p><font color=red><b>采用低介电常数的绝缘材料</b></font></p><ul><li>方法：利用$C&#x3D;\frac{\varepsilon ·S}{d}$可知，电容正比于介电常数$\varepsilon$​​。故采用低介电常数绝缘材料可以有效减小寄生的互连电容​​</li></ul></li><li><p><font color=red><b>避免最坏情况的发生</b></font></p><ul><li>方法：利用总线接口和总线传输数据避免引起最坏延时情况的导线翻转。</li><li>缺点：搭建总线接口有额外的硬件开销</li><li>优点：总线传输数据——减小了翻转次数，降低功耗；总线接口可以较小延时</li></ul></li></ul><h3 id="4-克服电容串扰的方法"><a href="#4-克服电容串扰的方法" class="headerlink" title="4. 克服电容串扰的方法"></a>4. 克服电容串扰的方法</h3><ul><li>尽量避免浮空节点，对串扰敏感的节点，加保持器降低阻抗、</li><li>敏感节点应当很好地与全摆幅信号隔离  </li><li>在满足时序约束的范围内尽可能加大上升（下降）时间  </li><li>在敏感的低摆幅布线网络中采用差分信号传输方法 </li><li>不要使两条信号线之间的电容太大  </li><li>在两个信号之间增加屏蔽线（即加$GND$ 或$V_{DD}$​），使线间电容变成接地电容来消除串扰，但增加了电容负载  </li><li>使用屏蔽层$GND$ 或$V_{DD}$</li></ul><h2 id="2-电阻寄生效应"><a href="#2-电阻寄生效应" class="headerlink" title="2. 电阻寄生效应"></a>2. 电阻寄生效应</h2><p>此处讨论电阻寄生主要是<font color=red><b>导线电压降、电迁移、性能（延时）</b></font></p><h3 id="1-导线电压降"><a href="#1-导线电压降" class="headerlink" title="1. 导线电压降"></a>1. 导线电压降</h3><h4 id="1-总论"><a href="#1-总论" class="headerlink" title="1. 总论"></a>1. 总论</h4><p>原因：芯片尺寸的减小，使得线宽减小，导线电阻增加，导线压降增加。</p><p>常考虑：<font color=red><b>电源网络设计——导线消耗了电压，使得供给门电路的电压下降</b></font></p><p>供给门电路的电压下降的危害</p><ul><li><p>噪声容限降低</p></li><li><p>延时增加</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211126220745937.png"></p></li></ul><p>上图中，$\Delta V’$称为电压降，而$\Delta V$称为低电压反弹。</p><p>实际供给门电路的电压只有  $V&#x3D;V_{DD}-\Delta V’-\Delta V$​</p><h4 id="2-【重点】减小电压降的方法"><a href="#2-【重点】减小电压降的方法" class="headerlink" title="2. 【重点】减小电压降的方法"></a>2. 【重点】减小电压降的方法</h4><p>战略：缩短电源引线和电路电源接地线的距离</p><ul><li>增加电源&#x2F;地Pad的数量</li><li>增加电源环的宽度</li><li>合理调整水平、垂直电源条间距和宽度</li></ul><h3 id="2-电迁移"><a href="#2-电迁移" class="headerlink" title="2. 电迁移"></a>2. 电迁移</h3><h4 id="1-总论-1"><a href="#1-总论-1" class="headerlink" title="1. 总论"></a>1. 总论</h4><p>原因：工艺尺寸减小，线宽、工作电压减小，但是功耗增加，意味着单位线宽流过的电流密度增加，电迁移现象变得明显。</p><p>小贴士：</p><ul><li>金属导线有极限传导电流的能力。太高的电流会金属中粒子碰撞变形严重，产生明显位移。从而引起<strong>断路和短路</strong>现象</li><li>电迁移同温度、晶体结构、<strong>平均电流密度</strong>有关。</li></ul><h4 id="2-【重点】降低电迁移的方法"><a href="#2-【重点】降低电迁移的方法" class="headerlink" title="2. 【重点】降低电迁移的方法"></a>2. 【重点】降低电迁移的方法</h4><ul><li><p>改变金属线属性。</p><p>​如合金或者$Cu$代替$Al$导线，但是成本增加。</p></li><li><p>降低温度。</p><p>​降低温度可以减小电迁移发射概率。</p><p>​芯片封装上面需要考虑散热问题。</p></li><li><p>增加线宽。</p><p>​增加线宽可以降低平均电流密度。</p><p>​缺点；增加布线资源，成本增加</p><p>​优点：增加线宽不仅可以降低平均电流密度，还可以降低金属温度，间接又抑制了电迁移。</p></li></ul><h3 id="3-性能——长导线延时"><a href="#3-性能——长导线延时" class="headerlink" title="3. 性能——长导线延时"></a>3. 性能——长导线延时</h3><h4 id="1-总论-2"><a href="#1-总论-2" class="headerlink" title="1. 总论"></a>1. 总论</h4><p>原因：根据导线模型——分布$RC$模型，可知$t_p\varpropto L^2$​。为了降低电路延时，提高电路的响应速度，需要降低导线寄生电阻。​</p><h4 id="2-【重点】降低长导线延时的方法"><a href="#2-【重点】降低长导线延时的方法" class="headerlink" title="2. 【重点】降低长导线延时的方法"></a>2. 【重点】降低长导线延时的方法</h4><ul><li><p>采用更好的互连材料。</p><p>​导线：铜$Cu$、合金等；绝缘材料：低介电常数的材料</p><p>​<strong>※但是，这种方法不是解决长导线延时的根本方法。</strong></p></li><li><p>增加互连金属层的数目</p><p>​管子数目增多驱动这金属层数目增多。</p><p>​局部线（底层金属层做信号传输）采用高密度，全局线（高层金属层走全局信号，如时钟线、电源线）</p></li><li><p>采用更好的互连策略——对角线法</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211126230250702.png"></p><p>​采用<strong>对角线式布线</strong>（如上图），现场可较小29%，但是对于EDA工具、掩膜制作的要求高，难度大。</p><p>​目前一般采用<strong>曼哈顿式布线</strong>，即横平竖直式的布线。</p></li><li><p>中间插入中继器——中继器</p><p>​长的互连线中插入中继器（如<code>inv buffer</code>），强行减小导线长度。但是中继器也存在延时。</p></li><li><p>优化互连结构——寄存器或锁存器</p><p>​方法：导线流水线——长互连线中插入寄存器或者锁存器，将导线分成$k$段。</p><p>​优点：可以提高数据处理能力。每段导线中可以加入中继器进行进一步优化。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（12）运算单元（加法器）</title>
    <link href="/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8812%EF%BC%89%E8%BF%90%E7%AE%97%E5%8D%95%E5%85%83%EF%BC%88%E5%8A%A0%E6%B3%95%E5%99%A8%EF%BC%89/"/>
    <url>/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8812%EF%BC%89%E8%BF%90%E7%AE%97%E5%8D%95%E5%85%83%EF%BC%88%E5%8A%A0%E6%B3%95%E5%99%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述数据通路上的基本元件——加法器，包括一位全加器和多位全加器。</p><hr><span id="more"></span><h1 id="第十一章-设计运算功能块"><a href="#第十一章-设计运算功能块" class="headerlink" title="第十一章 设计运算功能块"></a>第十一章 设计运算功能块</h1><h1 id="1-总论"><a href="#1-总论" class="headerlink" title="1. 总论"></a>1. 总论</h1><p>在时序电路中，时序电路&#x3D;组合电路+存储电路</p><p>在（9）~（11）中，已经详细介绍了存储电路（寄存器）</p><p>在本文中，将介绍<strong>组合电路</strong>中比较重要的<strong>数据通路</strong>上的电路，可以认为是在时序电路中提到的$logic$​​，即用于<strong>逻辑运算和算数运算</strong>。</p><p>在数集中，常用的数据通路组合电路有</p><ul><li>加法器</li><li>乘法器</li><li>移位器</li></ul><p>我们的目的，是追求以下几个方面的优化</p><ul><li>性能</li><li>面积</li><li>功耗</li></ul><p>如何优化：</p><ul><li>逻辑层次优化：利用状态机、真值表等，优化布尔方程得到一个速度更快、面积更小的电路</li><li>电路层次优化：改变管子的尺寸；改变电路的拓扑连接（互补CMOS、动态CMOS等）</li></ul><h1 id="2-加法器"><a href="#2-加法器" class="headerlink" title="2. 加法器"></a>2. 加法器</h1><p>加法器在数据通路电路中的地位类似于反相器在与或等简单逻辑电路的位置</p><ul><li><p><strong>数据通路的电路的基础是加法器</strong></p><p>乘法器也是加法器扩展而来的</p></li><li><p>加法器是限制数据通路运算<strong>速度</strong>的元件。</p></li></ul><h2 id="1-一位全加器（-FA-）"><a href="#1-一位全加器（-FA-）" class="headerlink" title="1. 一位全加器（$FA$）"></a>1. 一位全加器（$FA$）</h2><h3 id="1-传统表达方式"><a href="#1-传统表达方式" class="headerlink" title="1. 传统表达方式"></a>1. 传统表达方式</h3><p>定义：根据输入的二值数据、进位信号，计算得到结果和进位。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211027110224284.png"></p><p>其中，</p><p>$A、B$：输入的数据，或为0、或为1</p><p>$Cin&#x2F;\ C_{i}$​​：输入的前级的进位信号，或0或1</p><p>$Sum&#x2F;\ S$​：计算得到的结果​​</p><p>$Cout&#x2F;\ C_o$​​：计算得到的进位信号</p><p>其逻辑关系为<br>$$<br>S&#x3D;A\bigoplus B \bigoplus C_i&#x3D;A·\overline{B}·\overline{C_i}+\overline{A}·B·\overline{C_i}+\overline{A}·\overline{B}·C_i+ABC_i \<br>$$</p><p>$$<br>C_o&#x3D;AB+BC_i+AC_i<br>$$</p><p>【注】：</p><ol><li><p>$\bigoplus$：异或，常见结构有：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220622215116844.png" alt="image-20220622215116844" style="zoom: 67%;" /><p>$\bigodot$：同或，结构如下（即“异或门结构2”的“非”）：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220622215549134.png" alt="image-20220622215549134" style="zoom: 45%;" /></li></ol><h3 id="2-P、G、D-​函数表达"><a href="#2-P、G、D-​函数表达" class="headerlink" title="2. $P、G、D$​函数表达"></a>2. $P、G、D$​函数表达</h3><p>真值表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211027161741814.png" alt="一位加法器真值表"></p><p>$P、G、D$的表达式如下（根据真值表可得）：<br>$$<br>P&#x3D;A\bigoplus B\<br>G&#x3D;A·B\<br>D&#x3D;\overline{A}·\overline{B}<br>$$<br>现对$P、G、D$进行解释：</p><ul><li><p>$P$：只要$P&#x3D;1$，则只要$C_i&#x3D;1$，即前级有进位，则本级进位输出$C_o$输出等于1​。故称，$P$为<font color=red><b>进位传播</b></font>。</p></li><li><p>$G$：只要$G&#x3D;1$，则本级进位输出$C_o&#x3D;1$，且与$C_i$无关，故称$G$为<font color=red><b>进位产生</b></font>。</p></li><li><p>$D$​：只要$D&#x3D;1$​，则本级进位输出$C_o&#x3D;0$​，且与$C_i$​无关，故称$D$​为<font color=red><b>进位取消</b></font></p></li><li><p>注意：<strong>三者为互斥</strong></p></li></ul><p>将$f(A,B,C_i)$​​改写为$f(P,G(或D))$​​，即有<br>$$<br>C_o&#x3D;G+PC_i\<br>S&#x3D;P\bigoplus C_i<br>$$<br><strong>小贴士</strong>：</p><ul><li>$G$和$D$在表征进位上功能类似，其值<strong>直接表征</strong>了$C_o$的输出值，与$C_i$​​的输入无关。故而常常把二者合一（如上式，仅用$P、G$作为自变量）。</li><li>$P、G(或D)$​的值仅仅与$A、B$​值有关，而与$C_i$​无关</li><li>用这三个中间变量表征$S、C_o$​十分有用</li></ul><h3 id="3-逐位（行波）加法器"><a href="#3-逐位（行波）加法器" class="headerlink" title="3. 逐位（行波）加法器"></a>3. 逐位（行波）加法器</h3><p>所谓逐位（行波）加法器，指的是将$N$个​一位全加器（$FA$​​​​）串联在一起构成加法器。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211027164457679.png" alt="image-20211027161741814"></p><p>此处主要讨论其<font color=red><b>性能（延时）</b></font>。</p><ul><li><p>根据电路图，可知，设计行波加法器，<strong>提高优化进位运算$t_{carry}$​比优化和运算$t_{sum}$重要得多</strong>。</p><p>原因：由图可知，输入各级$FA$​的信号中，$A、B$​在理想状态下，在零时刻即输入到各级$FA$​的输入端；而$C_i$​需要等待上一级运算之后，才能到达本级$FA$​​的输入端。故，<strong>关键信号是$C_i$​</strong>（概念见（4）.5.3），只有提高$t_{carry}$​​，才能从根本上优化行波加法器的运算速度。</p></li><li><p>最坏情况，$t_d&#x3D;O(N)$​</p><p>最坏情况下，延时正比于全加器串联级数$N$</p></li></ul><h2 id="2-【结构】设计全加器FA"><a href="#2-【结构】设计全加器FA" class="headerlink" title="2. 【结构】设计全加器FA"></a>2. 【结构】设计全加器FA</h2><h3 id="1-互补静态CMOS结构FA"><a href="#1-互补静态CMOS结构FA" class="headerlink" title="1. 互补静态CMOS结构FA"></a>1. 互补静态CMOS结构FA</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211027173910194.png"></p><p>根据电路图可知，该电路对一些逻辑进行了变化</p><table><thead><tr><th align="center">传统</th><th align="center">该电路</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">$C_o&#x3D;AB+BC_i+AC_i$</td><td align="center">$C_o&#x3D;AB+BC_i+AC_i$</td><td align="center">未改变</td></tr><tr><td align="center">$S&#x3D;A\bigoplus B \bigoplus C_i$</td><td align="center">$S&#x3D;ABC_i+\overline{C_o}(A+B+C_i)$</td><td align="center">改变</td></tr></tbody></table><p><strong>优点</strong>：</p><ul><li>可知，$S$​在计算的时候，复用了$C_o$​​的逻辑，使得管子数量有所减小，一共使用了<font color=red><b>28个管子</b></font></li><li>【<strong>小技巧</strong>】在（4）.3.5中已经提到，关键信号应该靠近输出端。如图中<font color=red>红圈</font>，$C_i$</li></ul><p><strong>缺点</strong>：</p><p>​<strong>——（主要考虑对于$C_o$的影响）</strong>——<font color=red><b>工作速度较慢</b></font>：</p><ul><li>虽然管子数量有所减少，但是28个管子依旧消耗了较大的面积</li><li>作为关键信号$C_o$​​，其产生电路中堆叠了太多的PMOS管（？为啥提到PMOS管）</li><li>$C_o$​的本征负载电容很大，根据$t_p&#x3D;C_L·R_{eq}$​​可知，产生$C_o$​​​的延迟较大</li></ul><h3 id="2-镜像加法器"><a href="#2-镜像加法器" class="headerlink" title="2. 镜像加法器"></a>2. 镜像加法器</h3><p>该加法器是根据互补静态CMOS结构FA改进得到的，<strong>镜像加法器的下拉网络和互补CMOS结构FA完全相同</strong>。</p><p>电路图如图所示，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112191714798.png"></p><table><thead><tr><th align="center">项目</th><th align="center">公式</th></tr></thead><tbody><tr><td align="center">进位输出：$\overline{C_o}$</td><td align="center">$\overline{C_o}&#x3D;\overline{AB+(A+B)C_i}$</td></tr><tr><td align="center">求和输出：$\overline{S}$​</td><td align="center">$\overline{S}&#x3D;\overline{ABC_i+\overline{C_o}(A+B+C_i)}$</td></tr></tbody></table><p><strong>注意点</strong>：</p><ol><li><p><font color=red><b>24个管子</b></font></p></li><li><p>NMOS管（下拉网络）和PMOS管(上拉网络)完全对称，利用的是 <strong>求和 和 进位</strong> 的”自对偶性”</p></li><li><p>同互补CMOS加法器，关键信号$C_i$应该靠近输出端。</p></li><li><p><strong>进位输出电路需要考虑管子尺寸匹配问题，提高进位运算速度。</strong></p><p>求和输出电路不需要考了管子尺寸，可以全部使用最小尺寸。</p></li><li><p><font color=red><b>⭐需要掌握镜像加法器的棍棒图</b></font></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112193418399.png" alt="image-20211112193418399"></p></li></ol><h3 id="3-传输门型加法器——传统型"><a href="#3-传输门型加法器——传统型" class="headerlink" title="3. 传输门型加法器——传统型"></a>3. 传输门型加法器——传统型</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112194234891.png" alt="传输门加法器——传统型电路图"></p><p><strong>注意点</strong>：</p><ol><li><p><strong><font color=red>24个管子</font></strong></p></li><li><p>使用模块：多路开关+反相器</p></li><li><p><strong>进位产生和求和输出的延时几乎相同</strong></p></li><li><p>真值表</p><table><thead><tr><th align="center">结果\建立信号</th><th align="center">$P&#x3D;0$</th><th align="center">$P&#x3D;1$</th></tr></thead><tbody><tr><td align="center">$S$</td><td align="center">$C_i$</td><td align="center">$\overline{C_i}$</td></tr><tr><td align="center">$C_o$</td><td align="center">$A$</td><td align="center">$C_i$</td></tr></tbody></table></li></ol><h3 id="4-传输门型加法器——曼切斯特FA"><a href="#4-传输门型加法器——曼切斯特FA" class="headerlink" title="4. 传输门型加法器——曼切斯特FA"></a>4. 传输门型加法器——曼切斯特FA</h3><h4 id="1-静态电路"><a href="#1-静态电路" class="headerlink" title="1. 静态电路"></a>1. 静态电路</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112200847816.png"></p><p>分析：</p><ul><li><p>第一部分：传输门</p><p>该传输门的表达式很容易写，为：$C_iP_i$​</p><p>因为**$P、G、D$​​互斥**，当$P_i&#x3D;1$​​​时，$D_i&#x3D;0$​且$G_i&#x3D;0(\overline{G_i}&#x3D;1)$​，第二部分上下拉网络均截止，输出取决于$C_i$​​​</p></li><li><p>第二部门：上下拉网络</p><p>当$P_i&#x3D;0$时，根据<strong>互斥</strong>原理，存在以下两种情况：</p><ul><li><p>当$D_i&#x3D;1$​​​​时，表示进位为0，故输出需要下拉到地，即下拉网络导通，故下拉网络栅极输入为$D_i$​</p></li><li><p>当$G_i&#x3D;1$​时，表示进位为1，故输出需要上拉到$VCC$​​​，即上拉网络导通，又因为上拉网络需要栅极输入为0时才能实现上拉功能，故上拉网络的栅极输入为$\overline{G_i}$​</p></li></ul></li></ul><h4 id="2-动态电路"><a href="#2-动态电路" class="headerlink" title="2. 动态电路"></a>2. 动态电路</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112203526675.png" alt="image-20211112200847816"></p><ul><li>动态电路简单</li><li>动态电路单向工作，传输门使用NMOS管实现</li><li>该电路不需要$D$​</li></ul><h4 id="3-曼切斯特进位链加法器"><a href="#3-曼切斯特进位链加法器" class="headerlink" title="3. 曼切斯特进位链加法器"></a>3. 曼切斯特进位链加法器</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112204347485.png" alt="image-20211112203526675"></p><p><strong>最坏情况：</strong></p><p>$P_0P_1P_2P_3&#x3D;1111$​，则$G_0G_1G_2G_3&#x3D;0000$​，当$\overline{C_{i,0}}&#x3D;0$​时，电路通过$P_0$​、$P_1P_0$​、$P_2P_1P_0$​、$P_3P_2P_1P_0$​放电​，可知最坏情况下，$t_p&#x3D;O(N^2)$​（1+2+3+4…）​</p><h4 id="4-【会画会认】两位曼切斯特进位链棍棒图"><a href="#4-【会画会认】两位曼切斯特进位链棍棒图" class="headerlink" title="4. 【会画会认】两位曼切斯特进位链棍棒图"></a>4. 【会画会认】两位曼切斯特进位链棍棒图</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113091127097.png" alt="image-20211113091127097"></p><p>特点：</p><ul><li>动态逻辑上下管子数差很多，上少下多。</li></ul><h2 id="3-【逻辑】设计全加器FA"><a href="#3-【逻辑】设计全加器FA" class="headerlink" title="3. 【逻辑】设计全加器FA"></a>3. 【逻辑】设计全加器FA</h2><h3 id="1-旁路进位加法器"><a href="#1-旁路进位加法器" class="headerlink" title="1. 旁路进位加法器"></a>1. 旁路进位加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211112211243886.png" alt="image-20211112211243886"></p><p>当$BP&#x3D;P_0P_1P_2P_3&#x3D;1$时，即最坏情况下，可以直接得到$C_{o,3}&#x3D;C_{i,0}$​；</p><p>只要有一个$P&#x3D;0$​​，则只能按照正常路径计算进位​​。</p><p><font color=red><b>特点：逐位加法器进行最坏情况优化</b></font></p><p><strong>缺点</strong>：</p><ol><li>对速度提升不多，一般用得很少</li><li>主要考虑了<font color=red><b>最坏情况</b></font>单种情况，对速度提升不大</li><li>增加了旁路，使得电路不够规则，画版图不方便</li></ol><p><strong>优点</strong>：</p><ol><li>速度提升虽然不多，但是面积增加也不多。</li><li>速度的提升在<font color=red><b>高位进位</b></font>时显现优势。</li></ol><p><strong>延时（了解）</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113094101759.png" alt="image-20211113100147091"></p><center>图中阴影为关键路径</center><p>$t_{adder}&#x3D;t_{setup}+Mt_{carry}+(\frac{N}{M}-1)t_{bypass}+(M-1)t_{carry}+t_{sum}$</p><h3 id="2-线性进位选择加法器"><a href="#2-线性进位选择加法器" class="headerlink" title="2. 线性进位选择加法器"></a>2. 线性进位选择加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113100801109.png" alt="图中阴影为关键路径"></p><p><font color=red><b>特点：逐位加法器进行需要等待前一级的</b>$C_o$<b>输出之后才能进位。线性加法器先计算出</b>$C_o&#x3D;1$<b>或</b>$0$<b>的结果，等待出现了进位，直接通过选择器选出。</b></font></p><p><strong>缺点</strong>：</p><ol><li>以面积换取速度，使得整个放大器的面积大大增加。</li></ol><p><strong>优点</strong>：</p><ol><li>速度提升了</li></ol><p><strong>延时</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113100147091.png" alt="image-20211113094101759"></p><p>$t_{adder}&#x3D;t_{setup}+Mt_{carry}+(\frac{N}{M})t_{mux}+t_{sum}$</p><p>实际上，由于第一级只需要计算出$P、G$就可以直接根据$C_{i,0}$得到$C_{o,1}$​，故第一级不需要选择器。</p><p>因此延时公式修正为：$t_{adder}&#x3D;t_{setup}+Mt_{carry}+(\frac{N}{M}-1)t_{mux}+t_{sum}$​</p><h3 id="3-平方根进位加法器"><a href="#3-平方根进位加法器" class="headerlink" title="3. 平方根进位加法器"></a>3. 平方根进位加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113102608611.png" alt="image-20211113102608611"></p><p><font color=red><b>特点：相比线性进位加法器，每一个单元的计算位数都是M。导致了后面单元计算完了之后需要等待很久前面单元</b>$C_o$<b>传来，浪费了需要时间。平方根进位加法器每个单元的计算位数不同，为逐个单元递增。如上图所示，其计算位数为2、3、4、5……</b></font></p><p><strong>优点</strong>：运算速度最快</p><p><strong>延时</strong>：</p><p>$t_{adder}&#x3D;t_{setup}+Mt_{carry}+(\sqrt{2N})t_{mux}+t_{sum}$</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><table><thead><tr><th align="center">加法器</th><th align="center">传统FA：逐位加法器</th><th align="center">旁路进位加法器</th><th align="center">线性进位加法器</th><th align="center">平方根进位加法器</th></tr></thead><tbody><tr><td align="center">速度</td><td align="center">※</td><td align="center">※※</td><td align="center">※※※</td><td align="center">※※※※</td></tr><tr><td align="center">优点</td><td align="center">规规矩矩</td><td align="center">考虑了最坏情况</td><td align="center">实现计算好两种$C_i$的情况，【等待真实$C_i$信号】到来然后进行选择</td><td align="center">【一边】计算好两种$C_i$的情况，【一边】根据$C_i$进行选择</td></tr><tr><td align="center">备注</td><td align="center"></td><td align="center"></td><td align="center">每个单元都是M位的运算</td><td align="center">单元的运算位数逐级递增</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113145434666.png"></p><h3 id="5-超前进位加法器"><a href="#5-超前进位加法器" class="headerlink" title="5. 超前进位加法器"></a>5. 超前进位加法器</h3><p>见下文</p><h2 id="4-【重要】超前进位加法器"><a href="#4-【重要】超前进位加法器" class="headerlink" title="4. 【重要】超前进位加法器"></a>4. 【重要】超前进位加法器</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113163711000.png" alt="image-20211113163711000"></p><p>根据$C_{o,k}&#x3D;G_k+C_{o,k-1}P_k$可知只要将$C_{o,k-1}$利用递归拆开，就可以让$C_{o,k}$摆脱$C_{o,k-1}$的束缚，使得<br>$$<br>C_{o,k}&#x3D;f(G,P,C_{i,0})<br>$$<br>只要知道了各级的$G、P$和最初的$C_{i,0}$即可计算出$C_{o,k}$​。</p><p>容易知道，只要经过简单的逻辑运算：$G&#x3D;AB$​​、$P&#x3D;A\bigoplus B$​即可得到数据，而$C_{i,0}$​​是输入信号之一。</p><p><strong>缺点</strong>：随着计算位数的增多，<strong>整个加法器的扇入非常大</strong>。</p><p>一些电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113160739198.png" alt="【镜像电路】4位超前进位加法器"></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113161228146.png" alt="【动态实现】4位超前进位加法器"></p><h3 id="2-块运算"><a href="#2-块运算" class="headerlink" title="2. 块运算"></a>2. 块运算</h3><p>令：<br>$$<br>G_{a:b}&#x3D;G_a+P_aG_{a-1}+P_aP_{a-1}G_{a-2}+…+P_aP_{a-1}P_{a-2}…G_{b}<br>$$</p><p>$$<br>P_{a:b}&#x3D;P_aP_{a-1}…P_{b+1}P_b<br>$$</p><p>$G_{a:b}$​和$P_{a:b}$​分别表示从第$a$​位到第$b$​位的进位产生和进位传播信号，称为<font color=red><b>块进位产生和块进位传播</b></font></p><p>$eg：$</p><p>$G_{2:0}&#x3D;G_2+P_2G_1+P_2P_1G_0$​</p><p>$G_{3:1}&#x3D;G_3+P_3G_2+P_3P_2G_1$​</p><p>$P_{3:0}&#x3D;P_3P_2P_1P_1$​</p><p>$P_{3:1}&#x3D;P_3P_2P_1$</p><p>经过推导，有<br>$$<br>C_{o,k}&#x3D;G_{k:0}+P_{k:0}C_{i,0}<br>$$<br>即：<font color=red><b>只要算出块进位产生和块进位传播，就可以轻松算出任何一位的进位输出</b></font></p><p>其中，</p><p>$C_{o,k}$：第$k$级的进位输出</p><p>$G_{k:0}$​：第$k$​级到第$0$​级的块进位产生</p><p>$ P_{k:0}$​​​：第$k$​​​级到第$0$​​​​级的块进位传播</p><p>$C_{i,0}$​：第0级的进位输入，即加法器系统的进位输入</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113170432313.png"></p><p>根据上图，可以很形象理解，并且得到以下式子<br>$$<br>C_{o,3}&#x3D;G_{3:0}+P_{3:0}C_{i,0}<br>$$</p><p>$$<br>&#x3D;(G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0)+P_3P_2P_1P_1C_{i,0}<br>$$</p><h3 id="3-点操作"><a href="#3-点操作" class="headerlink" title="3. 点操作"></a>3. 点操作</h3><p>步骤如下：</p><ol><li><p>判断计算位数，分别计算出各个$G_k,P_k$​</p><p>其中：$G_k&#x3D;A_kB_k$​​、$P_k&#x3D;A_k\bigoplus B_k$​​</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113174550237.png"></p><p>上图分别是使用静态逻辑实现的<strong>进位传播、进位产生</strong></p></li><li><p>根据你要求的$C_{o,k}$​列出表达式</p><p>即：<br>$$<br>C_{o,k}&#x3D;G_{k:0}+P_{k:0}C_{i,0}<br>$$</p></li><li><p>根据2得到的$G_{k:0}$​、$P_{k:0}$​​​列出<font color=red><b>点操作表达式</b></font>，下面以4位加法器为例子</p><ol><li><p>列式子</p><p>$(G_{3:0},P_{3:0})&#x3D;(G_3,P_3)·(G_2,P_2)·(G_1,P_1)·(G_0,P_0)\$​​</p><p>​  $&#x3D;[(G_3,P_3)·(G_2,P_2)]·[(G_1,P_1)·(G_0,P_0)]$​</p><p>​  $&#x3D;(G_{3:2},P_{3:2})·(G_{1:0},P_{1:0})$​</p></li></ol><p>​         $&#x3D;(G_{3:2}+P_{3:2}G_{1:0},P_{3:2}P_{1:0})$​</p><p>此时已将多位加法器转换为2位加法器​​</p><ol><li><p>画出树结构图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113203342125.png" alt="image-20211113174550237"></p><p>最上面一个点，表示$(G_{3:0},P_{3:0})$</p><p>中间两个点分别为$(G_{3:2},P_{3:2})$和$(G_{1:0},P_{1:0})$​</p><p>最下面四个方块点分别为$(G_3,P_3)、(G_2,P_2)、(G_1,P_1)、(G_0,P_0)$</p></li></ol></li><li><p><strong>计算各个节点</strong>：</p><p>根据上文<strong>块运算</strong>已知，以其中一个节点$(G_{1:0},P_{1:0})$为例</p><p>$G_{1:0}&#x3D;G_1+P_1G_0$</p><p>$P_{1:0}&#x3D;P_1P_0$​</p><p>再如节点$(G_{3:0},P_{3:0})$为例</p><p>$G_{3:0}&#x3D;G_{3:2}+P_{3:2}G_{1:0}$</p><p>$P_{3:0}&#x3D;P_{3:2}P_{1:0}$</p><p>即2位的块运算，只需要简单的一个<strong>或-与门</strong>和<strong>与门</strong>就可以完成运算。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113173725268.png"></p></li></ol><h3 id="4-Kogge-Stone-16位超前进位加法器"><a href="#4-Kogge-Stone-16位超前进位加法器" class="headerlink" title="4. Kogge-Stone 16位超前进位加法器"></a>4. Kogge-Stone 16位超前进位加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211113205502577.png" alt="image-20211113203342125"></p><ol><li><p>运算速度快。</p><p>在位置$2^i-1$上的进位，只需要$i$次操作就可以计算出来。</p></li><li><p>面积、功耗较大</p></li><li><p>关键路径上的扇出基本是一个常数</p></li><li><p>互连结构，实现容易</p></li></ol><p><strong>例子</strong>：计算$C_5$​​</p><ol><li>$C_5&#x3D;G_{5:0}+P_{5:0}C_{i,0}$</li><li><font color=red><b>注意：需要严格按照图中的连线来</b></font></li></ol><p>$$<br>(G_{5:0},P_{5:0})<br>$$</p><p>$$<br>&#x3D;[(G_5,P_5)·(G_4,P_4)]·[(G_3,P_3)·(G_2,P_2)]·[(G_1,P_1)·(G_0,P_0)]\ —— \ 第一层节点<br>$$</p><p>$$<br>&#x3D;[(G_{5:4},P_{5:4})·(G_{3:2},P_{3:2})]·(G_{1:0},P_{1:0})\ ——\ 第二层节点<br>$$</p><p>$$<br>&#x3D;(G_{5:2},P_{5:2})·(G_{1:0},P_{1:0})\ —— \ 第三层节点<br>$$</p><p><strong>小贴士</strong>：</p><ol><li>需要严格按照图中连线，否则将判定为错误。</li><li><font color=red><b>有几层节点，就需要写几行</b></font></li></ol><h3 id="5-Brent-Kung-16位超前进位加法器"><a href="#5-Brent-Kung-16位超前进位加法器" class="headerlink" title="5. Brent-Kung 16位超前进位加法器"></a>5. Brent-Kung 16位超前进位加法器</h3><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211128005910220.png" alt="image-20211113205502577" style="zoom:67%;" /><ol><li><p>分为正向树和反向树。如图，黑点为正向树，灰点为反向树。</p><p><strong>正向树只计算$2^N-1$​​的点</strong>，如图中0、3、7、15位；反向树利用正向树计算出来的节点，补全其他位</p></li><li><p>布线少，但是布线不规则</p></li><li><p>每个门的扇出不同，优化困难</p></li><li><p>不同于K-S加法器，在位置$2^{i-1}$~$2^i-1$上的进位，只需要$i$次操作就可以计算出来。</p><p>B-K 16位加法器中，最长路径的$C_{14}$需要计算6个节点</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（11）时序报告</title>
    <link href="/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8811%EF%BC%89%E6%97%B6%E5%BA%8F%E6%8A%A5%E5%91%8A/"/>
    <url>/2022/05/02/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8811%EF%BC%89%E6%97%B6%E5%BA%8F%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述如何查看时序报告。如何书写时序约束，可以参见《DC-lab4和lab6的略解》一文。</p><hr><span id="more"></span><h1 id="第七章-时序组合电路设计"><a href="#第七章-时序组合电路设计" class="headerlink" title="第七章 时序组合电路设计"></a>第七章 时序组合电路设计</h1><h1 id="3-时序报告——求裕量slack"><a href="#3-时序报告——求裕量slack" class="headerlink" title="3. 时序报告——求裕量slack"></a>3. 时序报告——求裕量slack</h1><h2 id="1-建立时间"><a href="#1-建立时间" class="headerlink" title="1. 建立时间"></a>1. 建立时间</h2><p>建立时间定义：对于捕获沿到来之前，数据需要保持稳定的<strong>最小时间</strong></p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125175830676.png" alt="image-20211125175830676" style="zoom:67%;" /><p>关于**<font color=red>建立时间裕量$slack_{setup}$​</font>**的定义，需要以下几个参数：</p><ol><li><p><strong>数据要求到达的时间——Date Required Time</strong>，令为$t_{date\ required}$<br>$$<br>t_{date\ required}&#x3D;T-t_{su}<br>$$<br>其中，</p><p>$T$：周期，如图整段的阴影部分</p><p>$t_{su}$：建立时间</p></li><li><p><strong>数据实际到达的时间——Date Arrival Time</strong>，令为$t_{date\ arrival}$<br>$$<br>t_{date\ arrival}&#x3D;t_{c-q}+t_{logic}<br>$$<br>其中，</p><p>$t_{c-q}$：寄存器的（最坏）传播延时</p><p>$t_{logic}$：两个寄存器之间组合逻辑的（最坏）传播延时</p></li></ol><p>则有<br>$$<br>slack_{setup}&#x3D;t_{date\ required}-t_{date\ arrival}<br>$$<br>为了充分考虑各种情况下，组合逻辑的建立时间裕量$slack_{setup}$​，以下将分情况讨论。</p><p>在此之前，先明确几个概念：</p><ul><li>理想时钟（ideal clock）：以下的情况均不存在。</li><li>时钟偏差（clock skew）：指同一个时钟域之间，时钟信号到达各个寄存器的**<font color=red>最大时间差</font>**</li><li>时钟抖动（clock jitter）：芯片某一给定点上，时钟周期宽度发生变化，或缩短或变宽。一般我们会考虑**<font color=red>最坏情况</font>**，具体见下文。</li><li>（网络）时钟延迟（latency 或 network latency）：外部时钟输入该模块后，时钟信号达到寄存器时钟输入端的延时。</li><li>源时钟延迟（source latency）：从整个系统时钟源产生的时钟，到该模块时钟输入端的延时。</li></ul><h3 id="1-理想时钟——ideal-clock"><a href="#1-理想时钟——ideal-clock" class="headerlink" title="1. 理想时钟——ideal clock"></a>1. 理想时钟——ideal clock</h3><p>指令：</p><figure class="highlight tcl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br></code></pre></td></tr></table></figure><p>电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125184608609.png" alt="image-20211125184608609"></p><p>报告：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125184935488.png" alt="image-20211125184935488" style="zoom:67%;" /><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125185441369.png" alt="image-20211125185441369" style="zoom:80%;" /><p>根据公式$slack_{setup}&#x3D;t_{date\ required}-t_{date\ arrival}$​：<br>$$<br>slack_{setup}&#x3D;9.79-0.72&#x3D;9.07<br>$$</p><h3 id="2-时钟偏差——clock-skew"><a href="#2-时钟偏差——clock-skew" class="headerlink" title="2. 时钟偏差——clock skew"></a>2. 时钟偏差——clock skew</h3><p>指令：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br>set_clock_uncertainty <span class="hljs-number">0.5</span> [get_ports CLK] <br><span class="hljs-comment"># 设置0.5的时钟偏差</span><br></code></pre></td></tr></table></figure><p>电路图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125185521836.png" alt="image-20211125185521836" style="zoom: 80%;" /><p>报告：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125190351622.png" alt="image-20211125192836430" style="zoom:67%;" /><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125191128178.png" alt="image-20211125190351622" style="zoom: 67%;" /><p>可知，引入<strong>时钟偏差</strong>之后，（注意：因为负偏差对于建立时间不利，因此取$-t_{skew}$）<br>$$<br>t_{date\ required}&#x3D;T-t_{skew}-t_{su}<br>$$<br>即，$t_{date\ required}&#x3D;10-0.5-0.21&#x3D;9.29$​</p><p>因此，<br>$$<br>slack_{setup}&#x3D;9.29-0.72&#x3D;8.57<br>$$<br><strong>小贴士</strong>：</p><p>​和理想时钟相比，最坏情况下，捕获沿向前移动了$t_{skew}$，使得$t_{date\ required}$减小，从而减小了建立时间裕量。​</p><h3 id="3-时钟网络延时——latency或network-latency"><a href="#3-时钟网络延时——latency或network-latency" class="headerlink" title="3. 时钟网络延时——latency或network latency"></a>3. 时钟网络延时——latency或network latency</h3><p>代码：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br>set_clock_uncertainty <span class="hljs-number">0.5</span> [get_ports CLK] <br><span class="hljs-comment"># 设置0.5的时钟偏差</span><br>set_clock_latency <span class="hljs-number">1</span> [get_ports CLK] <br><span class="hljs-comment"># 设置1的时钟网络延时</span><br></code></pre></td></tr></table></figure><p>电路图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125191903536.png" alt="image-20211125191128178" style="zoom:67%;" /><p>报告：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125192313593.png" alt="image-20211125191903536"></p><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125192836430.png" alt="image-20211125192313593" style="zoom:67%;" /><p>引入时钟网络延时后，<strong>模块内</strong>的各个寄存器整体偏移了一个$t_{network\ latency}&#x3D;1$​</p><p>相比理想：<br>$$<br>t_{date\ required}&#x3D;T-t_{skew}-t_{su}+t_{network\ latency}<br>$$</p><p>$$<br>t_{date\ arrival}&#x3D;t_{c-q}+t_{logic}+t_{network\ latency}<br>$$</p><p>其中，$T-t_{skew}-t_{su}&#x3D;10-0.5-0.21&#x3D;9.29$​，$t_{c-q}+t_{logic}&#x3D;0.72$​</p><p>因此，<br>$$<br>slack_{setup}&#x3D;(9.29+1)-(0.72+1)&#x3D;8.57<br>$$</p><p><strong>小贴士：</strong></p><p>​和理想时钟相比，时钟网络延时是输入模块之后，时钟到寄存器时钟输入端的延时。</p><p>​对于模块内的各个寄存器，相当于<strong>整体偏差了一个$t_{network\ latency}$​</strong></p><p>​如时序报告所示，整体偏差了$t_{network\ latency}&#x3D;1$</p><p>​</p><h3 id="4-源时钟延时——source-latency"><a href="#4-源时钟延时——source-latency" class="headerlink" title="4. 源时钟延时——source latency"></a>4. 源时钟延时——source latency</h3><p>代码：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br>set_clock_uncertainty <span class="hljs-number">0.5</span> [get_ports CLK] <br><span class="hljs-comment"># 设置0.5的时钟偏差</span><br>set_clock_latency <span class="hljs-number">1</span> [get_ports CLK] <br><span class="hljs-comment"># 设置1的时钟网络延时</span><br>set_clock_latency -<span class="hljs-keyword">source</span> <span class="hljs-number">3</span> [get_ports CLK] <br><span class="hljs-comment"># 设置3的源时钟延时</span><br></code></pre></td></tr></table></figure><p>电路图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125194853863.png" alt="image-20211125194853863" style="zoom:80%;" /><p>报告：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125194930684.png" alt="image-20211125195012065" style="zoom:67%;" /><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125195012065.png" alt="image-20211125194930684" style="zoom:80%;" /><p>引入源时钟延时后，输入<strong>模块</strong>的时钟同时钟源整体偏移一个$t_{source\ latency}&#x3D;3$​​​，也相当于<strong>模块内</strong>的各个寄存器整体偏移了一个$t_{source\ latency}&#x3D;3$​</p><p>相比理想：​​<br>$$<br>t_{date\ required}&#x3D;T-t_{skew}+t_{network\ latency}-t_{su}+t_{source\ latency}<br>$$</p><p>$$<br>t_{date\ arrival}&#x3D;t_{c-q}+t_{logic}+t_{network\ latency}+t_{source\ latency}<br>$$</p><p>其中，$T-t_{skew}+t_{network\ latency}-t_{su}&#x3D;10-0.5+1-0.21&#x3D;10.29$​，$t_{c-q}+t_{logic}+t_{network\ latency}&#x3D;0.72+1&#x3D;1.72$​</p><p>因此，<br>$$<br>slack_{setup}&#x3D;(10.29+3)-(1.72+3)&#x3D;8.57<br>$$<br><strong>小贴士：</strong></p><p>​和理想时钟相比，引入源时钟延时后，输入<strong>模块</strong>的时钟同时钟源整体偏移一个$t_{source\ latency}&#x3D;3$</p><p>​也相当于<strong>模块内</strong>的各个寄存器整体偏移了一个$t_{source\ latency}&#x3D;3$</p><p>​对于模块内的各个寄存器，相当于<strong>整体偏差了一个$t_{source\ latency}$​​</strong></p><p>​如时序报告所示，整体偏差了$t_{source\ latency}&#x3D;3$​</p><h3 id="5-时钟抖动——clock-jitter"><a href="#5-时钟抖动——clock-jitter" class="headerlink" title="5. 时钟抖动——clock jitter"></a>5. 时钟抖动——clock jitter</h3><p>代码：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br>set_clock_uncertainty <span class="hljs-number">0.5</span> [get_ports CLK] <br><span class="hljs-comment"># 设置0.5的时钟偏差</span><br>set_clock_latency <span class="hljs-number">1</span> [get_ports CLK] <br><span class="hljs-comment"># 设置1的时钟网络延时</span><br><br><span class="hljs-comment"># set_clock_latency -source 3 [get_ports CLK] </span><br><span class="hljs-comment"># 设置3的源时钟延时</span><br><br>set_clock_latency <span class="hljs-number">2.5</span> -<span class="hljs-keyword">source</span> -early [get_ports CLK] <br><span class="hljs-comment"># 设置源时钟，最小绝对时钟抖动2.5</span><br>set_clock_latency <span class="hljs-number">3.5</span> -<span class="hljs-keyword">source</span> -late [get_ports CLK] <br><span class="hljs-comment"># 设置源时钟，最大绝对时钟抖动3.5</span><br><br><span class="hljs-comment"># 如下电路图，设置时间抖动为±0.5</span><br><span class="hljs-comment"># 上面代码取最坏情况，即前级向后抖动0.5，后级向前抖动0.5</span><br><span class="hljs-comment"># 故前级延时为3+0.5=3.5，后级为3-0.5=2.5</span><br></code></pre></td></tr></table></figure><p>电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125202435173.png" alt="image-20211125202435173"></p><p>报告：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125202511055.png" alt="image-20211125202511055" style="zoom: 80%;" /><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125202603447.png" alt="image-20211125202603447" style="zoom:67%;" /><p><strong><font color=red>取最差情况——前一级时钟向后抖动，本级时钟向前抖动</font></strong> ，如下图</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125203620946.png" alt="image-20211125203620946" style="zoom:67%;" /><p>最坏情况下，前一级时钟向后抖动0.5，本级时钟向前抖动0.5</p><p>因此，<br>$$<br>t_{date\ required}&#x3D;T-t_{skew}+t_{network\ latency}-t_{su}+(t_{source\ latency}-0.5)<br>$$</p><p>$$<br>t_{date\ arrival}&#x3D;t_{c-q}+t_{logic}+t_{network\ latency}+(t_{source\ latency}+0.5)<br>$$</p><p>其中，$T-t_{skew}+t_{network\ latency}-t_{su}&#x3D;10-0.5+1-0.21&#x3D;10.29$，$t_{c-q}+t_{logic}+t_{network\ latency}&#x3D;0.72+1&#x3D;1.72$</p><p>因此，<br>$$<br>slack_{setup}&#x3D;[10.29+(3-0.5)]-[1.72+(3+0.5)]&#x3D;7.57<br>$$</p><h2 id="2-保持时间"><a href="#2-保持时间" class="headerlink" title="2. 保持时间"></a>2. 保持时间</h2><p>保持时间定义：对于捕获沿到来之后，数据需要保持稳定的<strong>最小时间</strong></p><p><strong><font color=red>注意：保持时间看的是同一个时刻</font></strong> </p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125211556540.png" alt="image-20211125211751676"></p><p>同样的，对于保持时间裕度$slack_{hold}$​，有<br>$$<br>slack_{hold}&#x3D;t_{date\ arrival}-t_{date\ required}<br>$$</p><h3 id="1-理想时钟——ideal-clock-1"><a href="#1-理想时钟——ideal-clock-1" class="headerlink" title="1.理想时钟——ideal clock"></a>1.理想时钟——ideal clock</h3><p>代码：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br></code></pre></td></tr></table></figure><p>电路图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125211751676.png" alt="image-20211125211556540" style="zoom:80%;" /><p>报告：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125212006757.png" alt="image-20211125214133403"></p><p>波形图：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125212049653.png" alt="image-20211125212006757" style="zoom: 80%;" /><p><strong><font color=red>注意：保持时间看的是同一个时刻</font><strong>，即</strong>同一时刻</strong>的$u_1$​​寄存器时钟和$u_4$​寄存器时钟。</p><p>因此，<br>$$<br>slack_{hold}&#x3D;0.75-0.23&#x3D;0.53<br>$$<br>此处报告中，$slack_{hold}&#x3D;0.53$应该是小数点近似的结果。​</p><h3 id="2-源时钟延时、时钟网络延时——latency"><a href="#2-源时钟延时、时钟网络延时——latency" class="headerlink" title="2. 源时钟延时、时钟网络延时——latency"></a>2. 源时钟延时、时钟网络延时——latency</h3><p>代码：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TCL">create_clock -period <span class="hljs-number">10</span> [get_ports CLK] <br><span class="hljs-comment"># 产生一个周期为10的时钟</span><br>set_clock_uncertainty <span class="hljs-number">0.5</span> [get_ports CLK] <br><span class="hljs-comment"># 设置0.5的时钟偏差</span><br>set_clock_latency <span class="hljs-number">1</span> [get_ports CLK] <br><span class="hljs-comment"># 设置1的时钟网络延时</span><br>set_clock_latency -<span class="hljs-keyword">source</span> <span class="hljs-number">3</span> [get_ports CLK] <br><span class="hljs-comment"># 设置3的源时钟延时</span><br></code></pre></td></tr></table></figure><p>电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125214133403.png" alt="image-20211125212049653"></p><p>波形图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211125215658364.png" alt="image-20211125215658364"><br>$$<br>t_{date\ arrival}&#x3D;t_{network\ latency}+t_{source\ latency}+t_{ideal\ date\ arrival}<br>$$</p><p>$$<br>t_{date\ required}&#x3D;t_{network\ latency}+t_{source\ latency}+t_{skew}+t_{ideal\ date\ required}<br>$$</p><p>$$<br>slack_{hold}&#x3D;t_{date\ arrival}-t_{date\ required}&#x3D;t_{ideal\ date\ arrival}-(t_{skew}+t_{ideal\ date\ required})<br>$$</p><p>因为正偏差对于保持时间不利，故此使用的是$+t_{skew}$</p><p>因此，<br>$$<br>slack_{hold}&#x3D;t_{ideal\ date\ arrival}-(t_{skew}+t_{ideal\ date\ required})&#x3D;4.1-(3.5+0.29+0.5)&#x3D;-0.19<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（10）时序逻辑电路设计</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8810%EF%BC%89%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%8810%EF%BC%89%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述时序逻辑电路中的时序分析，包括建立时间、保持时间、最大延迟、污染延时、时间偏差和时间抖动等概念。并简述了时钟网络（在EDA中）分布技术和PLL技术。</p><hr><span id="more"></span><h1 id="第七章-时序逻辑电路设计"><a href="#第七章-时序逻辑电路设计" class="headerlink" title="第七章 时序逻辑电路设计"></a>第七章 时序逻辑电路设计</h1><h1 id="1-时序基础概念"><a href="#1-时序基础概念" class="headerlink" title="1. 时序基础概念"></a>1. 时序基础概念</h1><h2 id="1-时序分析的目的"><a href="#1-时序分析的目的" class="headerlink" title="1. 时序分析的目的"></a>1. 时序分析的目的</h2><p>对数字系统进行时序检查，判断电路是否可以正常工作（常面临建立时间和保持时间等问题），判断电路的性能等。</p><p>常常分析<strong>电压、温度、工艺（工艺角）</strong>等参数进行分析。</p><h2 id="2-时序分析的分类"><a href="#2-时序分析的分类" class="headerlink" title="2. 时序分析的分类"></a>2. 时序分析的分类</h2><h3 id="1-静态时序分析（STA）"><a href="#1-静态时序分析（STA）" class="headerlink" title="1. 静态时序分析（STA）"></a>1. 静态时序分析（STA）</h3><ul><li><p>主要研究对象：<font color=red><b>建立时间、保持时间、传播延时</b></font></p></li><li><p>常用于分析<font color=red><b>同步时序电路</b></font>（源时钟和目的时钟相同）</p></li><li><p>时序分析模型：</p><ul><li>同步时钟&#x2F;异步时钟</li><li>D触发器分割组合逻辑</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019205442171.png"></p></li><li><p>一般不需要进行太复杂的仿真，仅需要计算就可以进行分析，运行速度快。</p></li><li><p>不依赖于激励，根据<font color=red><b>穷尽信号路径上的器件</b></font>就可以进行计算</p></li><li><p><strong>常用方法</strong>是使用<font color=red><b>查找表——①输入跳变时间②输出负载（电容）→①传播延时②输出跳变（下一级的输入跳变）</b></font>。</p><p>具体方法如下：</p><pre><code class=" mermaid">graph LR        第n级输出跳变时间 --即第n+1级输入跳变时间--&gt; 对应的n+1级器件的查找表    subgraph 第n级   第n级输入跳变时间 --&gt; 对应的n级器件的查找表    第n级负载电容值 --&gt; 对应的n级器件的查找表     对应的n级器件的查找表 --&gt; 第n级传播延时    对应的n级器件的查找表 --&gt; 第n级输出跳变时间    end    subgraph 第n+1级    第n+1级负载电容值 --&gt; 对应的n+1级器件的查找表    对应的n+1级器件的查找表 --&gt; 第n+2级传播延时    对应的n+1级器件的查找表 --&gt; 第n+2级输出跳变时间    end</code></pre></li></ul><h3 id="2-动态时序分析（DTA）"><a href="#2-动态时序分析（DTA）" class="headerlink" title="2. 动态时序分析（DTA）"></a>2. 动态时序分析（DTA）</h3><ul><li>指<font color=red><b>门级仿真</b></font></li><li>主要用于<strong>异步逻辑、多周期路径</strong></li><li>在FPGA中，将RTL代码综合利用综合工具综合成门级网络进行仿真，其中各种门级器件的逻辑是厂家提供的。</li></ul><h2 id="3-【时钟】沿"><a href="#3-【时钟】沿" class="headerlink" title="3. 【时钟】沿"></a>3. 【时钟】沿</h2><ul><li>发送沿：发送数据的<strong>源时钟</strong>活动沿</li><li>捕获沿：接收数据的<strong>目的时钟</strong>的活动沿</li><li>源时钟：用于发送数据的时钟</li><li>目的时钟：用于接受数据的时钟</li></ul><p><strong>小贴士</strong>：在同步电路中，源时钟和目的时钟是同一个</p><h2 id="4-时序约束参数"><a href="#4-时序约束参数" class="headerlink" title="4. 时序约束参数"></a>4. 时序约束参数</h2><p>即：建立时间$t_{su}$、保持时间$t_{hold}$、传播延时$t_{c-q}$，同时我们引入<font color=red><b>污染时间</b>$t_{cd}$</font> </p><h3 id="1-建立时间："><a href="#1-建立时间：" class="headerlink" title="1. 建立时间："></a>1. 建立时间：</h3><p>对于捕获沿到来之前，数据需要保持稳定的时间</p><p>间接约束了<strong>组合逻辑的最大延时</strong></p><h3 id="2-保持时间："><a href="#2-保持时间：" class="headerlink" title="2. 保持时间："></a>2. 保持时间：</h3><p>对于捕获沿到来之后，数据需要保持稳定的时间</p><p>间接约束了<strong>组合逻辑的最小延时</strong></p><h3 id="3-传播时间（延时）："><a href="#3-传播时间（延时）：" class="headerlink" title="3. 传播时间（延时）："></a>3. 传播时间（延时）：</h3><ul><li><p>即<font color=red><b>最大延时时间</b></font></p></li><li><p><strong>捕获沿50%（数据输入沿50%【注意：<font color=red>数据输入沿其实就是捕获沿！！！</font>】）到数据稳定输出（输出数据50%）的时间</strong></p></li><li><p>根据器件不同，可以分为组合逻辑传播延时$t_{logic}$​​和寄存器传播延时$t_{c-q}$​​​​，详细见后文。</p></li></ul><h3 id="4-污染时间："><a href="#4-污染时间：" class="headerlink" title="4. 污染时间："></a>4. 污染时间：</h3><ul><li>可以理解为<font color=red><b>最短延时时间</b></font>——理想状态下</li><li><strong>从输入“扰动”到输出“扰动”的时间</strong>，下文进行解释。</li><li>根据器件不同，可以分为组合逻辑污染延时$t_{logic,cd}$和寄存器污染延时$t_{c-q,cd}$​​，详细见后文</li><li>所谓<strong>理想状态</strong>，指的是数据没有跳变时间，即数据跳变是瞬间完成的，数据跳变的$90%$、$50%$、$10%$​​是在同一个时间。</li><li>根据以上理想状态的定义，可认为一有<font color=red><b>扰动</b></font>，数据就跳变完成。</li></ul><h3 id="5-计算污染时间和传播时间"><a href="#5-计算污染时间和传播时间" class="headerlink" title="5. 计算污染时间和传播时间"></a>5. 计算污染时间和传播时间</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019213546648.png" alt="image-20211020103111439"></p><p>现对图中四个时间进行解释：</p><ul><li><p>组合逻辑：</p><ul><li><p>组合逻辑污染延时$t_{logic,cd}$​：图中①②之间的时间差$t_{12}$。</p><p>解释：</p><p>​在①时刻，组合逻辑的输入端发生扰动，对于污染延时的计算，①时刻数据跳变完成，即输入信号的50%在①时刻；</p><p>​在②时刻，组合逻辑的输出端发生扰动，对于污染延时的计算，②时刻数据跳变完成，即输入信号的50%在②时刻；</p><p>​故对于组合逻辑，计算污染延时，是<strong>从输入“扰动”对输出“扰动”的时间</strong>，即<br>$$<br>t_{logic,cd}&#x3D;t_{12}&#x3D;t_2-t_1<br>$$</p></li><li><p>组合逻辑传播延时$t_{logic}$​：图中③④之间的时间差$t_{34}$</p><p>解释：</p><p>​在①时刻，输入数据开始发生扰动，但是此时数据并没有稳定。当③时刻，数据输入正式跳变到50%</p><p>​在②时刻，输出数据开始发生扰动，但是此时数据并没有稳定。当④时刻，数据输出正式跳变到50%</p><p>​故对于组合逻辑，其传播延时为<br>$$<br>t_{logic}&#x3D;t_{34}&#x3D;t_4-t_3<br>$$</p></li></ul></li><li><p>时序逻辑：</p><ul><li><p>寄存器的污染延时$t_{c-q,cd}$，图中⑤⑥之间的时间差$t_{56}$​</p><p>解释：</p><p>​当时钟的捕获沿到来时，即⑤时刻，$D$​端数据被捕获到寄存器中（锁存在寄存器的第一级锁存器中），并进行传输。</p><p>​<strong>故时钟的捕获沿即为数据输入数据沿，捕获沿50%即为数据输入沿50%</strong></p><p>​当输出端$Q$​发生扰动，即⑥时刻。计算污染延时时，有扰动说明数据跳变完成，于是⑥时刻，为输出数据的50%</p><p>​故，寄存器的污染延时为<br>$$<br>t_{c-q,cd}&#x3D;t_{56}&#x3D;t_6-t_5<br>$$</p></li><li><p>寄存器的传播延时$t_{c-q,cd}$​，图中⑤⑦之间的时间差$t_{57}$​​</p><p>解释：</p><p>​当时钟的捕获沿到来时，即⑤时刻，$D$​端数据被捕获到寄存器中（锁存在寄存器的第一级锁存器中），并进行传输。</p><p>​<strong>故时钟的捕获沿即为数据输入数据沿，捕获沿50%即为数据输入沿50%</strong></p><p>​当输出端$Q$​​发生扰动，即⑥时刻，但是数据没有稳定。在⑦时刻，输出数据正式跳变到50%</p><p>​故，寄存器的传播延时为<br>$$<br>t_{c-q}&#x3D;t_{57}&#x3D;t_7-t_5<br>$$</p></li></ul></li></ul><h2 id="5-各种信号路径、时序路径"><a href="#5-各种信号路径、时序路径" class="headerlink" title="5. 各种信号路径、时序路径"></a>5. 各种信号路径、时序路径</h2><p>信号的路径主要分为三个</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019210811041.png" alt="image-20211019210811041" style="zoom:67%;" /><ul><li><p>时钟路径</p><ul><li><p><strong>源时钟路径</strong>：</p><pre><code class=" mermaid">graph LR    模块输入端口的源时钟 --&gt; 某个发送时序单元的时钟引脚</code></pre><p>如图所示，$Clk_{u1}→u1时钟引脚$​​</p></li><li><p><strong>目的时钟路径</strong>：</p><pre><code class=" mermaid">graph LR    模块输入端口的目的时钟 --&gt; 某个捕获时序单元的时钟引脚</code></pre><p>如图所示，$Clk_{u4}→u4时钟引脚$​</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211020103111439.png" alt="image-20211019213546648"></p></li><li><p>数据路径</p><pre><code class=" mermaid">graph LR    路径起点 --&gt; 路径终点</code></pre><ul><li><p><strong>数据起点</strong>：</p><ol><li>对于时序逻辑电路，为某时序单元的<strong>时钟引脚</strong></li><li>对于组合逻辑电路，为某逻辑单元的<strong>数据输入端口</strong></li></ol></li><li><p><strong>数据终点</strong>：</p><p>​对于组合逻辑电路、时序逻辑电路都一样，均为某单元的<strong>数据输出端口</strong></p></li></ul></li><li><p>异步路径（如异步复位）</p></li></ul><p>根据路径可将分析类型分为</p><ul><li>同步分析：时钟路径+数据路径</li><li>异步分析：时钟路径+异步路径</li></ul><h2 id="6-时钟参数两大条件"><a href="#6-时钟参数两大条件" class="headerlink" title="6. 时钟参数两大条件"></a>6. 时钟参数两大条件</h2><h3 id="1-周期条件"><a href="#1-周期条件" class="headerlink" title="1. 周期条件"></a>1. 周期条件</h3><p>$$<br>T&gt;t_{c-q}+t_{logic}+t_{su}<br>$$</p><p>其中，</p><p>$t_{c-q}$​：本级寄存器的（最坏）传播延时</p><p>$t_{logic}$：两个寄存器之间组合逻辑的（最坏）传播延时</p><p>$t_{su}$​：下一级寄存器需要的建立时间</p><h3 id="2-保持时间条件"><a href="#2-保持时间条件" class="headerlink" title="2. 保持时间条件"></a>2. 保持时间条件</h3><p>$$<br>t_{hold}&lt;t_{c-q,cd}+t_{logic,cd}<br>$$</p><p>其中，</p><p>$t_{c-q,cd}$​​：本级寄存器的污染延时</p><p>$t_{logic,cd}$​：两个寄存器之间组合逻辑的延时</p><p><strong>小贴士</strong>：如何理解这个不等式？</p><p>​前文提到，计算单元的污染时间，是<strong>”扰动“对”扰动“</strong>。于是，$t_{c-q,cd}+t_{logic,cd}$的意思就是从本级寄存器时钟有效沿到下一级寄存器的输入扰动的时间（下一级寄存器的输入扰动即为组合逻辑的输出扰动）。即当$t_{c-q,cd}+t_{logic,cd}$时间过后，下一级的数据输入端已经开始出现扰动，输入开始不稳定。而对于下一级寄存器，其保持时间要求的是下一级有效时钟沿到来之后，其数据输入端需要保持稳定的时间。于是，下一级寄存器的保持时间，只能小于其输入端扰动到来的时间，即有上式。</p><h2 id="7-【实验测量】建立时间与保持时间"><a href="#7-【实验测量】建立时间与保持时间" class="headerlink" title="7. 【实验测量】建立时间与保持时间"></a>7. 【实验测量】建立时间与保持时间</h2><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211020105507695.png" alt="image-20211020105507695"></p><ol><li><p>测量建立时间：</p><p>让时钟去采集一个脉冲$D$，设定足够长的保持时间，然后使$D$上升沿不断向时钟沿压缩，如图所示。当输出$D$出现错误时，记下当前上升沿时间$t_1$​，则认为建立时间略大于$t_{clk}-t_1$</p></li><li><p>测量保持时间：</p><p>同上，不断压缩$D$的下降沿，当输出$Q$​出现错误时，记下当前下降沿时刻$t_2$，则认为保持时间略大于$t_2-t_{clk}$​。</p></li></ol><h1 id="2-时间偏差与抖动"><a href="#2-时间偏差与抖动" class="headerlink" title="2. 时间偏差与抖动"></a>2. 时间偏差与抖动</h1><p>理想时钟：</p><ol><li>从时钟沿到各个单元的时钟端口的延时相等（即路径均匀）；</li><li>同一个时刻，各个单元的时钟端的时钟相位相等。</li></ol><p>实际时钟：</p><ol><li>时钟偏差：各个时钟端口的时钟的周期没有改变，但是<strong>相位</strong>可能略有差别。</li><li>时钟抖动：时钟的<strong>周期</strong>存在一些差别，或长或短。</li></ol><h2 id="1-时钟偏差-Clock-Skew"><a href="#1-时钟偏差-Clock-Skew" class="headerlink" title="1. 时钟偏差(Clock Skew)"></a>1. 时钟偏差(Clock Skew)</h2><h3 id="1-定义与成因"><a href="#1-定义与成因" class="headerlink" title="1. 定义与成因"></a>1. 定义与成因</h3><p>指同一个时钟域之间，时钟信号到达各个寄存器的<font color=red><b>最大时间差</b></font></p><p><strong>产生原因</strong>：</p><ol><li>时钟源到达各个端点的路径长度不同</li><li>各个端口的负载不同</li><li>时钟网络中插入的缓存器不等</li></ol><h3 id="2-计算【全局偏差、局部偏差】："><a href="#2-计算【全局偏差、局部偏差】：" class="headerlink" title="2. 计算【全局偏差、局部偏差】："></a>2. 计算【全局偏差、局部偏差】：</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025204529658.png" alt="image-20211025204529658"><br>$$<br>\delta&#x3D;t_{r-max}-t_{r-min}<br>$$<br>其中，</p><p>$\delta$：时钟偏差</p><p>$t_{r-max}$​​：从该时钟域的时钟输入端口到该时钟域内寄存器的最长时间，如图中②</p><p>$t_{r-max}$​​​​：从该时钟域的时钟输入端口到该时钟域内寄存器的最短时间，如图中①</p><h4 id="1-全局时钟偏差"><a href="#1-全局时钟偏差" class="headerlink" title="1. 全局时钟偏差"></a>1. 全局时钟偏差</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025204713311.png" alt="image-20211025213413238"></p><p>如图所示，蓝色阴影部分为全局电路。</p><p>可知，$t_{r-max}&#x3D;0.38ns(T_3)$​​​；$t_{r-min}&#x3D;0.36ns(T_2)$​​​，故时钟偏差$\delta&#x3D;0.38-0.36&#x3D;0.02ns$​​​</p><h4 id="2-局部时钟偏差"><a href="#2-局部时钟偏差" class="headerlink" title="2. 局部时钟偏差"></a>2. 局部时钟偏差</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025204957015.png" alt="image-20211025204957015"></p><p>如图所示，蓝色阴影部分和上面部分电路之间，不存在逻辑关系，因此阴影部分可以当成该时钟域下的一个<strong>局部电路</strong>。</p><p>可知，对于<strong>阴影部分</strong>而言，$t_{r-max}&#x3D;0.22ns(T_3)$​​​​；$t_{r-min}&#x3D;0.21ns(T_2)$​​​​，故时钟偏差$\delta&#x3D;0.22-0.21&#x3D;0.01ns$</p><p><strong>注意</strong>，非阴影部分电路不属于该局部电路，故而$t_{r-min}$取$T_2$，而不取$T_3$</p><h3 id="2-时钟偏差分类（正负）"><a href="#2-时钟偏差分类（正负）" class="headerlink" title="2. 时钟偏差分类（正负）"></a>2. 时钟偏差分类（正负）</h3><h4 id="1-正偏差"><a href="#1-正偏差" class="headerlink" title="1. 正偏差"></a>1. 正偏差</h4><p>正偏差，即<font color=red><b>时钟延迟方向与数据流方向一致</b></font>，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025210013014.png"></p><ul><li><p>建立时间：<strong>正偏差对于建立时间是有利的</strong>。</p><p>​因为信号从$R_1$传播到$R_2$​的时间多了$\delta$，即$T+\delta$，如图所示。</p><p>​意味着，逻辑运算完，数据输出稳定之后，还能多出$\delta$​​​的时间$R_2$​​才接收，即整体时间冗余多了$\delta$​，即建立时间（裕量）多了$\delta$​​。</p></li><li><p>保持时间：<strong>正偏差对于保持时间是不利的</strong>。</p><p>​<font color=red><b>保持时间是针对同一个周期，上下两级寄存器而言的</b></font>。</p><p>​同一周期，$CLK2$​​落后$CLK1\ \delta$​​​​​时间​，意味着$t_{hold}+\delta&lt;t_{c-q,cd}+t_{logic,cd}$​​​，意味着电路对于竞争（保持时间）更加敏感。</p></li></ul><h4 id="2-负偏差"><a href="#2-负偏差" class="headerlink" title="2. 负偏差"></a>2. 负偏差</h4><p>正偏差，即<font color=red><b>时钟延迟方向与数据流方向相反</b></font>，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025213413238.png" alt="image-20211025210013014"></p><ul><li><p>建立时间：<strong>负偏差对于建立时间是不利的</strong>。</p><p>​因为信号从$R_1$​传播到$R_2$​​的时间少了$\delta$​，即$T-\delta$​，如图所示。</p><p>​意味着，逻辑运算完，数据输出稳定之后，少了$\delta$​​​的时间$R_2$​​才接收，即整体时间冗余少了$\delta$​，即建立时间少了$\delta$​​​。</p><p>​如果要留有足够的建立时间裕量，只能减少逻辑运算时间，即<strong>实际逻辑运算时间较小</strong></p></li><li><p>保持时间：<strong>负偏差对于保持时间是有利的</strong>。</p></li><li><p>时钟周期：因为留给逻辑运算的时间减小，如果逻辑运算时间不能减小，建立时间裕量不能减少，只能将周期增加$\delta$​才能满足时序要求。周期的增加，意味着电路性能的降低。</p></li></ul><h3 id="3-【重点】利用时间偏差修补建立时间"><a href="#3-【重点】利用时间偏差修补建立时间" class="headerlink" title="3. 【重点】利用时间偏差修补建立时间"></a>3. 【重点】利用时间偏差修补建立时间</h3><p><font color=red><b>思想：增大或者缩小时钟路径上的buffer的尺寸来修正某些寄存器的建立时间</b></font></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025220852654.png" alt="image-20211025220852654"></p><p>由图可知，寄存器$R_3$​的建立时间裕量为$-0.15ns&lt;0ns$，不满足建立时间要求。</p><p>但是，$R_2$​的建立时间裕量为$0.20ns&gt;0$​，电路输出裕量$0.10ns&gt;0$​。</p><p>可以在$R_2$、$R_3$的时钟路径上进行buffer尺寸（即时钟偏差）的调整。</p><p>解决方案：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025221606061.png" alt="image-20211025221606061"></p><h3 id="4-【周期-T-​】时钟偏差对于周期的影响"><a href="#4-【周期-T-​】时钟偏差对于周期的影响" class="headerlink" title="4. 【周期$T$​】时钟偏差对于周期的影响"></a>4. 【周期$T$​】时钟偏差对于周期的影响</h3><p>前文提到，<strong>负偏差使得实际逻辑计算的时间减小</strong>，为了填补裕量，只能增加时间周期，而提高时间周期会使得电路的<strong>性能下降</strong>。</p><ul><li><p>最坏情况：$R_2$比$R_1$早到达$\delta$</p></li><li><p>该情况出现在：时钟负偏差</p></li><li><p><strong>负偏差下的最小时钟约束：</strong><br>$$<br>T&gt;t_{c-q}+t_{logic}+t_{su}+\delta<br>$$</p></li><li><p>为了减小时钟偏差对于周期的影响，通用的方法就是<font color=red><b>使得时钟网络中的</b>$\delta$​<b>尽可能小</b></font>。</p></li><li><p>下文会总结</p></li></ul><h2 id="2-时钟抖动-Clock-Jitter"><a href="#2-时钟抖动-Clock-Jitter" class="headerlink" title="2. 时钟抖动(Clock Jitter)"></a>2. 时钟抖动(Clock Jitter)</h2><h3 id="1-定义与计算"><a href="#1-定义与计算" class="headerlink" title="1. 定义与计算"></a>1. 定义与计算</h3><p>定义：芯片某一给定点上，时钟周期宽度发生变化，或缩短或变宽</p><p>计算：</p><ol><li><p>**绝对时钟抖动$t_{jitter}$**：某一给定位置的一个时钟边沿相对理想时钟边沿最坏情况下的变化（绝对值）</p><p>如图，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211025234107739.png" alt="image-20211025234107739"></p><center>时钟抖动<p>存在$-t_{jitter}$和$t_{jitter}$</p></li><li><p>周期至周期抖动$T_{jitter}$：第$j+1$级时钟沿和第$j$级时钟沿到达节点$n$的时间差。</p><p>计算公式如下：<br>$$<br>T_{jitter}&#x3D;t_{n,j+1}-t_{n,j}-T_{clk}<br>$$<br>其中，</p><p>$t_{n,j+1}$：第$j+1$级时钟沿到达节点$n$的时刻</p><p>$t_{n,j}$​：第$j$级时钟沿到达节点$n$​​的时刻</p><p>$T_{clk}$：理想的时钟周期</p><p>可知<strong>最坏情况下，周期至周期抖动</strong>为（即图中①-⑥或③-④），<br>$$<br>T_{jitter-max}&#x3D;±2t_{jitter}<br>$$</p></li></ol><h3 id="2-【周期-T-​​​】时钟抖动对于周期的影响"><a href="#2-【周期-T-​​​】时钟抖动对于周期的影响" class="headerlink" title="2. 【周期$T$​​​】时钟抖动对于周期的影响"></a>2. 【周期$T$​​​】时钟抖动对于周期的影响</h3><p>因为时钟抖动是难以预料的，在确定时钟周期的时候，我们应该考虑最坏的情况，即<br>$$<br>T-2t_{jitter}&gt;t_{c-q}+t_{logic}+t_{su}<br>$$<br>即上图所示的③-④。因为这意味着周期$T$需要增加$2t_{jitter}$​，性能降低。​</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><h3 id="1-【周期-T-】影响"><a href="#1-【周期-T-】影响" class="headerlink" title="1. 【周期$T$】影响"></a>1. 【周期$T$】影响</h3><table><thead><tr><th align="center">类型</th><th align="center">时钟偏差</th><th align="center">时钟抖动</th></tr></thead><tbody><tr><td align="center">对周期起影响</td><td align="center">负偏差$-\delta$</td><td align="center">最坏情况：$-2t_{jitter}$</td></tr></tbody></table><p>公式：<br>$$<br>T-\delta-2t_{jitter}&gt;t_{c-q}+t_{logic}+t_{su}<br>$$<br>即<br>$$<br>T&gt;t_{c-q}+t_{logic}+t_{su}+\delta+2t_{jitter}<br>$$</p><p><strong>注意</strong>：$\delta$和$t_{jitter}$均为绝对值</p><h3 id="2-来源（了解）"><a href="#2-来源（了解）" class="headerlink" title="2. 来源（了解）"></a>2. 来源（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026164908332.png"></p><ol><li>时钟信号产生</li><li>静态时钟偏差：期间工艺的差别，如缓冲器buffer</li><li>互联偏差：使用金属密度填充</li><li>环境变化：<ul><li>温度：使用反馈电路进行温度补偿</li><li>电源：时钟驱动器周围加入去耦电容</li></ul></li><li>电容耦合</li></ol><h1 id="3-时钟分布技术"><a href="#3-时钟分布技术" class="headerlink" title="3. 时钟分布技术"></a>3. 时钟分布技术</h1><h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h2><p>目标：</p><ul><li>时钟偏差和时钟抖动尽可能小</li><li>功耗尽可能小</li></ul><p>需要考虑的问题：</p><ul><li>不同单元模块的时钟输入负载不同，需要考虑局部负载的问题</li><li>不用太在意源到各个寄存器之间延时，应该考虑寄存器之间的相对偏差，即<strong>时钟偏差</strong>才是重要的</li></ul><h2 id="2-时钟分布网络"><a href="#2-时钟分布网络" class="headerlink" title="2. 时钟分布网络"></a>2. 时钟分布网络</h2><p>常用的有<strong>H树时钟分布网络、网格型结构</strong></p><h3 id="1-H树时钟分布"><a href="#1-H树时钟分布" class="headerlink" title="1. H树时钟分布"></a>1. H树时钟分布</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026172252462.png" alt="image-20211026172252462"></p><p>理想情况下，时钟偏差为0；但实际上，因为制造工艺和环境变化等原因，依然存在时钟的偏差和抖动。</p><h3 id="2-网格结构"><a href="#2-网格结构" class="headerlink" title="2. 网格结构"></a>2. 网格结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026172848521.png" alt="image-20211026172848521"></p><p>优点：</p><ul><li><p>延时相对较小</p></li><li><p>设计后期容易改动，因为芯片上的各个点都可以容易的得到时钟</p></li></ul><p>缺点：</p><ul><li>有许多”多余“的互连线，功耗增大；</li><li>不适合做门控时钟，因为大多数寄存器都是直接从时钟网络见过来的。</li></ul><h2 id="3-时钟网络指导原则（略）"><a href="#3-时钟网络指导原则（略）" class="headerlink" title="3. 时钟网络指导原则（略）"></a>3. 时钟网络指导原则（略）</h2><h1 id="4-锁相环PLL"><a href="#4-锁相环PLL" class="headerlink" title="4. 锁相环PLL"></a>4. 锁相环PLL</h1><h2 id="1-框图"><a href="#1-框图" class="headerlink" title="1. 框图"></a>1. 框图</h2><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026195146291.png" alt="image-20211026195146291"></p><ul><li><strong>压控振荡器</strong>：根据输入的模拟信号$V_{cont}$​产生一个对应频率的系统时钟信号</li><li><strong>相位检测器</strong>：片外参考时钟和N分频的系统时钟进行比较，根据相位差产生$Up$的$Down$​的信号</li><li><strong>电荷泵</strong>：根据$Up$​和$Down$​信号改变$V_{cont}$​</li><li><strong>低通滤波器</strong>：滤掉$V_{cont}$​中的高频成分，减小抖动</li></ul><h2 id="2-部分讲解"><a href="#2-部分讲解" class="headerlink" title="2. 部分讲解"></a>2. 部分讲解</h2><h3 id="1-压控振荡器"><a href="#1-压控振荡器" class="headerlink" title="1. 压控振荡器"></a>1. 压控振荡器</h3><p>根据输入的模拟信号$V_{cont}$，产生一个对应的频率，<strong>该频率与$V_{cont}$​成线性关系。</strong></p><p>公式略</p><h3 id="2-【重点】相位检测器"><a href="#2-【重点】相位检测器" class="headerlink" title="2. 【重点】相位检测器"></a>2. 【重点】相位检测器</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026201151069.png" alt="※相位检测器电路图"></p><p>注意：</p><ul><li><p>相位检测器是一个<strong>三状态的状态机</strong>，状态转换图如下</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026201949713.png" alt="image-20211026201949713"></p></li><li><p>相位检测器拥有**<font color=red>鉴频、鉴相</font>**的功能。</p><p><strong>鉴频</strong>：</p><table><thead><tr><th align="center">频率</th><th align="center">$f_A&#x3D;f_B$</th><th align="center">$f_A&gt;f_B$</th><th align="center">$f_A&lt;f_B$</th></tr></thead><tbody><tr><td align="center"></td><td align="center">平均脉冲数：UP&#x3D;DN</td><td align="center">平均脉冲数：UP&gt;DN，且DN的脉冲宽度极小</td><td align="center">平均脉冲数：UP&lt;DN，且UP的脉冲宽度极小</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211127232503203.png"></p><p><strong>鉴相</strong>：</p><table><thead><tr><th align="center">相位</th><th align="center">A超前B</th><th align="center">B超前A</th></tr></thead><tbody><tr><td align="center"></td><td align="center">脉冲宽度UP&gt;DN，UP的脉冲宽度&#x3D;AB的相位误差</td><td align="center">脉冲宽度UP&lt;DN，且DN的脉冲宽度&#x3D;AB的相位误差</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211127232430246.png" alt="image-20211127232430246" style="zoom:80%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（9）时序逻辑电路设计</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%889%EF%BC%89%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%889%EF%BC%89%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述时序电路中的基础元件：锁存器、寄存器（触发器）、施密特触发器。</p><hr><span id="more"></span><h1 id="第七章-时序逻辑电路设计"><a href="#第七章-时序逻辑电路设计" class="headerlink" title="第七章 时序逻辑电路设计"></a>第七章 时序逻辑电路设计</h1><h1 id="1-时序电路的相关概念"><a href="#1-时序电路的相关概念" class="headerlink" title="1. 时序电路的相关概念"></a>1. 时序电路的相关概念</h1><h2 id="1-时序电路"><a href="#1-时序电路" class="headerlink" title="1. 时序电路"></a>1. 时序电路</h2><p>框架：<br>$$<br>\text{时序电路}&#x3D;\text{组合电路}+\text{存储电路}<br>$$<br>结果：取决于<strong>当前的输入和过去的状态</strong>。</p><h2 id="2-静态-x2F-动态存储器"><a href="#2-静态-x2F-动态存储器" class="headerlink" title="2. 静态&#x2F;动态存储器"></a>2. 静态&#x2F;动态存储器</h2><ol><li><p>静态存储器：</p><ul><li><p>上电就保持存储状态</p></li><li><p>通过<strong>正反馈</strong>，有意将<strong>输入和输出连接</strong></p></li><li><p>如果长时间不用可以用门控时钟关闭（起到降低功耗的作用）</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010162502952.png" alt="静态存储器（以正锁存器为例）"></p></li></ul></li><li><p>动态存储器：</p><ul><li><p>简单而言，即<strong>传输门+反相器</strong>，如下图。</p></li><li><p>利用<strong>寄生电容</strong>存储高低电平</p></li><li><p>只能存储较短的时间（$ms$级别）（电容小等原因使得存储时间短）</p></li><li><p>需要<strong>周期性刷新</strong>来补偿泄露电荷（参见（8）动态门）</p></li><li><p>结构简单，有<strong>较高性能</strong>（管子少，$RC$​小）和<strong>较低功耗</strong>（不存在静态功耗）</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010164426948.png" alt="image-20211010164426948"></p></li></ul></li></ol><h2 id="3-时序参数"><a href="#3-时序参数" class="headerlink" title="3. 时序参数"></a>3. 时序参数</h2><ol><li><p>建立时间$t_{Setup}$​</p><p>输入数据$D$在时钟有效沿到来前，必须有效的时间</p></li><li><p>保持时间（维持时间）$t_{Hold}$​​</p><p>输入数据$D$在时钟有效沿到来之后，必须保持稳定的时间</p></li><li><p>传播时间$t_{Propagate\ Time}$​</p><p>当<strong>满足建立时间和保持时间</strong>时，数据从输入端复制到输出端所需要的时间（$50%$对$50%$）。</p><p>即<font color=red><b>时钟</b>$CLK50%$<b>对输出端数据</b>$50%$​​</font>，如下图。</p><p><strong>为何这么说？</strong></p><p>因为只有当满足了建立时间，此时时钟$CLK$​​​​才可以翻转，即<strong>此时的数据才是输入端输入的数据</strong></p><p>所以<strong>输入端数据的$50%$即为时钟的$50%$</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010165303845.png" alt="D触发器的建立时间、保持时间、传播时间"></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010211358792.png" alt="仿真实例中的传播时间（CLK50%对输出端数据50%）"></p><p><strong>小贴士：</strong></p><ol><li><p>建立时间$t_{su}$和保持时间$t_{hold}$​​​都是<strong>​针对时钟的有效沿</strong>而言的。</p><p>即，输入数据$50%$的时间对时钟有效沿$50%$的时间；对于传播延时$t_{c-q}$，输入信号$50%$（即时钟信号$50%$）时间对输出信号$50%$时间</p></li></ol><h2 id="4-时序约束条件"><a href="#4-时序约束条件" class="headerlink" title="4. 时序约束条件"></a>4. 时序约束条件</h2><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010170652507.png" alt="image-20211010170652507"></p><ol><li><p>时钟周期$T$​</p><p>只有当<strong>当前所有计算全部完成，系统闲置</strong>，下个时钟（即下一个操作）才可到来。</p><p>其公式如下，<br>$$<br>T&gt;t_{c-q}+t_{p-logic}+t_{su}<br>$$<br>其中，</p><p>$t_{c-q}$：时序电路的传播时间（图中为D触发器的传播时间）</p><p>$t_{p-logic}$​：组合逻辑的<strong>最坏</strong>传播延时（图中为$ALGO$​的传播延时）</p><p>$t_{su}$​：时序电路的建立时间（图中为D触发器的建立时间）</p></li><li><p>保持时间$t_{hold}$</p><p>保证数据可以在有效沿保持足够长的时间，不会因新进入的数据而过早改变</p><p>其公式如下，<br>$$<br>t_{cdreg}+t_{cdlogic}&gt;t_{hold}<br>$$<br>其中，</p><p>$t_{hold}$：保持时间</p><p>$t_{cd}$​：最小传播延时&#x2F;时间，又称为污染延时，于是有</p><p>$t_{cdreg}$：寄存器的最小传播时间</p><p>$t_{cdlogic}$​：组合逻辑的最小传播延时</p></li></ol><h2 id="5-锁存器和寄存器"><a href="#5-锁存器和寄存器" class="headerlink" title="5. 锁存器和寄存器"></a>5. 锁存器和寄存器</h2><table><thead><tr><th align="center">项目</th><th align="center">锁存器</th><th align="center">寄存器</th></tr></thead><tbody><tr><td align="center">敏感类型</td><td align="center">电平敏感<br>（有效电平内随意反转）</td><td align="center">边沿敏感</td></tr><tr><td align="center">波形</td><td align="center"><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010191547153.png" alt="" style="zoom: 50%;" /></td><td align="center"><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010192010991.png" alt="image-20211010194213324" style="zoom:50%;" /></td></tr><tr><td align="center">波形解释</td><td align="center">图为正锁存器。<br>当$CLK&#x3D;1$，$Q&#x3D;D$（<strong>透明模式</strong>）<br>当$CLK&#x3D;0$，$Q&#x3D;Q$（<strong>保持模式</strong>）</td><td align="center">图为上升沿有效D触发器<br>上升沿到来，$Q&#x3D;D$<br>其他时候，$Q&#x3D;Q$</td></tr><tr><td align="center">需要注意的边沿<br>（该边沿到来需要考虑建立时间保持时间）</td><td align="center">正锁存器：时钟下降沿<br>负锁存器：时钟上升沿</td><td align="center">有效沿</td></tr><tr><td align="center">备注</td><td align="center"></td><td align="center">由锁存器作为基本单元构成</td></tr></tbody></table><h1 id="2-静态锁存器-x2F-寄存器"><a href="#2-静态锁存器-x2F-寄存器" class="headerlink" title="2. 静态锁存器&#x2F;寄存器"></a>2. 静态锁存器&#x2F;寄存器</h1><h2 id="1-静态锁存器"><a href="#1-静态锁存器" class="headerlink" title="1. 静态锁存器"></a>1. 静态锁存器</h2><h3 id="1-电路图与分析"><a href="#1-电路图与分析" class="headerlink" title="1. 电路图与分析"></a>1. 电路图与分析</h3><p>以正锁存器为例，电路图如下，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010194213324.png" alt="正锁存器电路图"></p><p><strong>电路结构</strong>：以传输门为主体的<em>二选一选择器</em>；$CLK&#x3D;1$，$Q&#x3D;D$；而$CLK&#x3D;0$，通过<strong>正反馈</strong>，输出端和输入端连接。</p><h3 id="2-时序参数分析"><a href="#2-时序参数分析" class="headerlink" title="2. 时序参数分析"></a>2. 时序参数分析</h3><p>1.5中提到，分析正锁存器时，需要注意的时钟边沿是时钟的下降沿。</p><p>这是因为，在$CLK&#x3D;1$时，$Q&#x3D;D$​，属于<strong>透明传输</strong>，即输出随输入随时变化。其信号传播路径：D-①-②-③-Q</p><p>当$CLK&#x3D;1→0$时，锁存器将要对输入数据进行所存。因此需要考虑<strong>建立时间$t_{su}$​</strong>。</p><p>如果要让数据可以正确锁存下来，需要④⑤之间的节点的电平等于③⑤之间节点的电平，即<br>$$<br>D_{④⑤}&#x3D;D_{③⑤}<br>$$<br>即，如果要所锁存数据A，则当数据A到达④⑤节点之前，$D&#x3D;A$​​不可以改变，其信号传播路径：D-①-②-③-④-$Node_{④⑤}$​​</p><h2 id="2-静态寄存器——边沿触发寄存器"><a href="#2-静态寄存器——边沿触发寄存器" class="headerlink" title="2. 静态寄存器——边沿触发寄存器"></a>2. 静态寄存器——边沿触发寄存器</h2><p>边沿触发寄存器，又称主-从寄存器，由主、从两个锁存器组成</p><h3 id="1-电路图与分析-1"><a href="#1-电路图与分析-1" class="headerlink" title="1. 电路图与分析"></a>1. 电路图与分析</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026160355289.png" alt="框架图"></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010200528010.png" alt="传输门电路原理图"></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211026160542210.png" alt="时序图"></p><p>主-从寄存器，由主锁存器——负锁存器、从锁存器——正锁存器组成。</p><ul><li>$CLK&#x3D;0→1$​​​​​时，主锁存器锁存数据。</li><li>在①阶段，即$CLK&#x3D;1$，主锁存器输出$Q_M$保持不变，从锁存器随主锁存器输出值$Q_M$而变化（就是不变、<strong>从锁存器透明传输</strong>）；</li><li>$CLK&#x3D;1→0$时，从锁存器锁存数据。​</li><li>在②阶段，即$CLK&#x3D;0$​​，​​​从锁存器持续输出锁存的数据。</li></ul><center><b>过程总结</b></center><table><thead><tr><th align="center">$CLK$</th><th align="center">$0→1$（上升沿）</th><th align="center">阶段①：$CLK&#x3D;1$</th><th align="center">$1→0$（下降沿）</th><th align="center">阶段②：$CLK&#x3D;0$</th></tr></thead><tbody><tr><td align="center">主锁存器</td><td align="center">锁存数据</td><td align="center">保持锁存</td><td align="center"></td><td align="center">透明传输</td></tr><tr><td align="center">从锁存器</td><td align="center"></td><td align="center">透明传输</td><td align="center">锁存数据</td><td align="center">保持锁存</td></tr></tbody></table><p>于是，有以下结论：</p><ul><li>寄存器的有效沿同从锁存器的敏感电平相关。<strong>对于从锁存器，如是正锁存器，则为上升沿；反之，下降沿。</strong></li><li>从锁存器可以持续输出一个值长达一个时钟周期。</li></ul><h3 id="2-时序参数分析-1"><a href="#2-时序参数分析-1" class="headerlink" title="2. 时序参数分析"></a>2. 时序参数分析</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010200528010.png" alt="传输门电路原理图"></p><p><strong>设定</strong>反相器延时为$t_{pd-inv}$，传输门延时为$t_{pd-tx}$​，时钟INV无延时。</p><p><strong>明确</strong>：**<font color=red>有效时钟沿为上升沿，一切参数均以有效时钟沿作为基准</font>**</p><h4 id="1-建立时间-t-su"><a href="#1-建立时间-t-su" class="headerlink" title="1. 建立时间$t_{su}$"></a>1. 建立时间$t_{su}$</h4><p>类似于2.1.2 静态锁存器时序参数的分析，可知需要满足$D_{I2-T2}&#x3D;D_{T2-I3}$</p><p>即信号传输到$Node_{I2-T2}$之前，输入数据$D$​不能变化，数据路径为$D-I_1-T_1-I_3-I_2$​（3个INV，1个TX）</p><p>即有<br>$$<br>t_{su}&#x3D;3t_{pd-inv}+t_{pd-tx}<br>$$</p><h4 id="2-保持时间-t-hold"><a href="#2-保持时间-t-hold" class="headerlink" title="2. 保持时间$t_{hold}$"></a>2. 保持时间$t_{hold}$</h4><p>当$CLK&#x3D;1$时，$T_1$就会关断，因此需要保证$CLK&#x3D;1$之前，数据$D$已经通过传输门$T_1$</p><p>因为数据$D$​进入$T_1$之前需要经过$I_1$；而时钟作用于$T_1$之前，同样需要经过$INV$​​；故而二者作用域于$T_1$时间差不多。</p><p>于是只需要留一定的余量给$t_{hold}$即可，即有<br>$$<br>t_{hold}≈0<br>$$</p><h4 id="3-传播时间-t-c-q"><a href="#3-传播时间-t-c-q" class="headerlink" title="3. 传播时间$t_{c-q}$"></a>3. 传播时间$t_{c-q}$</h4><p>前面1.3提到，传播时间是<strong>满足建立时间和保持时间</strong>之后，数据从输入端到输出端的时间（$50%$​对$50%$​）或者时钟$CLK50%$对输出端数据$50%$的时间（原因见1.3）。</p><p>满足了<strong>建立时间</strong>，此时输入数据$D$​​​已经到达了$Node_{I4-T3}$​​​（<strong>因为为了满足建立时间，数据到达$Node_{I3-I4}$​​之后，还要经历$I_2$​​。经历$I_2$​​的延时同数据经历$I_4$​​的延时相互抵消了</strong>）</p><p>此时传播时间即为$Node_{I4-T3}$​到达$Q$​的时间</p><p>而又因为此时$CLK&#x3D;1$，从锁存器处于透明模式，故数据路径为$Node_{I4-T3}-T_3-I_6-Q$​（1个INV、1个TX）</p><p>即有，<br>$$<br>t_{c-q}&#x3D;t_{pd-inv}+t_{pd-tx}<br>$$</p><h3 id="3-寄存器复位——同步-x2F-异步"><a href="#3-寄存器复位——同步-x2F-异步" class="headerlink" title="3. 寄存器复位——同步&#x2F;异步"></a>3. 寄存器复位——同步&#x2F;异步</h3><h4 id="1-同步复位（RST-x3D-0时复位）"><a href="#1-同步复位（RST-x3D-0时复位）" class="headerlink" title="1. 同步复位（RST&#x3D;0时复位）"></a>1. 同步复位（RST&#x3D;0时复位）</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220502144029350.png" alt="同步复位"></p><h4 id="2-异步复位（clr-x3D-0时复位）"><a href="#2-异步复位（clr-x3D-0时复位）" class="headerlink" title="2. 异步复位（clr&#x3D;0时复位）"></a>2. 异步复位（clr&#x3D;0时复位）</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220501232734462.png" alt="异步复位"></p><h1 id="3-动态锁存器-x2F-寄存器"><a href="#3-动态锁存器-x2F-寄存器" class="headerlink" title="3. 动态锁存器&#x2F;寄存器"></a>3. 动态锁存器&#x2F;寄存器</h1><h2 id="1-动态锁存器"><a href="#1-动态锁存器" class="headerlink" title="1. 动态锁存器"></a>1. 动态锁存器</h2><p>电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211011162522262.png" alt="动态锁存器电路图"></p><p>使用<strong>电容电荷</strong>表示一个逻辑信号。</p><p>但是值的保存时间有限（$ms$）（漏电时间），需要周期性进行刷新。</p><h2 id="2-动态寄存器"><a href="#2-动态寄存器" class="headerlink" title="2. 动态寄存器"></a>2. 动态寄存器</h2><h3 id="1-电路图"><a href="#1-电路图" class="headerlink" title="1. 电路图"></a>1. 电路图</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211011163927553.png" alt="动态锁存器电路图"></p><h3 id="2-工作原理："><a href="#2-工作原理：" class="headerlink" title="2. 工作原理："></a>2. 工作原理：</h3><p>$CLK&#x3D;0$，$T_1$导通，$A$对$D$进行采样，并通过$C_1$充放电进行保存。</p><p>$CLK&#x3D;1$​，$T_1$​关端，$T_2$​导通，从$A$​看$T_1$​和反相器$I_1$都呈现高阻态，$C_1$无法充放电，于是$C_1$​电荷值锁存。根据$D_A$​值，反相器$I_1$​进行对数据进行反向（即$I_1$​输出端上拉或者下拉），实现$C_2$​的充电或者放电。</p><p>$CLK&#x3D;0$​​，$T_1$​​导通，$A$​​对$D$​​进行采样，并通过$C_1$​​​充放电进行保存。此时$T_2$​​截止，从$B$​​看$T_2$​​​和反相器$I_2$​都呈现高阻态，于是$C_2$​​只能保持电荷。</p><p>….</p><h3 id="3-时间参数分析："><a href="#3-时间参数分析：" class="headerlink" title="3. 时间参数分析："></a>3. 时间参数分析：</h3><ul><li><p>建立时间$t_{su}$​：</p><p>输入信号$D$传输到$A$，并且$A$节点完成$C_1$​充电或放电时间（电容容值小，电荷量小，充电放电时间极短，可忽略不计）。<br>$$<br>t_{su}&#x3D;1t_{pd-tx}<br>$$</p></li><li><p>保持时间$t_{hold}$：</p><p>传输门在时钟边沿关断，近似0。<br>$$<br>t_{hold}≈0<br>$$</p></li><li><p>传播延时$t_{c-q}$：</p><p>满足建立时间和保持时间之后，此时信号已经到$A$​节点。传播延时（时间）即为信号从$A$到$Q$的时间。</p><p>即2个反相器+1个传输门+$C_2$​​充放电时间。<br>$$<br>t_{c-q}&#x3D;2t_{pd-inv}+t_{pd-tx}<br>$$</p></li></ul><h3 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4. 存在的问题"></a>4. 存在的问题</h3><ol><li><p>通过$C_1$、$C_2$​​​电容进行存储，抗干扰能力差（<strong>噪声容限低</strong>）。</p></li><li><p>$C_1$、$C_2$​电容存在漏电现象，需要不断刷新。</p></li><li><p><strong>时钟重叠问题</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211011170957239.png" alt="时间重叠问题"></p><p>$\overline{CLK}$是通过$CLK$反相而来，于是需要用到<strong>反相器</strong>，于是$CLK$和$\overline{CLK}$之间存在延时。</p><p>于是在时钟跳转的时候，二者会有一段时间电平相当，这样子工作是有问题的，即存在<strong>竞争行为</strong>。</p><p><strong>解决办法</strong>：</p><ol><li>（0，0）重叠：<strong>PMOS均导通</strong>，需保证在$D$输入和节点$B$（数据不会影响到$C_2$电平）之间有足够的延时，以使主级采样的新数据不会传送到从级。</li><li>（1，1）重叠：<strong>NMOS均导通</strong>，需要强加一个<strong>保持（维持）时间</strong>，使得$D$保持一段时间不变，即可。</li></ol></li></ol><h3 id="5-优化——提高噪声容限"><a href="#5-优化——提高噪声容限" class="headerlink" title="5. 优化——提高噪声容限"></a>5. 优化——提高噪声容限</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211011172513451.png" alt="image-20211011170957239"></p><p>增加<strong>弱反馈——反相器$I_1$​</strong>，形成“伪静态电路”​​，可提高抗噪能力。</p><p>缺点：增加少量延时。</p><h1 id="4-流水线和多周期路径"><a href="#4-流水线和多周期路径" class="headerlink" title="4. 流水线和多周期路径"></a>4. 流水线和多周期路径</h1><h2 id="1-流水线"><a href="#1-流水线" class="headerlink" title="1. 流水线"></a>1. 流水线</h2><p>电路的工作速度取决于<strong>时序电路间的组合逻辑</strong></p><ul><li>可以通过将复杂、延迟大的组合逻辑（如计算$lg(A·B)$​）通过寄存器进行分割，提高做工效率。</li><li><font color=red><b>需要注意时序设计</b></font>。每增加一个寄存器，结果就落后一拍！</li></ul><h2 id="2-多周期路径"><a href="#2-多周期路径" class="headerlink" title="2. 多周期路径"></a>2. 多周期路径</h2><p>主要是写<strong>RTL</strong>代码时需要注意。</p><p>如果一个组合逻辑计算需要多个时间周期完成，可以通过一个<code>cnt</code>进行移位（移位运算量小）。当满足某个条件时，寄存器<code>en=1</code>，输出结果。</p><p>如：某运算需要经过四个周期完成，可以声明<code>cnt=4&#39;b0001</code>，每个时钟进行左移，当<code>cnt[3]==1&#39;b1</code>时，<code>en=1</code>，输出结果。</p><h1 id="5-双稳态时序电路"><a href="#5-双稳态时序电路" class="headerlink" title="5. 双稳态时序电路"></a>5. 双稳态时序电路</h1><h2 id="1-施密特触发器"><a href="#1-施密特触发器" class="headerlink" title="1. 施密特触发器"></a>1. 施密特触发器</h2><p>符号：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019194200702.png" alt="施密特触发器符号"></p><p>波形：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019194307002.png" alt="施密特触发器波形图"></p><p><strong>用处</strong>：将含有<strong>噪声或者缓慢变化</strong>的信号转变为一个干净的数字输出信号，即<strong>“0”或者“1”</strong>。</p><p>​或者说：<font color=red><b>抑制信号的振荡，使输入信号迅速翻转。</b></font></p><p><strong>原理</strong>：一般采用互补CMOS进行搭建，改变PMOS管和NMOS管的$W$之比，实现$V_M$的改变。</p><p>​（增大PMOS管的尺寸，$V_M$​​后移）</p><p><strong>施密特触发器互补CMOS电路图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211019194622279.png" alt="施密特触发器互补CMOS电路图"></p><p>分析：</p><ol><li><p>$V_{in}&#x3D;0→1$​​​，故最初，$V_{out}&#x3D;0$​​，此时下拉网络$M_1$​​导通、上拉网络$M_2$​​、$M_4$​​​导通，即$\frac{W_P}{W_N}$增大，$V_M$​​​<strong>往后移</strong>。</p><p>当$V_{in}&gt;V_M$之后，则$M_4$截至而$M_3$导通，此时$\frac{W_P}{W_N}$减小，于是$X$信号可以加速$1→0$的翻转，从而可以得到<strong>高速翻转</strong>的$V_{out}(0→1)$</p></li><li><p>$V_{in}&#x3D;1→0$​，故最初，$V_{out}&#x3D;1$​，此时下拉网络$M_1$​、$M_3$​导通、上拉网络$M_2$​导通，即$\frac{W_P}{W_N}$​减小，$V_M$​<strong>往前移</strong>。</p><p>当$V_{in}&lt;V_M$之后，则$M_3$截至而$M_4$导通，此时$\frac{W_P}{W_N}$增大，于是$X$信号可以加速$0→1$的翻转，从而可以得到<strong>高速翻转</strong>的$V_{out}(1→0)$</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（8）动态CMOS</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%888%EF%BC%89%E5%8A%A8%E6%80%81CMOS/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%888%EF%BC%89%E5%8A%A8%E6%80%81CMOS/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述动态逻辑门的基本概念和多米诺逻辑。</p><hr><span id="more"></span><h1 id="第六章-CMOS组合逻辑门电路"><a href="#第六章-CMOS组合逻辑门电路" class="headerlink" title="第六章 CMOS组合逻辑门电路"></a>第六章 CMOS组合逻辑门电路</h1><h2 id="9-动态CMOS"><a href="#9-动态CMOS" class="headerlink" title="9. 动态CMOS"></a>9. 动态CMOS</h2><p>静态CMOS：稳态时，通过<strong>低阻</strong>路径连接$V_{DD}$或$GND$</p><ul><li>互补CMOS：上下网络互补，上拉到$V_{DD}$，下拉到$GND$​。管子数为$2N$</li><li>传输管逻辑：上拉网络用其他代替，有比逻辑，存在$V_{TH}$。管子数为$N+1$</li></ul><p>动态CMOS：依靠<strong>高阻抗</strong>上的<strong>电容</strong>存储临时的信号。管子数为$N+2$</p><h3 id="1-动态门"><a href="#1-动态门" class="headerlink" title="1. 动态门"></a>1. 动态门</h3><h4 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h4><p>结构如下，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006183050542.png" alt="image-20211006183050542"></p><p><strong>工作方式</strong>：工作分为两个阶段</p><ul><li><font color=red><b>预充电</b></font>：$CLK&#x3D;0$，$M_P$导通，对$C_L$充电</li><li><font color=red><b>求值</b></font>：$CLK&#x3D;1$，$M_N$导通，$OUT$和$GND$之间存在低阻通路。</li></ul><p>特点：</p><ul><li>全电压摆幅</li><li>无比逻辑（同互补CMOS，异传输管逻辑）</li><li>噪声容限低。因为$out$​在预充电阶段已经充电到$V_{DD}$，即$V_{DS}$已经满足$&gt;V_{OV}$，于是只要$V_{IN}&gt;V_{TH}$，管子就会导通。</li><li>需要预充电和求值的<strong>时钟</strong>。</li><li>较快的开关速度。原因如下，<ul><li>相对互补CMOS，缺少了上拉网络的一个门，相对负载是互补CMOS，负载是动态门的$C_L$比较小</li><li>动态门没有短路电流（同一个时刻，只能一个$M$导通），由下拉网络提供的所有电流都用于$C_L$​电容的放电(?)</li><li>如果$IN&#x3D;0$​，则不存在输出延时（预充电完输出即为1）；如果$IN&#x3D;1$​，则需要$C_L$​放电</li></ul></li><li>晶体管重复利用，减小面积（多输出多米诺）</li></ul><p><strong>优点</strong>：</p><ul><li>提高速度</li><li>减小面积（多输出多米诺；$N+2$​个管子）</li><li>没有短路功耗</li><li>没有毛刺（因为一次只能翻转一次，$C_L$放电完只能等效下一次预充电才能回到1）</li></ul><h4 id="2-存在的问题——信号完整性问题"><a href="#2-存在的问题——信号完整性问题" class="headerlink" title="2. 存在的问题——信号完整性问题"></a>2. 存在的问题——信号完整性问题</h4><ol><li><p><strong>电荷泄露</strong></p><ul><li><p>来源：与$C_L$​相连的管子存在反偏二极管和亚阈值漏电。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006194414006.png" alt="image-20211006194414006"></p></li><li><p>解决办法：使用<strong>泄露晶体管</strong></p><ul><li>反馈形式的伪NMOS型上拉器件。</li><li>该晶体管为了减小功耗和尺寸，一般选用尺寸较小（电阻值大）的管子。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006194347868.png" alt="image-20211006194347868"></p></li></ul></li><li><p><strong>电荷分享</strong></p><ul><li><p>来源：下拉网络中存在的节点电容$C_A$。当$A&#x3D;0→1、B&#x3D;0$，则原本存储在电容$C_L$上的电荷在$C_L$和$C_A$​​之间重新分配，造成输出电压有所下降。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006195455550.png" alt="image-20211006195455550"></p><p>※需要满足$A&#x3D;0→1、B&#x3D;0$才能进行电荷分享，否则当$B&#x3D;1$​的时候，求值过程中（$CLK&#x3D;1$​），$C_L$存储的电荷将全部被释放掉，不存在点电荷分享现象。</p></li><li><p><strong>【重点】【计算】</strong>计算电荷分享对于输出电压的影响</p><p><strong>根据的是</strong><font color=red><b>电荷守恒</b></font></p><p>关于计算，会在后面详解</p></li><li><p>解决办法：使用<strong>泄露晶体管</strong></p><p>这种方法几乎不用。会增加面积和电容。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006200314654.png" alt="image-20211006200314654"></p><p>使用泄露晶体管$M_{kp}$​​对<strong>关键的内部节点预充电</strong>，但是会增加面积和电容。</p><p>注意：和上文中的“电荷泄露”中的泄露晶体管进行区分。</p></li></ul></li><li><p><strong>电容耦合</strong>（略）</p><p>使得$V_{out}$略有下降</p></li><li><p><strong>时钟馈通</strong>（略）</p><ul><li><p>起因：<strong>时钟输入和动态节点输出</strong>之间的耦合电容引起</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006202315657.png" alt="image-20211006202315657"></p></li><li><p>现象：时钟反转过快，则当$CLK$​​ $0\rightarrow 1$​​时，动态节点输出$&gt;V_{DD}$​​；则当$CLK$​​ $1\rightarrow 0$​​时，动态节点输出$&lt;0$​​</p></li><li><p>危害：时钟馈通危险在于可能使正常情况下<strong>反偏二极管变为正向偏置</strong>，导致出错  </p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006202444751.png" alt="image-20211006202444751"></p></li></ul></li></ol><h4 id="3-【计算】计算电荷分享对于输出电压的影响"><a href="#3-【计算】计算电荷分享对于输出电压的影响" class="headerlink" title="3. 【计算】计算电荷分享对于输出电压的影响"></a>3. 【<strong>计算</strong>】计算电荷分享对于输出电压的影响</h4><p>前提：没有加泄露晶体管的时候，电荷分享对于输出电压的影响</p><p>根据：电荷守恒定律</p><p>例1：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211127093045819.png" alt="image-20211006200314654"></p><p>可知求值期间，$CLK&#x3D;1$​，因此电路如果存在电荷分享现象，则$A&#x3D;1、B&#x3D;0$​才能存在电荷分享。</p><p>如果$A&#x3D;B&#x3D;CLK&#x3D;1$​，则$Out$​对地有直接通路，则$C_L$​的电荷将被全部放掉，不存在电荷分享的现象。</p><p>对于计算电荷分享，需要<strong>输出电压降$\Delta V_{out}$​</strong>分两种情况：</p><p>首先<strong>假设其他参与电荷分享的电容上的电压和输出电压相等，即$V_{Cx}(t)&#x3D;V_{out}(t)$</strong></p><ul><li>$\Delta V_{out}&gt;V_{Tn}$​</li><li>$\Delta V_{out}&lt;V_{Tn}$​</li></ul><p>其中，</p><p>$\Delta V_{out}&#x3D;V_{DD}-V_{out}(t)$​​​。</p><p>$V_{DD}$​​​​为初始输出电压，因为$CLK&#x3D;0$​​时输出预充电到$V_{DD}$​​​​</p><p>$V_{out}(t)$​​​​​为电压分享之后的输出电压。​</p><p><strong>情况①：</strong>$\Delta V_{out}&gt;V_{Tn}$​，则<strong>实际上</strong>$V_{Cx}(t)&#x3D;V_{out}(t)$​</p><p><strong>情况①：</strong>$\Delta V_{out}&lt;V_{Tn}$​，则<strong>实际上</strong>$V_{Cx}(t)&#x3D;V_{DD}-V_{Tn}$​</p><p>​即电压分享之后，$C_L$上的电压或者说输出电压和其他参与电荷分享的电容上的电压相等。</p><p>​因为$PDN$都是NMOS管，对于其他参与电荷分享的电容最多只能充电充到$V_{DD}-V_{Tn}$</p><p>​如图中$X$点，当$A&#x3D;1$时，即$V_{A}&#x3D;V_{DD}$，则$V_X-max&#x3D;V_{DD}-V_{Tn}$，因此$\Delta V_{X}(t)<em>{min}&#x3D;V</em>{DD}-V_X-max&#x3D;V_{Tn}$</p><p>​因此如果$\Delta V_{out}&gt;V_{Tn}$，则说明<strong>假设</strong>的参与电荷分享电容上的压降和$V_{DD}$之间的差值大于$\Delta V_{X}(t)_{min}$，满足假设</p><p>解题：</p><p>设$C_a&#x3D;V_{out}$​，则根据电荷守恒定律<br>$$<br>C_LV_{DD}&#x3D;(C_a+C_L)V_{out}<br>$$<br>计算得到$V_{out}$</p><p>根据$\Delta V_{out}&#x3D;V_{DD}-V_{out}$和$V_{Tn}$的值</p><p>分为两种情况：</p><p>①$\Delta V_{out}&gt;V_{Tn}$，则上面计算得到的$V_{out}$即为正确的值</p><p>②$\Delta V_{out}&lt;V_{Tn}$，则<br>$$<br>C_LV_{DD}&#x3D;C_LV_{out}+C_a(V_{DD}-V_{Tn})<br>$$<br>计算得到$V_{out}$</p><p>例2：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211127103528067.png" alt="image-20211006200314654"></p><p>解题方法如上。</p><h4 id="4-串联动态门"><a href="#4-串联动态门" class="headerlink" title="4. 串联动态门"></a>4. 串联动态门</h4><ol><li><p>存在的问题：前级的输出可能会影响到后级，从而使后级预充电完的$C_L$放电</p></li><li><p>解决办法：</p><p>规定<strong>预充电</strong>的时候，所有的输入均为0；当<strong>求值</strong>的时候，输入只能从0变化到1。</p><p>故在两级之间放一个<code>buffer</code>（反相器）。当前一级预充电到1的时候，1经过反相器之后得到0，并且作为后一级的输入，确保预充电时所有的输入为0。</p></li></ol><h3 id="2-多米诺逻辑"><a href="#2-多米诺逻辑" class="headerlink" title="2. 多米诺逻辑"></a>2. 多米诺逻辑</h3><h4 id="1-综述-1"><a href="#1-综述-1" class="headerlink" title="1. 综述"></a>1. 综述</h4><p>多米诺逻辑即为前文所述的<strong>串联动态门</strong>，<strong>目的</strong>就是<font color=red><b>保证预充电时，输入均为0；求值时，输入只做0→1的翻转</b></font><br>$$<br>多米诺逻辑&#x3D;n型动态门+反相器<br>$$<br><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006203758438.png" alt="image-20211006203758438"></p><p>初始状态均为0，求值的时候根据前一级输出确定下一级输入，从而求下一级输出。</p><p>特点：</p><ul><li>求值层层传播，如多米诺骨牌</li><li>求值阶段的时间取决于<strong>逻辑深度</strong>（因为求值时候的特性，见上）</li><li>只能实现<strong>非反向</strong>逻辑</li><li><strong>无比逻辑</strong></li><li>节点需要在预充电充完电，求值的过程中，输入需要特别稳定。</li><li><strong>速度非常快</strong>（因为当上一级的输入都是0时，下一级相当于无延迟传播）</li><li>输入电容小（和互补CMOS比，只有一个管子）</li></ul><h4 id="2-去掉下拉时钟网络"><a href="#2-去掉下拉时钟网络" class="headerlink" title="2. 去掉下拉时钟网络"></a>2. 去掉下拉时钟网络</h4><p>如下图所示，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006205648830.png" alt="image-20211006205648830"></p><p>优点：</p><ul><li>只需要第一级的下拉时钟负载，后面的不用。<strong>减少时钟负载</strong>。</li><li>速度和性能可以得到大大提升</li></ul><p>缺点：</p><ul><li>去掉下拉时钟网络，需要满足该动态门$CLK&#x3D;0$​​时，该<strong>动态门输入均为0</strong>，否则可能导致<strong>短路</strong></li><li>为了达到上文的目标，需要<strong>精确把控时钟</strong>。</li></ul><p><strong>方法：</strong></p><p>​不同级的动态门的$CLK$​并不是同时的，需要<font color=red><b>逐级推迟时钟时间</b></font>。</p><p>​也就是该时钟必须通过逻辑网络传输，不同级之间可能需要<code>Buffer</code>进行缓冲延迟。这对于时钟的把控特别严格。</p><h4 id="3-多米诺逻辑的性能优化"><a href="#3-多米诺逻辑的性能优化" class="headerlink" title="3. 多米诺逻辑的性能优化"></a>3. 多米诺逻辑的性能优化</h4><ol><li><p>调整反相器的晶体管尺寸</p><p>分析可知，</p><p><strong>预充电过程中</strong>，主要经过两个门的延迟：</p><ul><li>$V_{DD}$通过<strong>上拉时钟PMOS管</strong>对$C_L$进行充电</li><li>本级动态门输出逻辑1经过<strong>反相器（INV的PMOS管）</strong>输出逻辑0，作为下一级输入</li></ul><p><strong>求值过程中</strong>，如果存在该动态门输入存在从$0→1$​​​跳变，主要经过两部分延迟：</p><ul><li>本级动态门<strong>下拉网络</strong>对$C_L$进行放电</li><li>本级动态门输出逻辑0经过<strong>反相器（INV的PMOS管）</strong>输出输出逻辑1，作为下一级的求值输入</li></ul><p>可根据情况进行反相器尺寸的调整（一般为了减低求值时间，会<strong>增大INV的PMOS尺寸</strong>）</p></li><li><p>面积优化</p><ul><li><p>采用<strong>多输出多米诺逻辑</strong>，见下文。</p><p>多输出多米诺逻辑中，<strong>动态逻辑门可以实现多种逻辑，可以重复利用一些晶体管，使得晶体管数目减小</strong>。</p></li><li><p>或者使用组<strong>合多米诺逻辑</strong>，见下文。</p><p>组合多米诺逻辑，并<strong>不需要</strong>在每个动态门之后加<strong>反相器</strong>，而是借助一个复合互补CMOS门将多个动态门组合起来。</p></li></ul></li></ol><h4 id="4-多输出多米诺"><a href="#4-多输出多米诺" class="headerlink" title="4. 多输出多米诺"></a>4. 多输出多米诺</h4><p>多输出多米诺可以重复利用一些晶体管，一个复合逻辑门里面可以实现多种逻辑，减小了晶体管数量，大大减小面积。</p><p>$eg$：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211006213224199.png" alt="image-20211006213224199"></p><p>如上图所示，$P_{3:0}$和$G_{3:0}$共用$P_1$、$P_3$管子。</p><p>其中，$P_{3:0}&#x3D;P_0P_1P_2P_3$；$G_{3:0}&#x3D;G_3+$</p><h4 id="5-组合多米诺逻辑"><a href="#5-组合多米诺逻辑" class="headerlink" title="5. 组合多米诺逻辑"></a>5. 组合多米诺逻辑</h4><p>组合多米诺逻辑，并<strong>不需要</strong>在每个动态门之后加<strong>反相器</strong>，而是借助一个复合互补CMOS门将多个动态门组合起来。</p><pre><code class=" mermaid">graph LR动态门1 ==Y1==&gt; 复合CMOS门动态门2 ==Y2==&gt; 复合CMOS门动态门... ==Y...==&gt; 复合CMOS门复合CMOS门 ==&gt; 结果</code></pre><p>$eg:$</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211010155234054.png" alt="image-20211010155234054"></p><p>如上图，动态门组成逻辑：$Y1&#x3D;\overline{A·B}$；经过静态互补CMOS门，组成逻辑$Y2&#x3D;\overline{Y1·In}$​</p><p>注意，$Y1$结果并<strong>不需要经过反相器</strong></p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（7）传输管和传输门逻辑</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%887%EF%BC%89%E4%BC%A0%E8%BE%93%E7%AE%A1%E5%92%8C%E4%BC%A0%E8%BE%93%E9%97%A8%E9%80%BB%E8%BE%91/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%887%EF%BC%89%E4%BC%A0%E8%BE%93%E7%AE%A1%E5%92%8C%E4%BC%A0%E8%BE%93%E9%97%A8%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述静态互补CMOS电路中的传输管逻辑和传输门逻辑，其中传输门逻辑未整理成笔记。</p><hr><span id="more"></span><h1 id="第六章-CMOS组合逻辑门电路"><a href="#第六章-CMOS组合逻辑门电路" class="headerlink" title="第六章 CMOS组合逻辑门电路"></a>第六章 CMOS组合逻辑门电路</h1><h2 id="6-传输管逻辑"><a href="#6-传输管逻辑" class="headerlink" title="6. 传输管逻辑"></a>6. 传输管逻辑</h2><h3 id="1-有比逻辑"><a href="#1-有比逻辑" class="headerlink" title="1. 有比逻辑"></a>1. 有比逻辑</h3><p>传输管逻辑是有比逻辑；互补CMOS是无比逻辑。</p><p>简单而言，</p><ul><li><p>无比逻辑：输出的高低电平和尺寸无关。比如互补CMOS可以直接把输出电压拉到$V_{DD}$或者$GND$</p></li><li><p>有比逻辑：<strong>输出的高低电平和尺寸有关。基本没办法直接拉到最大逻辑摆幅。</strong></p><ul><li><p><strong>上拉网络由一个负载代替</strong>，如下三种常见的负载（电阻负载、有源负载、伪NMOS负载）</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003154810444.png" alt="image-20211003152600955"></p></li><li><p>输出端的电压摆幅和门的功能<strong>取决于NMOS和PMOS的尺寸比</strong></p></li><li><p>对于<strong>伪NMOS管负载</strong></p><ul><li><p>优点：<strong>逻辑门减小，面积减小</strong>，只需要$n+1$个管子，而互补CMOS需要$2n$​个管子</p></li><li><p>缺点：</p><ol><li>有比逻辑，达不到最大逻辑摆幅。</li><li>可能没办法完全关断MOS管，静态功耗增加。</li></ol></li><li><p>应用：<strong>面积要求严格</strong>，性能要求不高的场景。</p></li></ul></li></ul></li></ul><h3 id="2-传输管逻辑"><a href="#2-传输管逻辑" class="headerlink" title="2. 传输管逻辑"></a>2. 传输管逻辑</h3><h4 id="1-区别"><a href="#1-区别" class="headerlink" title="1. 区别"></a>1. 区别</h4><p>传输管逻辑和互补CMOS有以下差别：</p><table><thead><tr><th align="center"></th><th align="center">传输管</th><th align="center">互补CMOS</th></tr></thead><tbody><tr><td align="center">逻辑</td><td align="center">有比逻辑</td><td align="center">无比逻辑</td></tr><tr><td align="center">输入端</td><td align="center">漏极<code>D</code>、栅极<code>G</code></td><td align="center">只能栅极<code>D</code></td></tr><tr><td align="center">面积&#x2F;管子数&#x2F;寄生电容</td><td align="center">小&#x2F;少&#x2F;小</td><td align="center">大&#x2F;多&#x2F;大</td></tr><tr><td align="center">摆幅</td><td align="center">存在$V_{TH}$，无法达到最大摆幅</td><td align="center">可上拉到$V_{DD}$​下拉到$GND$​，实现最大摆幅</td></tr><tr><td align="center">静态功耗</td><td align="center">可能存在“关不断”情况，静态功耗较大</td><td align="center">完全关断，静态功耗小</td></tr></tbody></table><h4 id="2-串联"><a href="#2-串联" class="headerlink" title="2. 串联"></a>2. 串联</h4><p>综合以上的区别，<strong>原因</strong>主要出在于输入端可以从<code>D</code>、<code>G</code>，而输出从<code>S</code>，从而使<strong>输出和输入之间存在$V_{TH}$​的压降</strong></p><p>为了减小$V_{TH}$​带来的影响，<strong>传输管串联</strong>采用<code>D-S-D-S</code>的方式，而不采用<code>D-S-G-S</code>的方式</p><p>前者只有一个$V_{TH}$压降，而后者有两个</p><p>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003152600955.png" alt="image-20211003154810444"></p><h3 id="3-互补传输管逻辑（CPL）"><a href="#3-互补传输管逻辑（CPL）" class="headerlink" title="3. 互补传输管逻辑（CPL）"></a>3. 互补传输管逻辑（CPL）</h3><p>优点：</p><ul><li>互补输入输出</li><li>每个输出节点都有一个<strong>低阻路径</strong>连接到$V_{DD}$或者$GND$</li><li>模块化</li></ul><p>缺点：</p><ul><li><p>存在$V_{TH}$，充电充不到$V_{DD}$，只<strong>能充到$V_{DD}-V_{TH}$</strong></p><p><strong>解决方法</strong>：电平恢复、多种阈值晶体管、<strong>传输门逻辑</strong></p></li></ul><p><strong>确定输出：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003155630034.png" alt="image-20211003155630034"></p><p>以<code>AND/NAND</code>为例，</p><p><code>AND</code>：$F&#x3D;AB+B\overline{B}&#x3D;AB$</p><p><code>NAND</code>：$\overline{F}&#x3D;\overline{A}B+\overline{B}·\overline{B}&#x3D;\overline{AB}$</p><h2 id="7-传输门逻辑"><a href="#7-传输门逻辑" class="headerlink" title="7. 传输门逻辑"></a>7. 传输门逻辑</h2><p>笔者：时间有点久远，忘了为啥没写了</p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（6）棍棒图和欧拉路径</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%886%EF%BC%89%E6%A3%8D%E6%A3%92%E5%9B%BE%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%886%EF%BC%89%E6%A3%8D%E6%A3%92%E5%9B%BE%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述如何画“棍棒图”和“欧拉路径”来优化复合逻辑门电路的版图设计。</p><hr><span id="more"></span><h1 id="第六章-CMOS组合逻辑门电路"><a href="#第六章-CMOS组合逻辑门电路" class="headerlink" title="第六章 CMOS组合逻辑门电路"></a>第六章 CMOS组合逻辑门电路</h1><h2 id="5-复合逻辑门的版图技术"><a href="#5-复合逻辑门的版图技术" class="headerlink" title="5. 复合逻辑门的版图技术"></a>5. 复合逻辑门的版图技术</h2><p>在（5）4【静态CMOS】组合逻辑的优化重点讨论了<strong>复合逻辑门的尺寸优化</strong></p><p>此处，重点讨论<strong>如何设计逻辑门的版图</strong></p><p>指标如下：</p><ul><li>性能好（$RC$小）</li><li>占用面积小</li></ul><h3 id="1-棍棒图"><a href="#1-棍棒图" class="headerlink" title="1. 棍棒图"></a>1. 棍棒图</h3><p>棍棒图已经在<strong>（1）第二章 版图基础</strong> 中有所提及</p><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ul><li>器件不标尺寸</li><li>注重相对位置和连接关系</li></ul><h4 id="2-串联-并联"><a href="#2-串联-并联" class="headerlink" title="2. 串联-并联"></a>2. 串联-并联</h4><ol><li><p>串联：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906215723057.png" alt="image-20210906215723057" style="zoom: 80%;" /></li><li><p>并联：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906220913771.png" alt="image-20210906220913771" style="zoom:80%;" /></li></ol><h4 id="3-好的棍棒图"><a href="#3-好的棍棒图" class="headerlink" title="3. 好的棍棒图"></a>3. 好的棍棒图</h4><ul><li><p>一个阱中只有一条扩散区</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003134357474.png" alt="image-20211003134357474"></p><p>如上图，图中的扩散区被打断（图中圈画处）。根据设计规则，版图之间应该存在距离，使得版图面积增加。同时寄生参数也会增加。</p><p>改变输入端顺序，得到如下改进，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003134629160.png" alt="image-20211003134629160"></p><p>可以得到一个简单的结论：<strong>合理的输入端顺序可以优化版图——欧拉路径（见下文）</strong></p></li><li><p>同一个输入控制的NMOS管和PMOS管对准。</p></li></ul><h3 id="2-欧拉路径"><a href="#2-欧拉路径" class="headerlink" title="2. 欧拉路径"></a>2. 欧拉路径</h3><p>根据欧拉路径可以得到合理的输入端排列顺序，使得复合逻辑门可以用连续的扩散区来实现，达到占用面积最小、性能好。</p><p>设计步骤步骤如下：</p><h4 id="1-构建逻辑图"><a href="#1-构建逻辑图" class="headerlink" title="1. 构建逻辑图"></a>1. 构建逻辑图</h4><p>逻辑图详见（4）2.3</p><p>此处不加赘述</p><h4 id="2-识别欧拉路径"><a href="#2-识别欧拉路径" class="headerlink" title="2. 识别欧拉路径"></a>2. 识别欧拉路径</h4><p>欧拉路径：<strong>通过逻辑图中所有节点并且每条边只经过一次的路径</strong></p><ul><li>如果上拉网络或者下拉网络<strong>存在欧拉路径</strong>，就说明多个晶体管可以<strong>共用一条扩散区</strong>。</li><li>如果上拉网络和下拉网络的<strong>欧拉路径相同</strong>，说明同一个输入控制的<strong>NMOS管和PMOS管对准</strong></li><li>欧拉路径的顺序，就是输入端在版图中的排列顺序。</li></ul><p>$eg：AOI22$</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220501230206832.png" alt="image-20220501230206832"></p><center>AOI22原理图</center><p>步骤一：画出逻辑图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003140836606.png" alt="image-20211003140836606"></p><p>步骤二：找出欧拉路径</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003140915753.png" alt="image-20211003140915753"></p><p>步骤三：根据欧拉路径排布输入端顺序，并画出棍棒图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211003141000878.png" alt="image-20211003141000878"></p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（5）努力</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%885%EF%BC%89%E5%8A%AA%E5%8A%9B/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%885%EF%BC%89%E5%8A%AA%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述静态互补CMOS电路“努力”计算，并且通过“努力”计算设计最佳逻辑链电路。</p><hr><span id="more"></span><h1 id="第六章-CMOS组合逻辑门电路"><a href="#第六章-CMOS组合逻辑门电路" class="headerlink" title="第六章 CMOS组合逻辑门电路"></a>第六章 CMOS组合逻辑门电路</h1><h2 id="4-【静态CMOS】组合逻辑的优化"><a href="#4-【静态CMOS】组合逻辑的优化" class="headerlink" title="4. 【静态CMOS】组合逻辑的优化"></a>4. 【静态CMOS】组合逻辑的优化</h2><h3 id="1-总论"><a href="#1-总论" class="headerlink" title="1. 总论"></a>1. 总论</h3><ol><li><p>不同材料工艺</p><p>CMOS、双极性、BiCMOS、GaAs、超导等材料</p></li><li><p>逻辑级优化</p><ul><li>逻辑深度：流水线【一级变n级】</li><li>电路拓扑：逻辑电路寄存器放几个、怎么放、要不要放；重定时（主要EDA工具完成）</li><li>扇出</li><li>门的复杂性</li></ul></li><li><p>电路优化</p><p>逻辑类型、晶体管尺寸、不同频率下的电路模型</p></li><li><p>物理优化</p><p>版图策略</p></li><li><p>布局布线</p></li></ol><h3 id="2-【重点】努力"><a href="#2-【重点】努力" class="headerlink" title="2. 【重点】努力"></a>2. 【重点】努力</h3><p>根据INV延时的通式，<br>$$<br>t_p&#x3D;t_{p0}·(1+ \frac{f}{\gamma})<br>$$<br>推广到所有的逻辑电路中，即有<br>$$<br>t_p&#x3D;t_{p0}·(p+ \frac{g·f}{\gamma})&#x3D;t_{p0}·(p+ \frac{h}{\gamma})<br>$$<br>其中，</p><p>$t_{p0}$：简单INV的本征延时。</p><p>$p$​​：复合门和简单INV的<strong>本征延时之比</strong>（显然，INV的$p&#x3D;1$）。</p><p>$g$：<strong>逻辑努力</strong></p><p>$f$：<strong>电气努力</strong>，即讨论INV链时说的<strong>等效扇出</strong>，定义为$C_{ext}&#x3D;f C_g$，第$j+1$级管子相对于第$j$级管子的尺寸。</p><p>$h$：<strong>门努力</strong>，即$h&#x3D;g·f$​</p><p>为了方便讨论，将反相器的延时作为单位，进行<strong>归一化</strong>，将所有逻辑电路的延时用反相器延时作为单位进行表示。</p><p>设定，<strong>一个标准的反相器（对称反相器）</strong>，$W_P&#x3D;2,W_N&#x3D;1$​​​​，即$W_{INV}&#x3D;3$​​​，即一个单位的$W&#x3D;3$​​</p><p>设定，</p><ul><li><p>$g_{INV}&#x3D;1$​​（一个标准的INV，其$W&#x3D;3$​​​）</p></li><li><p>$p_{INV}&#x3D;1$​（一个标准的INV，其本征延时为$t_{p0}$​）</p></li><li><p>$\gamma&#x3D;1$​（一个标准的INV，其本征漏电容等于输入栅电容）</p></li></ul><p>下面对上面的参数进行讨论</p><h4 id="1-p-（本征延时比）"><a href="#1-p-（本征延时比）" class="headerlink" title="1. $p$（本征延时比）"></a>1. $p$（本征延时比）</h4><p>如果忽略内部节点电容，$p$​​​的计算：<br>$$<br>p&#x3D;\frac{复合门的输出端本征电容}{INV输出端的本征电容}<br>$$<br>因，$C_{int}&#x3D;a·W$​​​，于是电容值​可以用$W$​来代替。</p><p><strong>注意，是和输出端相连的管子才参与计算</strong></p><p>例子：</p><table><thead><tr><th align="center">门类型</th><th align="center">$p$</th></tr></thead><tbody><tr><td align="center">反相器INV</td><td align="center">$1$</td></tr><tr><td align="center">$n$输入的NAND 或 $n$输入的NOR</td><td align="center">$n$</td></tr><tr><td align="center">$n$路多路开关</td><td align="center">$2n$</td></tr><tr><td align="center">XOR，NXOR</td><td align="center">$n2^{n-1}$</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002172842916.png" alt="image-20211002172842916"></p><p>如上图，</p><p>对于<code>2-input NADN</code>，$C_L&#x3D;C_{PB}+C_{PA}+C_{NA}&#x3D;2+2+2&#x3D;2·3$​​​​</p><p>对于<code>2-input NOR</code>，$C_L&#x3D;C_{PA}+C_{NA}+C_{NB}&#x3D;4+1+1&#x3D;2·3$</p><p>忽略内部节点电容，也就是<code>2-input NAND</code>的两个NMOS管之间的电容、<code>2-input NOR</code>的两个PMOS管之间的电容忽略不计。</p><p>因为逻辑门的宽长比是按照<strong>标准INV（对称INV）</strong>的设定的，于是有$R_{PUN}&#x3D;R_{PDN}&#x3D;R_{INV}$​​</p><p>通过计算可知，<br>$$<br>t_{复合门p0}&#x3D;0.69RC_L&#x3D;p·t_{p0}<br>$$</p><h4 id="2-g-​​（逻辑努力）和-G-​（路径逻辑努力）"><a href="#2-g-​​（逻辑努力）和-G-​（路径逻辑努力）" class="headerlink" title="2. $g$​​（逻辑努力）和$G$​（路径逻辑努力）"></a>2. $g$​​（逻辑努力）和$G$​（路径逻辑努力）</h4><p><strong>定义</strong>：一个门在最坏情况下，与反相器提供<strong>相同的输出电流（即电阻相等或驱动能力相等）</strong>时，所表现的输入电容比反相器大多少倍。</p><p><strong>小贴士</strong>：</p><ul><li>反相器有最小的逻辑努力</li><li>随着门的复杂度增加，逻辑努力相应增加</li><li><strong>只和门的拓扑有关，与尺寸无关</strong></li></ul><p>逻辑努力$g$的计算：</p><table><thead><tr><th align="center">门类型</th><th align="center">1 input</th><th align="center">2 input</th><th align="center">3 input</th><th align="center">n input</th></tr></thead><tbody><tr><td align="center">反相器</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>NAND</strong></td><td align="center"></td><td align="center">4&#x2F;3</td><td align="center">5&#x2F;3</td><td align="center">（n+2）&#x2F;3</td></tr><tr><td align="center"><strong>NOR</strong></td><td align="center"></td><td align="center">5&#x2F;3</td><td align="center">7&#x2F;3</td><td align="center">（2n+1）&#x2F;3</td></tr><tr><td align="center">MUL</td><td align="center"></td><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">XOR</td><td align="center"></td><td align="center">4</td><td align="center">12</td><td align="center"></td></tr></tbody></table><p>例子：</p><p>对于<code>2-input NADN</code>，对于端口$A$​，可知$C&#x3D;C_{PA}+C_{NA}&#x3D;2+2&#x3D;4$​，故$g&#x3D;4&#x2F;3$​​；端口$B$​同理。</p><p>对于<code>2-input NOR</code>，对于端口$A$​​​，可知$C&#x3D;C_{PA}+C_{NA}&#x3D;4+1&#x3D;5$​​​，故$g&#x3D;5&#x2F;3$​​​；端口$B$​​​同理。</p><p>对于路径逻辑努力$G$<br>$$<br>G&#x3D;\prod_{1}^ng_i<br>$$<br>对于一条路径，该路径的逻辑努力等于路径上所有门的逻辑努力连乘。</p><h4 id="3-b-​​（分支努力）和-B-（路径分支努力）"><a href="#3-b-​​（分支努力）和-B-（路径分支努力）" class="headerlink" title="3. $b$​​（分支努力）和$B$（路径分支努力）"></a>3. $b$​​（分支努力）和$B$（路径分支努力）</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002211405433.png" alt="image-20211002211405433"></p><p>公式：<br>$$<br>b&#x3D;\frac{C_{on-path}+C_{off-path}}{C_{on-path}}<br>$$<br>注意：</p><ul><li>分支努力$b$​是针对与<strong>一个路径节点</strong>而言的</li><li>如果只有一条路径，没有分叉，<strong>则$b&#x3D;1$​</strong>；如果该节点两个分支的栅电容大小相等，则$b&#x3D;2$</li></ul><p>其中，</p><ul><li>$C_{on-path}$：沿着分析路径上的负载电筒</li><li>$C_{off-path}$：离开该路径连线上的电容</li></ul><p>$eg：$​假设，①反相器尺寸为2，②反相器尺寸为1，则$b&#x3D;\frac{2+1}{2}&#x3D;\frac{3}{2}$​</p><p>对于<strong>路径分支努力$B$​</strong>​<br>$$<br>B&#x3D;\prod_{1}^nb_i<br>$$<br>对于一条路径，该路径的分支努力等于路径上所有节点的分支努力连乘。</p><h4 id="4-f-（电气努力）和-F-​（路径电气努力）"><a href="#4-f-（电气努力）和-F-​（路径电气努力）" class="headerlink" title="4. $f$（电气努力）和$F$​（路径电气努力）"></a>4. $f$（电气努力）和$F$​（路径电气努力）</h4><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210915190315032.png" alt="image-20210915190315032"></p><p>$f$又称为<strong>等效扇出</strong>，表示<strong>第$j+1$级管子（$j+1$级输入电容）相对于第$j$级管子（$j$​级输入电容）的尺寸（电容值）。</strong></p><p>$$<br>f&#x3D;\frac{C_{ext}}{C_g}<br>$$<br><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002223922383.png" alt="image-20211002223922383"></p><p>注意：对于第1级反相器和第2级两个<code>3-input NAND</code>，$f&#x3D;\frac{2·C_{g-3-input-NAND}}{C_{g-inv}}$​（<code>3-input NAND</code>尺寸相等，才能直接$·2$）​​​</p><p>但是如果我们计算某一条路径，如上图所示分叉中某一路径，<strong>只针对路径上面的门电路计算电气努力</strong></p><p>可知，<br>$$<br>f’&#x3D;\frac{f}{b}<br>$$<br>也就是算路径电气努力的时候（见下文），为何是$\prod\frac{f}{b}$​</p><p>$F$​​​​​​为<strong>路径电气努力</strong>，又称为<strong>总等效的扇出</strong>，即最后一级的负载电容与第一级输入栅电容的关系。<br>$$<br>F&#x3D;C_{ext,N}&#x2F;C_{g,1}&#x3D;C_{g,N+1}&#x2F;C_{g,1}&#x3D;C_L&#x2F;C_{g,1}<br>$$<br>经过推导（略），可知$F$又可表示为<br>$$<br>F&#x3D;\prod_{1}^n\frac{f_i}{b_i}&#x3D;\frac{\prod_{1}^nf_i}{B}<br>$$<br>对于一条路径，该路径的电气努力等于路径上所有门的电气努力连乘然后除以路径分支努力。</p><h4 id="5-h-​（门努力）和-H-（路径门努力）"><a href="#5-h-​（门努力）和-H-（路径门努力）" class="headerlink" title="5. $h$​（门努力）和$H$（路径门努力）"></a>5. $h$​（门努力）和$H$（路径门努力）</h4><p>$$<br>h&#x3D;g·f<br>$$</p><p>其中，</p><ul><li><p>逻辑努力$g$​​，与拓扑（逻辑门类型，比如NAND、NOR等）有关，与具体尺寸无关。</p></li><li><p>电气努力$f$​，即等效扇出。$f&#x3D;C_{ext}&#x2F;C_g$​</p><p>注意，<strong>除以栅输入电容，而不是本征电容</strong></p></li></ul><p><strong>$H$​​路径门努力公式如下：</strong><br>$$<br>H&#x3D;\prod_{1}^nh_i&#x3D;\prod_{1}^ng_i·f_i&#x3D;GFB<br>$$<br>$PS$​：$H&#x3D;\prod_{1}^nh_i&#x3D;\prod_{1}^ng_i·f_i&#x3D;\prod_{1}^ng_i·\prod_{1}^nf_i&#x3D;G·\frac{\prod_{1}^nf_i}{B}·B&#x3D;GFB$​</p><h3 id="3-【重点】【优化】-确定电路尺寸"><a href="#3-【重点】【优化】-确定电路尺寸" class="headerlink" title="3.【重点】【优化】 确定电路尺寸"></a>3.【重点】【优化】 确定电路尺寸</h3><p>为了追求更好的性能，即最低的延时，我们希望可以调整尺寸，让组合逻辑的延时最小。</p><ul><li><p>计算路径的总努力：$H&#x3D;GFB$</p></li><li><p>确定路径上的门数：$N$</p></li><li><p>计算门努力：$h&#x3D;\sqrt[N]{H}$​</p><p><strong>注意</strong>：<font color=red><b>经过推导，当$h$​​​​满足上式时，路径延时最短</b></font></p></li><li><p>根据$h_i&#x3D;g_i·f_i$求出不同级门的尺寸$S_i$【尺寸系数$S$详见（3）4.3】<br>$$<br>S_{j+1}&#x3D;\frac{h_j·S_j}{b_j·g_{j+1}}<br>$$<br>推导如下：</p><p>※<strong>本征延时和路径中逻辑门的类型有关，和尺寸无关</strong>。具体推导看（3）4.3</p><p>一个单位尺寸的门具有和最小尺寸反相器相同的<strong>驱动能力</strong>，即可知该门的输入电容$C_{j-in}&#x3D;g_jC_{ref}$​​</p><p>若该门的尺寸系数为$S_j$​​​​，则该门的输入电容$C_{j-in}&#x3D;S_jg_jC_{ref}$​​​​</p><p>根据上文4.2.3 可知，<strong>路径上面</strong>，<br>$$<br>\frac{f_j}{b_j}&#x3D;\frac{C_{j+1-in}}{C_{j-in}}&#x3D;\frac{S_{j+1}g_{j+1}C_{ref}}{S_jg_jC_{ref}}<br>$$<br>于是，<br>$$<br>S_{j+1}&#x3D;\frac{f_j·g_j·S_j}{b_j·g_{j+1}}&#x3D;\frac{h_j·S_j}{b_j·g_{j+1}}<br>$$</p></li></ul><p>$eg：$​求出路径上各级门的尺寸系数$S$</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002223922383.png" alt="image-20211002223922383"></p><p>如上图电路图，可以将电路分成以下<strong>4级</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002223849712.png" alt="image-20211002223849712"></p><p><strong>步骤一：确定</strong>$G、B、F$</p><p>由图可知，$C_L&#x3D;5,C_{g1}&#x3D;1$，故$F&#x3D;C_L&#x2F;C_{g1}&#x3D;5$</p><p>接下来求解$G、B$</p><p>第1级：</p><p>第1级为一个反相器，即：$g_1&#x3D;1$​；</p><p>在输出节点，有两个分支，且两个分支尺寸相等，即：$b_1&#x3D;\frac{1+1}{1}&#x3D;2$</p><p>第2级：</p><p>第2级为两个尺寸相等的<code>3-input NAND</code>，即：$g_2&#x3D;5&#x2F;3$​；</p><p>在输出节点，有两个分支，且两个分支尺寸相等，即：$b_2&#x3D;\frac{1+1}{1}&#x3D;2$​</p><p>第3级：</p><p>第3级为两个尺寸相等的<code>2-input NOR</code>，即：$g_3&#x3D;5&#x2F;3$​​；</p><p>在输出节点，只有一条路径，即：$b_3&#x3D;1$​​</p><p>第4级：</p><p>第4级为一个反相器，即：$g_4&#x3D;1$​；</p><p>在输出节点，只有一条路径，即：$b_4&#x3D;1$</p><p>于是，有$G&#x3D;1·\frac{5}{3}·\frac{5}{3}·1&#x3D;\frac{25}{9}$；$B&#x3D;2·2·1·1&#x3D;4$</p><p>故$H&#x3D;G·B·F&#x3D;\frac{25}{9}·4·5&#x3D;55.69$</p><table><thead><tr><th align="center"></th><th align="center">第一级</th><th align="center">第二级</th><th align="center">第三级</th><th align="center">第四级</th><th align="center">总</th></tr></thead><tbody><tr><td align="center">$g$</td><td align="center">1</td><td align="center">5&#x2F;3</td><td align="center">5&#x2F;3</td><td align="center">1</td><td align="center">$G&#x3D;25&#x2F;9$</td></tr><tr><td align="center">$b$</td><td align="center">2</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">$B&#x3D;4$</td></tr></tbody></table><p><strong>步骤二：确定级数</strong>$N$</p><p>由图可知，$N&#x3D;4$</p><p><strong>步骤三：计算门努力</strong>$h$<br>$$<br>h&#x3D;\sqrt[N]{H}&#x3D;\sqrt[4]{55.56}&#x3D;2.73<br>$$<br><strong>步骤四：计算尺寸系数</strong>$S_i$</p><p>已知：$S_1&#x3D;1$</p><p>于是：</p><p>$S_2&#x3D;\frac{h_{1}S_{1}}{b_{1}g_{2}}&#x3D;\frac{2.73·1}{2·\frac{5}{3}}&#x3D;0.819$​</p><p>$S_3&#x3D;\frac{h_{2}S_{2}}{b_{2}g_{3}}&#x3D;\frac{2.73·0.819}{2·\frac{5}{3}}&#x3D;0.671$​​​</p><p>$S_4&#x3D;\frac{h_{3}S_{3}}{b_{3}g_{4}}&#x3D;\frac{2.73·0.671}{1·1}&#x3D;1.832$​​​</p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（4）CMOS组合逻辑门电路</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%884%EF%BC%89CMOS%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%884%EF%BC%89CMOS%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述静态互补CMOS电路基本概念和延时计算。</p><hr><span id="more"></span><h1 id="第六章-CMOS组合逻辑门电路"><a href="#第六章-CMOS组合逻辑门电路" class="headerlink" title="第六章 CMOS组合逻辑门电路"></a>第六章 CMOS组合逻辑门电路</h1><h2 id="1-CMOS电路的分类"><a href="#1-CMOS电路的分类" class="headerlink" title="1. CMOS电路的分类"></a>1. CMOS电路的分类</h2><ol><li><p><strong>静态互补CMOS电路</strong></p><p>即常见的CMOS电路——<strong>开关模型&#x3D;理想开关+有限电阻</strong></p><p>门输出通过一个低阻连接到$V_{DD}$和$GND$​，输出为该电路实现的布尔值（0或者1）</p><p>特点如下：</p><ul><li>高噪声容限（见（3）噪声门限）。</li><li>高输入阻抗，低输出阻抗</li><li>静态功耗可忽略（见（3）功耗）</li></ul></li><li><p><strong>动态CMOS集成电路</strong></p><p>信号暂时存储在高阻抗电路节点上面的<strong>电容</strong>上——$RC$大</p><p>特点如下：</p><ul><li>门电路简单、速度快</li><li>设计和制作工艺复杂</li><li>对噪声敏感</li></ul></li></ol><h2 id="2-静态互补CMOS设计"><a href="#2-静态互补CMOS设计" class="headerlink" title="2. 静态互补CMOS设计"></a>2. 静态互补CMOS设计</h2><h3 id="1-何为互补CMOS"><a href="#1-何为互补CMOS" class="headerlink" title="1. 何为互补CMOS"></a>1. 何为互补CMOS</h3><ul><li><p>互补CMOS由<strong>上拉网络（PUN）和下拉网络（PDN）</strong>组成，每个输入都分配到上拉和下拉网络</p><p>如下图，以<strong>与非门</strong>为例：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210924170555179.png" alt="image-20210924170555179"></p></li><li><p>上拉和下拉网络是<strong>相互排斥</strong>的——上下只能同时<strong>一个导通</strong></p></li><li><p>上拉：输出为1，$OUT$和$V_{DD}$之间存在通路</p><p>下拉：输出为0，$OUT$和$V_{SS}(GND)$之间存在通路</p></li><li><p>上拉：使用PMOS管，输出为<strong>强1</strong>，即$V_{out}&#x3D;V_{DD}$​​​；故<strong>一般使用PMOS管</strong>。</p><p>​使用NMOS管，输出为<strong>弱1</strong>，即$V_{out}&#x3D;V_{DD}-V_{THN}$</p><p>下拉：使用NMOS管，输出为<strong>强0</strong>，即$V_{out}&#x3D;GND$​；故<strong>一般使用NMOS管</strong></p><p>​使用PMOS管，输出为<strong>弱0</strong>，即$V_{out}&#x3D;|V_{THP}|$</p><p>其原因在于：MOS管导通需要满足$V_{GS}&gt;V_{TH}$​</p></li><li><p><strong>具有N输出的逻辑门所需的晶体管数为2N</strong></p></li></ul><h3 id="2-规则"><a href="#2-规则" class="headerlink" title="2. 规则"></a>2. 规则</h3><p>以NMOS管作为分析对象，</p><center><b><font color="red" size="6">串与，并或</font></b></center><p>即，<strong>NMOS管串联</strong>，实现<strong>与非</strong>功能；<strong>NMOS管并联</strong>，实现<strong>或非</strong>功能。</p><p>其关系如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210924165935360.png" alt="image-20210924165935360"></p><p>为何是<strong>非</strong>？</p><p>因为互补CMOS本身脱身于<strong>反相器</strong>，故自带非逻辑。</p><h3 id="3-设计复杂的逻辑门电路"><a href="#3-设计复杂的逻辑门电路" class="headerlink" title="3. 设计复杂的逻辑门电路"></a>3. 设计复杂的逻辑门电路</h3><h4 id="1-构成逻辑图的要素"><a href="#1-构成逻辑图的要素" class="headerlink" title="1. 构成逻辑图的要素"></a>1. 构成逻辑图的要素</h4><ul><li>网络节点：<strong>顶点</strong></li><li>弧线：<strong>源-漏</strong></li><li>弧线名：<strong>栅信号</strong></li></ul><h4 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h4><ol><li><p><strong>根据原理图画下拉网络</strong>——NMOS管构成</p><p>根据<font color="red"> <b>串与并或</b></font>的原则，画出下拉网络的逻辑图。</p></li><li><p><strong>根据下拉网络，画出上拉网络（PMOS管）</strong></p><ul><li>每个<strong>闭合路径</strong>放置<strong>节点</strong></li><li>设置节点：$OUT$、$V_{DD}$​​ 两个新节点</li><li>PMOS管新弧线穿过NMOS管弧线，把节点连接起来</li><li>给定新的PMOS弧线和NMOS管弧线<strong>相同的逻辑标记</strong></li></ul></li></ol><h2 id="3-【静态CMOS】分析逻辑门电路"><a href="#3-【静态CMOS】分析逻辑门电路" class="headerlink" title="3. 【静态CMOS】分析逻辑门电路"></a>3. 【静态CMOS】分析逻辑门电路</h2><p>CMOS管构成的电路分析，使用<strong>开关模型——理想开关+有限电阻+<em>电容</em></strong></p><p>以<strong>两输入与非门</strong>为例，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210924202818084.png" alt="image-20210924202818084"></p><center>两输入与非门开关模型</center><p><strong>注意</strong>：有节点的地方，一般都有电容。如上图两输入与非门所示，两个串联的NMOS管之间存在节点，于是存在一个电容$C_{int}$​；上拉和下拉网络之间存在节点，这个节点正好是输出结果的节点​，为$C_L$</p><h3 id="1-【输入模式】影响互补CMOS的传播延时-t-p"><a href="#1-【输入模式】影响互补CMOS的传播延时-t-p" class="headerlink" title="1. 【输入模式】影响互补CMOS的传播延时$t_p$"></a>1. 【输入模式】影响互补CMOS的传播延时$t_p$</h3><p>以两输入与非门为例，电路图如上图。</p><ul><li><p><strong>输出</strong>：低$\rightarrow$高</p><ol><li><p>**两个输入均→低 **： 即通过两个上拉电阻对电容充电，上拉网络中两个管子导通。此时两个$R_P$​并联<br>$$<br>t_p&#x3D;0.69· \frac{R_P}{2}·C_L<br>$$<br>其中，$\frac{R_P}{2}$为两$R_P$电阻并联之后的电阻阻值。​</p></li><li><p><strong>一个输入为高，一个输入→低</strong>：即只通过一个电阻对电容进行充电，上拉网络仅有一个管子导通，此时只有一个电阻$R_P$<br>$$<br>t_p&#x3D;0.69·R_P·C_L<br>$$</p></li></ol></li><li><p><strong>输出</strong>：高 $\rightarrow$ 低</p><ol><li><strong>两个输入均为高电平（或低→高）</strong>：即通过两个下拉电阻对电容放电，下拉网络中的两个管子均导通。此时两个$R_N$串联<br>$$<br>t_p&#x3D;0.69·2R_N·CL<br>$$<br>其中，$2R_N$为两个$R_N$电阻串联之后的电阻阻值</li></ol></li><li><p>此处给出一组表格。采用$NMOS&#x3D;0.5\mu&#x2F;0.25\mu;PMOS&#x3D;0.75\mu&#x2F;0.25\mu;C_L&#x3D;100fF$</p></li></ul><table><thead><tr><th align="center">输入方式</th><th align="center">延迟（$ps$）</th></tr></thead><tbody><tr><td align="center">$A、B&#x3D;0\rightarrow 1$​</td><td align="center">62</td></tr><tr><td align="center">$A&#x3D;1；B&#x3D;0 \rightarrow 1$</td><td align="center">50</td></tr><tr><td align="center">$A&#x3D;0 \rightarrow 1；B&#x3D;1$</td><td align="center">69</td></tr><tr><td align="center">$A&#x3D;B&#x3D;1 \rightarrow 0$</td><td align="center">35</td></tr><tr><td align="center">$A&#x3D;1；B&#x3D;1 \rightarrow 0$</td><td align="center">57</td></tr><tr><td align="center">$A&#x3D;1 \rightarrow 0；B&#x3D;1$</td><td align="center">76</td></tr></tbody></table><p>很明显，<strong>传播延时取决于输入模式</strong></p><h3 id="2-【重点】如何确定晶体管尺寸"><a href="#2-【重点】如何确定晶体管尺寸" class="headerlink" title="2. 【重点】如何确定晶体管尺寸"></a>2. 【重点】如何确定晶体管尺寸</h3><p>目的：使得做出来的逻辑门电路<strong>性能</strong>最好（$t_p$最小）</p><p>指标：该逻辑门<strong>最坏情况</strong>下，与反相器提供相同的输出电流，即$R_{PUN-max}&#x3D;R_{PDN-max}$​​​。</p><p>​即$t_{pHL}&#x3D;t_{pLH}$。</p><p>​相当于构建一个<strong>对称反相器</strong></p><p>例子：</p><ul><li><p><strong>电阻大小和管子的$W$​​​成反比</strong></p></li><li><p>由于迁移率$\mu$​​的不同，此处我们认为，$W_P&#x3D;2,W_N&#x3D;1$​时，<strong>管子有着相同的电阻</strong>。</p><p>这个系数$\frac{W_P}{W_N}&#x3D;2$​并不一定，根据工艺进行调整。</p><p>下面是版图上面的体现：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925110036727.png" alt="image-20210925110036727"></p><p>按照<strong>系数为2</strong>进行计算，即有<br>$$<br>W_P&#x3D;2 \rightarrow R_P&#x3D;1\<br>W_N&#x3D;1 \rightarrow R_N&#x3D;1\<br>$$<br>原因：PMOS管和NMOS管的$\mu$不同</p><p>注意：不同工艺的系数不同，此处的系数相当于是构建了一个对称反相器</p><p>以两输入与非门和两输入或非门为例：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925135413503.png" alt="image-20210925135413503"></p></li></ul><ol><li><p>双输入与非门：</p><p><strong>PUN</strong>：当只有一个管子导通的时候，取到最大电阻，$R_{PUN-max}&#x3D;R_P$</p><p><strong>PDN</strong>：当两个管子同时导通的时候，取到最大电阻，$R_{PDN-max}&#x3D;2R_N$</p><p>即$R_P&#x3D;2R_N$​</p><p>假设$R_P&#x3D;1$​​，则$W_P&#x3D;2$；此时$R_N&#x3D;1&#x2F;2$，则$W_N&#x3D;2·1&#x3D;2$</p><p>结果如上图。</p></li><li><p>双输入或非门：</p><p><strong>PUN</strong>：当两个管子同时导通的时候，取到最大电阻，$R_{PUN-max}&#x3D;2R_P$​</p><p><strong>PDN</strong>：当只有一个管子导通的时候，取到最大电阻，$R_{PDN-max}&#x3D;R_N$​</p><p>即$2R_P&#x3D;R_N$​​</p><p>假设$R_N&#x3D;1$​​​​​​，则$W_N&#x3D;1$​​​​；此时$R_P&#x3D;1&#x2F;2$​​​​，则$W_P&#x3D;2·2&#x3D;4$​​​​</p><p>结果如上图。</p></li><li><p>【<strong>重点</strong>】复合门的例子</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925142702981.png" alt="image-20210925142702981"></p><p><strong>PUN</strong>：$B、C、D$​​​管子 或 $A、D$​管子导通时，取到最大电阻，$R_{PUN-max}&#x3D;3R_{P-bcd}$​或者$R_{PUN-max}&#x3D;2R_{P-ad}$​​​</p><p><strong>PDN</strong>：$A、C$​ 或 $A、B$​导通 或 只有$D$​管子导通时，取到最大电阻，$R_{PDN-max}&#x3D;2R_{N-ac、ab}$​或者$R_{PDN-max}&#x3D;R_{N-d}$​</p><p>即$2R_{P-bc}+R_{P-d}&#x3D;R_{P-a}+R_{P-d}&#x3D;R_{N-d}&#x3D;R_{N-a}+R_{N-bc}$​​</p><p>假设$R_{N-d}&#x3D;1$​​，则$W_{N-d}&#x3D;1$​​；</p><p>若令$R_{N-a}&#x3D;R_{N-bc}&#x3D;R_{N-abc}$，即$2R_{N-abc}&#x3D;R_{N-d}$，因此$R_{N-abc}&#x3D;1&#x2F;2$，$W_{N-abc}&#x3D;2·1&#x3D;2$</p><p>若令$R_{P-bc}&#x3D;R_{P-d}&#x3D;R_{P-bcd}$，即$3R_{P-bcd}&#x3D;R_{N-d}$，因此$R_{P-bcd}&#x3D;1&#x2F;3$，$W_{P-bcd}&#x3D;3·2&#x3D;6$</p><p>又因为$2R_{P-bc}&#x3D;R_{P-a}$，即$\frac{3}{2}R_{P-a}&#x3D;R_{N-d}$，因此$R_{P-a}&#x3D;2&#x2F;3$，$W_{P-a}&#x3D;\frac{3}{2}·2&#x3D;3$</p><p>结果如上图。</p><p>或采用<strong>另外一种方法——更加方便快捷</strong></p><p><strong>PUN</strong>：$B、C、D$​​​管子 或 $A、D$​管子导通时，取到最大电阻。​</p><p>​取<strong>串联最多</strong>的，即$3R_{P-bcd}$为计算基准</p><p><strong>PDN</strong>：$A、C$​ 或 $A、B$​导通 或 只有$D$​管子导通时，取到最大电阻</p><p>​取<strong>串联最多</strong>的，即$2R_{N-ac、ab}$​为计算基准</p><p>对于<strong>PUN</strong>，因为最多是<b><font color="red">3个电阻串联——3</font><strong>（BCD），且</strong><font color="red">为PMOS管——2</font></b>，故$W_{P-bcd}&#x3D;3·2&#x3D;6$​​</p><p>​根据$A$​和<b><font color="red">2个电阻并联——2</font></b>（BC），故$W_{P-a}&#x3D;\frac{6}{2}&#x3D;3$​</p><p>对于<strong>PDN</strong>，因为最多是<b><font color="red">2个电阻串联——2</font></b>（AB或AC），且<b><font color="red">为NMOS管——1</font></b>，故$W_{N-abc}&#x3D;2·1&#x3D;2$</p><p>​根据$D$​​​​和<b><font color="red">2个电阻并联——2</font></b>（AB或AC），故$W_{N-d}&#x3D;\frac{2}{2}&#x3D;1$​​​​</p></li></ol><h3 id="3-Elmore延时模型"><a href="#3-Elmore延时模型" class="headerlink" title="3. Elmore延时模型"></a>3. <code>Elmore</code>延时模型</h3><p> 【用途】：用于大概估算具有<strong>众多电容、电阻电路</strong>的延时，适用于<strong>【RC树】</strong></p><p>最基本的公式：<br>$$<br>t_p&#x3D;0.69RC&#x3D;0.69\tau<br>$$<br>何为【RC树】？</p><ul><li><p>电路仅有<strong>一个输入节点</strong></p></li><li><p>电容均在<strong>节点和地</strong>之间</p></li><li><p>电路不包含任何<strong>电阻环路</strong></p></li><li><p>两概念：路径电阻、共享路径电阻</p><ol><li>路径电阻：输入节点到所求节点之间的<strong>唯一电阻通路</strong>上的电阻</li><li>共享路径电阻：输入节点到$i、A$两个节点之间<strong>共享的【路径电阻】上</strong>的电阻</li></ol><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925161257847.png" alt="image-20210925161257847"></p></li></ul><p>**$i$​​节点的路径电阻$R_{ii}$**​​：$R_1、R_3、R_i$​​；</p><p>1节点的路径电阻$R_{11}$：$R_1$</p><p>…</p><p>节点$i$​、1的共享路径电阻$R_{i1}$：$R_1$​</p><p>节点$i$​、2的共享路径电阻$R_{i2}$​：$R_1$​</p><p>节点$i$​、3的共享路径电阻$R_{i3}$​：$R_1、R_3$​</p><p>节点$i$​、4的共享路径电阻$R_{i4}$​：$R_1、R_3$​</p><p><strong>节点$i、i$​的共享路径电阻$R_{ii}$​</strong>：$R_1、R_3、R_i$​；</p><p>…</p><p>可以看到，<strong>路径电阻可以认为是一种特殊的共享电阻</strong>。</p><p>于是有计算公式如下：<br>$$<br>\tau_{D i}&#x3D;\sum_{k&#x3D;1}^{i} C_{k} R_{i k}<br>$$<br>注意：计算延时的时候，电容$C_k$为RC树中的所有电容。也就是<strong>该RC树的延时和所有电容有关</strong></p><p>以上文图中的RC树为例子<br>$$<br>\tau&#x3D;R_1C_1+R_1C_2+(R_1+R_3)C_3+(R_1+R_3)C_4+(R_1+R_3+R_i)C_i<br>$$<br>于是<br>$$<br>t_p&#x3D;0.69·[R_1(C_1+C_2)+(R_1+R_3)(C_3+C_4)+(R_1+R_3+R_i)C_i]<br>$$</p><h3 id="4-【Elmore延时】计算复合门延时——【多扇入】"><a href="#4-【Elmore延时】计算复合门延时——【多扇入】" class="headerlink" title="4. 【Elmore延时】计算复合门延时——【多扇入】"></a>4. 【<code>Elmore</code>延时】计算复合门延时——【多扇入】</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925170854676.png" alt="image-20210925170854676"></p><center>四输入与非门</center><p>考虑延时的时候，常常考虑<strong>最坏的情况</strong>——所有的电容都充电或者所有电容都放电。</p><p>如果原本$ABCD&#x3D;1110$，则此时所有电容均充电到$V_{DD}$</p><p>在零时刻，$ABCD&#x3D;1111$​​，此时所有的电容进行放电。</p><p>此时$S&#x3D;⑥，i&#x3D;②、③、④、⑤$</p><p>即：</p><p>$⑤$​​​​​​​​​​​节点$C_1$​​​​​​​​​​​通过$R_{ND}$​​​​​​​​​​​​放电（$1R$​），</p><p>$④$​​​​​​​​​​​节点$C_2$​​​​​​​​​​​通过$R_{ND}+R_{NC}$​​​​​​​​​​​放电（$2R$），</p><p>$③$​​​​​​​​​​​​节点$C_3$​​​​​​​​​​​​通过$R_{ND}+R_{NC}+R_{NB}$​​​​​​​​​​​​放电（$3R$），</p><p>$②$​​​​​​​​​​​​​节点$C_L$​​​​​​​​​​​​​通过$R_{ND}+R_{NC}+R_{NB}+R_{NA}$​​​​​​​​​​​​​​放电（$4R$）</p><p>若NMOS管的电阻均相等，为$R_{eqn}$</p><p>于是，<br>$$<br>{t}_{pHL}&#x3D;0.69 {R}_{eqn}\ ({C}_{1}+2 C_{2}+3 C_{3}+4 C_{\mathrm{L}})<br>$$<br><strong>分析【多扇入】：</strong></p><ul><li>晶体管串联导致电阻增大，传播延时随着<strong>扇入数的</strong>增大而增大</li><li>一个门的无负载本征延时最坏情况下，延时约为扇入数的<strong>二次函数</strong></li><li>实际应用中，<strong>一般扇入数不超过4</strong></li></ul><h3 id="5-降低【多扇入】的电路的延时"><a href="#5-降低【多扇入】的电路的延时" class="headerlink" title="5. 降低【多扇入】的电路的延时"></a>5. 降低【多扇入】的电路的延时</h3><ol><li><p>调整管子尺寸</p><p>​——逐级加大晶体管尺寸，即在Elmore分析中出现<strong>最多次的管子的电阻</strong>应该减小（$W$增大）</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210925191633262.png" alt="image-20210925191633262"></p><p>尺寸：$M_1&gt;M_2&gt;M_3&gt;…&gt;M_N$​</p><p><strong>缺点：</strong>画版图困难</p></li><li><p>重新安排输入</p><p>​——关键路径上的晶体管应该<strong>靠近输出端</strong>。</p><p><strong>关键信号</strong>：一个门的输出信号中，在所有输入中最后到达稳定的信号。</p><p><strong>关键路径</strong>：决定一个结构最终速度的逻辑路径称为关键路径。</p><p>原理：越靠近输出端，信号需要经过的管子少，$RC$​​延时短。</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211128003928853.png" alt="image-20211128003928853" style="zoom: 67%;" /><p>最坏情况，<strong>全部的电容放电</strong>——即下拉网络对地有通路。关键信号应为$0→1$，其他信号为$1$</p><p>如左图，关键输入信号远离输出端，则$In_1&#x3D;0→1$时，$C_1、C_2、C_L$放电，延时最大。</p><p>如右图，关键输入信号靠近输出端，当$In_1$还等于$0$时，其他电容已经放电完毕。当$In_1&#x3D;0→1$时，只有$C_L$放电，延时小。</p></li><li><p>重构逻辑结构</p><p>​——多扇入逻辑电路拆解成若干个较低扇入的逻辑电路。</p><p>前面<code>Elmore</code>延时模型已经知道，延时和扇入数接近平方关系增长。</p><p>于是降低扇入数，可以降低电路的整体延时。</p></li><li><p>加入<code>buffer</code>隔开大扇入和大扇出</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20211002162122634.png" alt="image-20211002162122634"></p><ul><li><code>buffer</code>的$C_G$​比较小，一定程度上削弱了大扇入的延时；</li><li>根据$C_L$的大小，按照$f&#x3D;\sqrt[N]{F}$​​比例​设置反相器的尺寸，可以降低大扇出带来的大延时。</li></ul></li></ol><h3 id="6-延时和【扇出】"><a href="#6-延时和【扇出】" class="headerlink" title="6. 延时和【扇出】"></a>6. 延时和【扇出】</h3><p>公式：<br>$$<br>t_p&#x3D;t_{p0}·(1+ \frac{C_{ext}}{C_{int}})&#x3D;t_{p0}·(1+ \frac{f}{\gamma})<br>$$<br>一般，进行归一化后取$\gamma&#x3D;1$，即有<br>$$<br>t_p&#x3D;t_{p0}·(1+ f)<br>$$<br>呈现<strong>线性关系</strong>。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>关于逻辑门的延时，给出如下的公式进行描述<br>$$<br>t_p&#x3D;a_1F_I+a_2F_I^2+a_3F_O<br>$$<br>$F_I$​表示总的等效扇入，$F_O$表示总的等效扇出。</p><p>可见，<strong>延时与扇入成平方关系，同扇出成线性关系。</strong></p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（3）反相器</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%883%EF%BC%89%E5%8F%8D%E7%9B%B8%E5%99%A8/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%883%EF%BC%89%E5%8F%8D%E7%9B%B8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述如何根据延时和功耗设计反相器（INV）。</p><hr><span id="more"></span><h1 id="第五章-反相器"><a href="#第五章-反相器" class="headerlink" title="第五章 反相器"></a>第五章 反相器</h1><h2 id="1-设计指标"><a href="#1-设计指标" class="headerlink" title="1. 设计指标"></a>1. 设计指标</h2><p>明确：<strong>反相器是数字电路设计的核心</strong>。</p><ol><li><p>成本：</p><p>主要是指标就是<strong>面积</strong>。在数集中，最小尺寸是$L&#x3D;2\lambda$，于是【$W$】就成了设计的要点。</p><p>$Eg：$</p><p>以反相器（$INV$​）为例，不同的$W$​的INV应用于不同的场合。如：“CLKINV”和”INVD”。CLKINV应用于时间通路上，对延迟要求较高，希望可以做到$t_p≈t_{pLH}≈t_{pHL}$，且尽可能小（或者达到指标）。而对于INVD，并不要求$t_p≈t_{pLH}≈t_{pHL}$，仅需要$t_p&#x3D;\frac{t_{pLH}+t_{pHL}}{2}$的数值满足要求即可，即如果$t_{pLH}、t_{pHL}$​其中一个较小，一个较大，但是平均值满足要求也是可以的。</p></li><li><p>完整性和稳定性：</p><p>主要考虑<strong>静态特性</strong></p><p>在INV等门电路的设计中，常采用<strong>互补CMOS</strong>的结构。互补CMOS结构可以让输出的电压上拉到$VDD$或者下拉到$GND$，提高稳定性。</p></li><li><p>性能：</p><p>主要考虑<strong>动态特性</strong></p><p>也就是【$t_p$】数值大小。</p></li><li><p>功耗：</p><p>使用”关断“等技术</p></li></ol><h2 id="2-INV综述"><a href="#2-INV综述" class="headerlink" title="2. INV综述"></a>2. INV综述</h2><h3 id="1-INV的数集模型"><a href="#1-INV的数集模型" class="headerlink" title="1. INV的数集模型"></a>1. INV的数集模型</h3><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210908173438566.png" alt="image-20210908173438566"></p><p>由组成的图可以知道，INV是由两个CMOS管串联组成的。而<strong>CMOS的数集模型是理想开关+有限导通电阻or无限关断电阻</strong>，故INV的数集模型如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210908174017914.png" alt="image-20210908174017914"></p><center><b><font color=red >INV的开关模型</font></b></center><p>即<strong>两个电阻开关并联</strong>。</p><p>图中的$C_L$表示<strong>晶体管的漏极电容、连线电容、扇出门的输入电容</strong></p><h3 id="2-INV的特性综述"><a href="#2-INV的特性综述" class="headerlink" title="2. INV的特性综述"></a>2. INV的特性综述</h3><h4 id="1-动态特性："><a href="#1-动态特性：" class="headerlink" title="1. 动态特性："></a>1. 动态特性：</h4><p>主要由$C_L$决定，$C_L$表示<strong>晶体管的漏极电容、连线电容、扇出门的输入电容</strong></p><h4 id="2-静态特性："><a href="#2-静态特性：" class="headerlink" title="2. 静态特性："></a>2. 静态特性：</h4><ol><li><p>噪声容量大：</p><p>电压摆幅&#x3D;电源电压。因为是CMOS互补结构。</p></li><li><p><strong>无比逻辑</strong>:</p><p>逻辑电平和器件的尺寸无关。故而可以采用最小的尺寸：$L&#x3D;2\lambda$</p></li><li><p><strong>稳态下有限的（低）的输出电阻</strong></p><p>稳态输出时，输出和VDD或GND之间用于存在一条<strong>有限电阻的通路</strong>，使他对<strong>噪声不敏感</strong></p></li><li><p><strong>高的输入电阻</strong></p><ul><li>输入是从栅极输入，栅极电流几乎为零，故而电阻极高</li><li>因为极低的栅极电流，故而理论上，一个INV可以驱动多穷多个INV。但是由于<strong>栅极寄生电容</strong>的原因，过多的扇出会使得输出电容$C_L$过大，<strong>使得$t_p$过高，动态特性变差</strong>。</li></ul></li><li><p>稳态的下，无$I_D$电流——<strong>无功耗</strong></p><p>稳态条件下，互补CMOS中始终有一个”开关“打开，故而没有电流的存在，意味着没有静态功耗</p></li></ol><h4 id="3-VTC（电压传输特性）"><a href="#3-VTC（电压传输特性）" class="headerlink" title="3. VTC（电压传输特性）"></a>3. VTC（电压传输特性）</h4><ol><li><strong>所有的工作点不是输出高电平就是输出低电平</strong>，如下图：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210908192819600.png" alt="image-20210908192819600"></p><center>静态CMOS反向中PMOS和NMOS的负载曲线，<b><font color=red>原点表示直流工作点</font></b></center><ol start="2"><li><p><strong>过渡区的电平范围很窄</strong>，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210909212850990.png" alt="image-20210908193244083"></p></li></ol><h2 id="3-INV的静态特性"><a href="#3-INV的静态特性" class="headerlink" title="3. INV的静态特性"></a>3. INV的静态特性</h2><h3 id="1-开关阈值（-V-M-）"><a href="#1-开关阈值（-V-M-）" class="headerlink" title="1. 开关阈值（$V_M$）"></a>1. 开关阈值（$V_M$）</h3><ul><li><p>定义：**$V_M$被定义为$V_{in}&#x3D;V_{out}$的点。<strong>对于INV而言，此时</strong>$V_{GS}&#x3D;V_{DS}$**</p></li><li><p>结论：</p></li></ul><p>$$<br>V_M≈\frac{rV_{DD}}{1+r}<br>$$</p><p>其中，<strong>r为PMOS与NMOS相对驱动强度之比</strong></p><ul><li>希望值：</li></ul><p>$$<br>V_M&#x3D;\frac{V_{DD}}{2}<br>$$</p><p>因为这样可以使得<strong>低电平噪声门限和高电平噪声门限的值相近</strong>，于是得到【<strong>r应该尽可能等于1</strong>】</p><p>经过推导，可以把$V_M&#x3D;\frac{V_{DD}}{2}$映射为<strong>PMOS管和NMOS管的W之比</strong>，如下：<br>$$<br>\frac{(W&#x2F;L)_p}{(W&#x2F;L)_n}&#x3D;\frac{W_p}{W_n}(数集中L相等)&#x3D;…<br>$$<br>以下结论：</p><ol><li>$V_M$对于器件$\frac{W_p}{W_n}$尺寸的变化不敏感。意味着工艺上的偏差，并不会使$V_M$偏差希望值很多。</li><li>增加$W_p$会使得$V_M$移向$V_{DD}$，增加$W_n$会使得$V_M$移向$GND$</li></ol><h3 id="2-噪声门限"><a href="#2-噪声门限" class="headerlink" title="2. 噪声门限"></a>2. 噪声门限</h3><p>注：数集中，噪声容限都很大，接近$\frac{V_{DD}}{2}$，故而过度讨论他并没有太大的用处，此处仅作了解。</p><p>定义$V_{IH}$和$V_{IL}$分别是VTC中<strong>增益&#x3D;-1</strong>的点。</p><p>定义<strong>噪声门限</strong>为：<br>$$<br>NM_H&#x3D;V_{DD}-V_{IH} \ NM_L&#x3D;V_{IL}-0<br>$$<br>实际实验中，$NM_H$和$NM_L$并不完全相等，但是基本都可以到达1V左右，属于很大的噪声门限了。</p><h3 id="3-稳定性"><a href="#3-稳定性" class="headerlink" title="3. 稳定性"></a>3. 稳定性</h3><ol><li><p>器件参数变化对器件稳定性的影响：</p><p><strong>仿真测试：PVT（process voltage temperature）</strong>：常常在设计中，采用三者组合仿真。</p><ul><li>工艺角（process corner）分析，常见的五种：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs verilog">fast <span class="hljs-keyword">nmos</span> <span class="hljs-keyword">and</span> fast <span class="hljs-keyword">pmos</span> （ff）<br>slow <span class="hljs-keyword">nmos</span> <span class="hljs-keyword">and</span> slow <span class="hljs-keyword">pmos</span> （ss）<br>slow <span class="hljs-keyword">nmos</span> <span class="hljs-keyword">and</span> fast <span class="hljs-keyword">pmos</span> （sf）<br>fast <span class="hljs-keyword">nmos</span> <span class="hljs-keyword">and</span> slow <span class="hljs-keyword">pmos</span> （fs）<br>typical <span class="hljs-keyword">nmos</span> <span class="hljs-keyword">and</span> typical <span class="hljs-keyword">pmos</span> （tt）<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">t,代表typical (平均值)<br>s,代表slow（电流小）<br>f,代表fast（电流大）<br></code></pre></td></tr></table></figure><ul><li>电压（voltage）分析，常见的三种：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v</span>+<span class="hljs-number">10</span>% ,v ,v-<span class="hljs-number">10</span>%<br></code></pre></td></tr></table></figure><ul><li>温度（temperature）分析，常见的四种</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-40℃, 0℃,25℃, 125℃</span><br></code></pre></td></tr></table></figure><p>在进行不同的组合，仿真最好最坏的等多种情况。</p></li><li><p>器件电源电压降低对器件稳定的影响</p><p><strong>不可使用过低的电压</strong></p><ol><li>低电压可以减小功耗（$P&#x3D;C·V_{DD}^2$），但是会增加门延时。</li><li>电源电压减低使得dc特性（开关阈值）对器件的尺寸越来越敏感。</li><li>$V_{DD}$减小，信号摆幅减小，有利于减小系统内部噪声。</li></ol></li></ol><h2 id="4-【重点】INV的动态特性——-t-p-（计算-R-eq-和-C-L-）"><a href="#4-【重点】INV的动态特性——-t-p-（计算-R-eq-和-C-L-）" class="headerlink" title="4. 【重点】INV的动态特性——$t_p$（计算$R_{eq}$和$C_L$）"></a>4. 【重点】INV的动态特性——$t_p$（计算$R_{eq}$和$C_L$）</h2><h3 id="1-设计角度"><a href="#1-设计角度" class="headerlink" title="1. 设计角度"></a>1. 设计角度</h3><ol><li><p>最小的传播延时</p><p>这是厂家最希望的</p></li><li><p>满足性能的同时，做到面积最小</p><p>面积最小，意味着成本最低。这里的面积取决于$W$，也就是选择合适的$W$</p></li><li><p>根据扇出设计反相器链的级数</p><p>对于时钟树、复位树等需要多扇出的、且要求$t_p$小的，如何设计一个<strong>合理的高扇出的反相器链</strong></p></li><li><p>输入信号的上升下降时间对传播延时的影响</p></li></ol><h3 id="2-计算-C-L"><a href="#2-计算-C-L" class="headerlink" title="2. 计算$C_L$"></a>2. 计算$C_L$</h3><p>$$<br>C_L&#x3D;晶体管的漏极电容+连线电容+扇出门的输入电容<br>$$</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210908193244083.png" alt="image-20210908193244083"></p><ul><li><p>晶体管的漏极电容：$C_{db2}+C_{db1}+C_{gd12}$</p><p>即：两个管子的漏极电容，即管子1和2的结构电容总和$C_{gd12}$，管子1的结电容$C_{db1}$，管子2的结电容$C_{db2}$</p><p>其中，</p><ol><li>结构（覆盖）电容是固定的（有时候会使用<strong>密勒效应</strong>）：$C_{gd12}&#x3D;2C_{gdo}&#x3D;2C_oW$</li><li>PN结电容：$C_{db}&#x3D;C_{diff}&#x3D;C_{bottom}+C_{sw}$；或者使用线性化的值：$C_{eq}&#x3D;K_{eq}C_{j0}$（推导见P55）</li></ol></li><li><p>连线电容</p><p>与连线的长度、宽度，扇出门离驱动门的距离、扇出门的数量有关。</p></li><li><p>扇出的栅电容：$C_{g3}+C_{g4}$</p><p>即：两个扇出CMOS管的栅极电容。</p><p>而栅极电容具体看前文，1个CMOS管的栅极电容&#x3D;2个结构电容+3个沟道电容</p></li></ul><h3 id="3-等效电阻-R-eq"><a href="#3-等效电阻-R-eq" class="headerlink" title="3. 等效电阻$R_{eq}$"></a>3. 等效电阻$R_{eq}$</h3><p>$$<br>R_{eq}&#x3D;\frac{1}{V_{DD}&#x2F;2}\int_{V_{DD}&#x2F;2}^{V_{DD}}\frac{V}{I_{DSAT(1+\lambda V)}}dV≈\frac{3}{4}\frac{V_{DD}}{I_{DSAT}}(1+\frac{7}{9}\lambda V_{DD})<br>$$</p><p>具体推导见书本P70</p><h3 id="4-【※重要】计算延时-t-p-——计算、优化"><a href="#4-【※重要】计算延时-t-p-——计算、优化" class="headerlink" title="4. 【※重要】计算延时$t_p$——计算、优化"></a>4. 【※重要】计算延时$t_p$——计算、优化</h3><p>$$<br>t_{pHL}&#x3D;0.69R_{on}C_L\<br>$$</p><p>使用等效$R_{eq}$，则<br>$$<br>t_{pHL}&#x3D;0.69R_{eqn}C_L\<br>同理，t_{pLH}&#x3D;0.69R_{eqp}C_L<br>$$<br>上面两个值不一定相等！！</p><p>故，<br>$$<br>t_p&#x3D;\frac{0.69(R_{eqn}+R_{eqp})C_L}{2}<br>$$<br>又经过一波推导，得出<br>$$<br>t_{pHL&#x2F;LH}\varpropto \frac{C_L}{(W&#x2F;L)V_{DSAT}}<br>$$<br>故【<strong>减小延时的方法</strong>】</p><ol><li>减小$C_L$</li><li>增加$(W&#x2F;L)$。增加$W$也会使得$C_L$增加，故有一个增加的范围。</li><li>提高$V_{DD}$。会增加能耗，而且增加到一定程度之后优化的效果有限。</li></ol><h2 id="5-根据【延时】设计电路"><a href="#5-根据【延时】设计电路" class="headerlink" title="5. 根据【延时】设计电路"></a>5. 根据【延时】设计电路</h2><h3 id="1-对称反相器"><a href="#1-对称反相器" class="headerlink" title="1. 对称反相器"></a>1. 对称反相器</h3><ol><li><p><strong>如何得到对称反相器——调整宽长比</strong></p><p>对称反相器常常用于<strong>时钟网络（CLKINV）</strong>中，其有以下几个特点：</p><ol><li>充电电流和放电电流相等</li><li>上升延时时间$t_{pLH}$​和下降延时$t_{pHL}$​大致相等</li><li>晶体管电阻$R_P&#x3D;R_N$</li></ol><p>在.25工艺中，要得到<strong>对称反相器</strong>，一般要求：<br>$$<br>\frac{W_P}{W_N}&#x3D;2\sim 3.5<br>$$</p><p>可以认为，设计一个对称反相器，其<strong>目标</strong>是使得上下两个MOS管匹配。然而，这并不意味着反相器有着最短的延时（<strong>性能不是最佳</strong>）</p><p>※ 其<strong>原因</strong>是较宽的$W_P$​可以改善反相器的$t_{pLH}$​（$W_P\uparrow ,R_P \downarrow ,t_{pLH} \downarrow $​），但是会导致$t_{pHL}$​增大（$W_P\uparrow ,C_L \uparrow ,t_{pHL} \uparrow $​​​​）。如下图所示：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210912145608966.png" alt="image-20210912145608966"></p>   <center>CMOS反相器延时和<b>宽长比之比β</b>的关系</center><p>   根据上图，我们可以知道，在$\beta&#x3D;2.4$​时，得到对称反相器；而当$\beta&#x3D;1.9$​​​时​，得到传播延时的最小值——性能最佳的INV。</p><ol start="2"><li><p><strong>如何根据【性能—负载】选择对称反相器的尺寸</strong></p><p>计算延时的时候，我们利用公式：<br>$$<br>t_{p}&#x3D;0.69R_{eq}C_L\<br>$$<br>其中，令<br>$$<br>C_L&#x3D;C_{int}+C_{ext}<br>$$<br>$C_{int}$​表示反相器的本征输出电容，常常为（驱动管）$N$​管和$P$​管的漏电容。</p><p>$C_{ext}$：表示下一级反相器的输入电容，常常为（负载管）栅电容（忽略导线电容）。</p><p><strong>引入参数$S$​​：尺寸系数</strong>，即该反相器的晶体管和最小晶体管尺寸之比。</p><p><strong>如果P管和N管的$W$同时增大$S$倍，</strong></p><ul><li><strong>本征电容$C_{int}$​增大$S$​​倍</strong></li><li><strong>等效电阻$R_{eq}$减小$S$倍</strong></li></ul><p>经过推导（看书），有以下结论：<br>$$<br>t_p&#x3D;t_{p0}·(1+ \frac{C_{ext}}{C_{int}})&#x3D;t_{p0}·(1+ \frac{C_{ext}}{SC_{int-ref}})<br>$$<br>$C_{int-ref}$​​​​​​：<strong>最小尺寸的INV的本征输出电容</strong>，因为对于有一个反向器而言，本身的漏极电容是确定的，故称为本征输出电容。</p><p>$C_{int}$​​​​：（驱动管）$N$​​​​管和$P$​​​​管的漏电容。</p><p>$C_{ext}$​​​​​​​：（负载管）栅电容（忽略导线电容）。​</p><p>$t_{p0}$​：本征延时——尺寸变化$S$​倍，则$R \rightarrow R&#x2F;S,C \rightarrow SC$​，如果令$t_{p0}&#x3D;0.69RC$​，则 $t_p&#x3D;0.69·R&#x2F;S·SC&#x3D;t_{p0}$​</p><ul><li><p>反相器的本征延时和门尺寸无关，但是外界负载电容会导致影响反相器的传播延时</p></li><li><p>适当增加$S$可以减弱外界负载的影响。$S\rightarrow \infty ，\frac{C_{ext}}{SC_{int-ref}} \rightarrow 0$，此时$t_p&#x3D;t_{p0}$</p><p><font color=red><b>一般而言，S&#x3D;5已经可以改善外界负载带来的延时，S&gt;10之后收益很小</b></font>。$S$增加过多之后，会导致<strong>面积</strong>变得非常大，然而电容减低不多。</p><p>$eg$​：</p><p>假如某反相器的本征输出电容值$C_{int-ref}&#x3D;1$​，外部电容$C_{ext}&#x3D;100$​，而因为本征延时$t_{p0}$​与尺寸无关。故而如果把尺寸增加5倍，即$S&#x3D;5$​，就可以把延时从$101t_{p0}$​降为$21t_{p0}$​，相当于延时降低了5倍。​​​</p></li></ul></li></ol><h3 id="2-性能最好（-t-p-min-）的反相器"><a href="#2-性能最好（-t-p-min-）的反相器" class="headerlink" title="2. 性能最好（$t_{p-min}$）的反相器"></a>2. 性能最好（$t_{p-min}$）的反相器</h3><p>上面可以知道对称反相器并不是最佳的反向器，如何调整<strong>宽长比之比$\beta$​</strong>得到最佳性能的反相器？</p><p>最佳性能INV的宽长比之比满足<br>$$<br>\beta &#x3D; \sqrt{r}<br>$$<br>其中，$r$为P管和N管<strong>尺寸相同</strong>时的电阻比，即<br>$$<br>r&#x3D;\frac{R_{eqp}}{R_{eqn}}<br>$$<br><font color=red><b>最佳性能的INV需要以对称性和噪声容量为代价</b></font>。如上图，$\beta &#x3D; 1.9$​​时，得到性能最佳的INV。</p><h3 id="3-反相链的设计"><a href="#3-反相链的设计" class="headerlink" title="3. 反相链的设计"></a>3. 反相链的设计</h3><p>反相链结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210915190315032.png" alt="image-20210915190315032"></p><p>假设此处的反相链是由<strong>对称反相器</strong>构成的，根据对称反相器的延迟公式：<br>$$<br>t_p&#x3D;t_{p0}·(1+ \frac{C_{ext}}{C_{int}})<br>$$<br>如果令<br>$$<br>C_{int}&#x3D;\gamma C_g\<br>C_{ext}&#x3D;f C_g\<br>$$<br>这里的$C_g$指的是<strong>驱动管的栅极输入电容</strong>（对比上文的几个电容。$C_{int-ref}$指<strong>最小尺寸驱动管的输出电容</strong>；$C_{int}$指驱动管的输入电容，其大小是$SC_{int-ref}$；$C_{ext}$指驱动管的输入电容和线电容，这边$C_g$<strong>并没有要求是最小尺寸</strong>）；$\gamma $：<strong>比例系数，只与工艺有关</strong>；$f$：<strong>等效扇出，即第$j+1$级管子相对于第$j$级管子的尺寸</strong>。</p><p>于是，可以得到<br>$$<br>t_p&#x3D;t_{p0}·(1+ \frac{f}{\gamma})<br>$$<br>经过推导，要让<strong>反相链的延时最短</strong>，第$j$​个反相器需要满足<br>$$<br>C_{g,j}&#x3D;\sqrt{C_{g,j-1}·C_{g,j+1}}<br>$$<br>如果要达到这个，需要满足第$j$级的反相器尺寸永远是第$j-1$级反相器尺寸的$f$倍（前文提到，令$C_{ext,j+1}&#x3D;C_{g,j+1}&#x3D;f C_{g,j}$，故而只有满足$C_{g,j}&#x3D;\sqrt{C_{g,j}&#x2F;f·fC_{g,j+1}}$，等式才永远成立。）。</p><p>对于由$N$个反相器组成的反相链，可以得到<br>$$<br>f&#x3D;\sqrt[N]{C_{ext}&#x2F;C_{g1}}&#x3D;\sqrt[N]{F}<br>$$<br>其中，$F$为<strong>总等效的扇出</strong>，$F&#x3D;C_{ext,N}&#x2F;C_{g,1}&#x3D;C_{g,N+1}&#x2F;C_{g,1}&#x3D;C_L&#x2F;C_{g,1}$（忽略导线电容）</p><p>【<strong>总结</strong>】：反相器链中，<strong>每个反相器尺寸都是前一个反相器的$f$倍</strong>，则说明每一级反相器拥有相同的等效扇出（等效扇出就是$f$），并且有相同的延时，链总延时最小。</p><p>【<strong>公式总结</strong>】：</p><p>链的总延时：<br>$$<br>t_p&#x3D;Nt_{p0}·(1+ \frac{\sqrt[N]{F}}{\gamma})<br>$$<br>其中，$N$为反相链链数；$F$为总等效的扇出，$\gamma$为比例系数，只与工艺有关。</p><p>$N$大，则反相器本身延迟$t_{p0}$占主导，需要降低本征延时$t_{p0}$</p><p>$N$小，则反相器的扇出占主导，应该适当降低每一级反相器的等效扇出$f$——经过推导，一般$f&#x3D;3\sim4$</p><h2 id="6-功耗"><a href="#6-功耗" class="headerlink" title="6. 功耗"></a>6. 功耗</h2><h3 id="1-功耗组成"><a href="#1-功耗组成" class="headerlink" title="1. 功耗组成"></a>1. 功耗组成</h3><ol><li><p><strong>动态功耗</strong>：</p><p>来源于电容充放电</p></li><li><p><strong>短路电流</strong>：</p><p>当输入电压在某一个区域时，使得上下两管同时导通，从而形成短路电流。</p></li><li><p><strong>漏电流</strong>：</p><p>属于静态功耗</p></li></ol><h3 id="2-动态功耗"><a href="#2-动态功耗" class="headerlink" title="2. 动态功耗"></a>2. 动态功耗</h3><h4 id="1-工作过程——能量分配"><a href="#1-工作过程——能量分配" class="headerlink" title="1. 工作过程——能量分配"></a>1. 工作过程——能量分配</h4><p>来源于<strong>电容充放电</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210908174017914.png" alt="image-20210908174017914"></p><ol><li><p><strong>充电：P管导通，N管截止</strong></p><p>能量分配——从电源摄取能量：$EV_{DD}$​：</p><ul><li><p>充电过程，P管消耗能量：$\frac{1}{2}EV_{DD}$​</p><p>注意：此处P管消耗的功耗，<strong>和P管的尺寸无关</strong></p></li><li><p>充电结束，电容$C_L$存储能量：$\frac{1}{2}EV_{DD}$</p></li></ul></li><li><p><strong>放电：N管导通，P管截止</strong></p><p>能量分配——电容$C_L$存储的能量：$\frac{1}{2}EV_{DD}$​</p><ul><li>放电过程，N管消耗能量：$\frac{1}{2}EV_{DD}$</li></ul></li></ol><h4 id="2-公式"><a href="#2-公式" class="headerlink" title="2. 公式"></a>2. 公式</h4><p>定义：每一次<strong>开关周期</strong>（由低到高，再由高到低）所需要的固定能量，即<strong>动态功耗</strong>。为<br>$$<br>E_{dyn}&#x3D;C_LV_{DD}^2<br>$$</p><p>于是，定义<strong>每秒</strong>的<strong>平均动态功耗</strong>大小为<br>$$<br>P_{dyn}&#x3D;C_LV_{DD}^2f_{0 \rightarrow 1}<br>$$<br>其中，$f_{0 \rightarrow 1}$​为这个门电路每秒通断的次数，称为<strong>开关活动率</strong>​</p><h4 id="3-如何降低功耗"><a href="#3-如何降低功耗" class="headerlink" title="3. 如何降低功耗"></a>3. 如何降低功耗</h4><p>从上文的公式中，可以得到动态功耗同三个参数有关。</p><ul><li>降低电源电压。电源电压太低，电路性能会变差到难以接受。</li><li>减少反转率。逻辑和结构层次实现——<code>en信号+与门</code></li><li>减少电容。考察$C_L$的组成（见上文），主要在于减少器件的<strong>尺寸</strong></li></ul><h3 id="3-短路电流引起功耗"><a href="#3-短路电流引起功耗" class="headerlink" title="3. 短路电流引起功耗"></a>3. 短路电流引起功耗</h3><h4 id="1-公式"><a href="#1-公式" class="headerlink" title="1. 公式"></a>1. 公式</h4><p>每个<strong>开关周期</strong>消耗的能量：<br>$$<br>E_{dp}&#x3D;t_{sc}V_{DD}I_{peak}<br>$$<br><strong>每秒</strong>平均功耗为<br>$$<br>P_{dp}&#x3D;t_{sc}V_{DD}I_{peak}f_{0 \rightarrow 1}<br>$$<br>其中，</p><p>$t_{sc}$​​​：上下两管同时导通的时间，如下图中的$t_2-t_1$​​和$t_4-t_3$​​​。当输入信号大小满足$V_{TH}&lt;V_{in}&lt;V_{DD}-|V_{TH}|$​​，两个管子同时导通。​</p><p>$I_{peak}$​：短路电流峰值大小，如下图。​</p><p>$f_{0 \rightarrow 1}$：开关活动率。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210922101325179.png" alt="image-20210922101325179"></p><h4 id="2-同负载电容-C-L-的关系"><a href="#2-同负载电容-C-L-的关系" class="headerlink" title="2. 同负载电容$C_L$的关系"></a>2. 同负载电容$C_L$的关系</h4><ol><li><p>$C_L$很大</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210922102112590.png" alt="image-20210922102112590"></p><p>特征：输出下降时间&gt;输入上升时间</p><p>结果：输入在输出改变之间已经通过了过渡区（指$V_{TH}&lt;V_{in}&lt;V_{DD}-|V_{TH}|$​​​），此时<strong>短路电流小</strong></p><p>电路功耗：主要来自动态功耗。</p></li><li><p>$C_L$​较小</p><p>特征：输出下降时间&lt;输入上升时间</p><p>结果：输入在输出降到0还在过渡区，此时PMOS管漏-源电压近似为$V_{DD}$​，此时<strong>短路电流极大</strong>。</p><p>电路功耗：主要来自短路电流</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210922102917417.png" alt="image-20210922102917417"></p><center>负载电容大小与短路电流的关系</center><h3 id="4-静态功耗（漏电流）"><a href="#4-静态功耗（漏电流）" class="headerlink" title="4. 静态功耗（漏电流）"></a>4. 静态功耗（漏电流）</h3><h4 id="1-公式-1"><a href="#1-公式-1" class="headerlink" title="1. 公式"></a>1. 公式</h4><p>$$<br>P_{stat}&#x3D;V_{DD}I_{stat}<br>$$</p><p>其中，$I_{stat}$为没有开关活动时，电源两条轨道之间流动的电流。</p><h4 id="2-组成部分"><a href="#2-组成部分" class="headerlink" title="2. 组成部分"></a>2. 组成部分</h4><p>静态功耗主要组成</p><ul><li>亚阈值漏电功耗</li><li>PN结漏电功耗</li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>$$<br>P_{tatol}&#x3D;P_{dyn}+P_{dp}+P_{stat}<br>$$</p><p>其中，</p><p>动态功耗$P_{dyn}$​：主导位置。</p><p>短路电流功耗$P_{dp}$：可以经过把控$C_L$​的大小，把功耗控制在限定的范围之内。</p><p>静态功耗$P_{stat}$：正在变得与来越重要。</p><h2 id="7-利用【功耗】设计电路"><a href="#7-利用【功耗】设计电路" class="headerlink" title="7. 利用【功耗】设计电路"></a>7. 利用【功耗】设计电路</h2><p>这边主要利用【动态功耗】设计【反相器链】</p><p>设计目的：使整个电路<strong>功耗最小</strong>，且满足最低性能要求。</p><p>可变的设计参数：反相器等效扇出系数$f$​（后级反相器与前级反相器尺寸比）、电源电压$V_{DD}$</p><p>设计目标：<strong>延迟不大于参数为$f，V_{DD}&#x3D;V_{ref}$的参考电路</strong></p><p><strong>考虑降低电压</strong></p><p>①随着$f$的增加，电路的性能有所增加，此时可适当降低电源电压$V_{DD}$</p><p>②当$f$满足，<br>$$<br>f&#x3D;\sqrt{F}<br>$$<br>得到最理想的尺寸系数。此时，<strong>电源电压可以降到最低</strong>。</p><p>PS：当$F&#x3D;1$时，$f&#x3D;1$是最好的情况，如下图。</p><p>③当$f&gt;\sqrt{F}$​​，器件本征电容增加，性能降低，此时需要提高电源电压。​</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210922111612083.png" alt="image-20210922111612083"></p><p><strong>【小贴士】</strong>：延迟最低的等效扇出系数为$f&#x3D;\sqrt[N]{F}$</p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（2）MOS晶体管</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%882%EF%BC%89MOS%E6%99%B6%E4%BD%93%E7%AE%A1/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%882%EF%BC%89MOS%E6%99%B6%E4%BD%93%E7%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>本文主要讲述MOS晶体管动态特性（寄生电容）和手工计算延时的方法。</p><hr><span id="more"></span><h1 id="第三章-MOS晶体管"><a href="#第三章-MOS晶体管" class="headerlink" title="第三章 MOS晶体管"></a>第三章 MOS晶体管</h1><h2 id="1-数字电路的晶体管——最直观"><a href="#1-数字电路的晶体管——最直观" class="headerlink" title="1. 数字电路的晶体管——最直观"></a>1. 数字电路的晶体管——最直观</h2><ol><li><p>执行开关功能</p></li><li><p>非常小的寄生电容</p></li><li><p>非常高的集成度</p></li><li><p>相对简单的制造工艺</p></li><li><p>符号：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906221614054.png" alt="image-20210906221614054"></p></li></ol><h2 id="2-MOS静态特性——稳定性（CMOS模电基础）"><a href="#2-MOS静态特性——稳定性（CMOS模电基础）" class="headerlink" title="2. MOS静态特性——稳定性（CMOS模电基础）"></a>2. MOS静态特性——稳定性（CMOS模电基础）</h2><h3 id="1-阈值电压-V-T"><a href="#1-阈值电压-V-T" class="headerlink" title="1. 阈值电压$V_T$"></a>1. 阈值电压$V_T$</h3><ol><li>考虑<strong>体效应</strong>对于阈值电压的影响——<strong>偏执效应系数 $\gamma$</strong></li><li>阈值电压与<strong>材料常数</strong>（氧化层厚度、费米电势、注入离子剂量等）有关</li></ol><h3 id="2-三个工作区："><a href="#2-三个工作区：" class="headerlink" title="2.三个工作区："></a>2.三个工作区：</h3><p><strong>截止</strong>—（亚阈值导电）—<strong>线性</strong>—<strong>饱和</strong>—（击穿）</p><h3 id="3-沟长调制效应"><a href="#3-沟长调制效应" class="headerlink" title="3. 沟长调制效应"></a>3. 沟长调制效应</h3><ol><li><strong>沟长调制系数</strong> $\lambda$： $\lambda$<strong>反比于沟长</strong>$L$，即沟道长度越短，沟长调制效应越显著。</li><li>沟长调制效应会使得漏电流$I_D$增大</li></ol><h3 id="4-速度饱和："><a href="#4-速度饱和：" class="headerlink" title="4. 速度饱和："></a>4. 速度饱和：</h3><p><strong>短沟道</strong>的饱和区范围更大，故常常工作在饱和区。</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906222828994.png" alt="image-20210906222828994" style="zoom:67%;" /><p>此时，不再用$V_{OV}&gt;V_{GS}-V_{T}$来表征是否进入饱和区，而是<strong>使用$V_{DSAT}$表征是否进入饱和区</strong>。</p><h3 id="5-漏电流-I-D-和-V-GS"><a href="#5-漏电流-I-D-和-V-GS" class="headerlink" title="5. 漏电流$I_D$和$V_{GS}$"></a>5. 漏电流$I_D$和$V_{GS}$</h3><p>长沟道，呈现平方关系</p><p>短沟道，不那么显著</p><h2 id="3-数字电路手工分析模型——开关-R-eq"><a href="#3-数字电路手工分析模型——开关-R-eq" class="headerlink" title="3. 数字电路手工分析模型——开关+$R_{eq}$"></a>3. 数字电路手工分析模型——开关+$R_{eq}$</h2><p>常用<strong>开关模型</strong>——<strong>晶体管&#x3D;开关+无穷大断开电阻</strong>$R_{on}$   <strong>or 有限导通电阻</strong>$R_{on}$</p><p>【<strong>计算等效导通电阻</strong>$R_{eq}$】：2种方法</p><p>在实际情况中，导通电阻$R_{on}$是随工作点而时变的。而我们想要用一个<strong>等效的、恒定阻值的电阻</strong>$R_{eq}$来表征$R_{on}$。</p><ol><li><p>计算所关心的区域上面的平均电阻值：<br>$$<br>R_{eq}&#x3D;\frac{1}{t_2-t_1}\int_{t_1}^{t_2}R_{on}(t)dt<br>$$</p></li><li><p>【常用】使用瞬态过程中，<strong>起点和重点两个电阻的平均值</strong><br>$$<br>R_{eq}&#x3D;\frac{1}{2}(R_{on}(t_1)+R_{on}(t_2))<br>$$</p></li></ol><h2 id="4-【重点】MOS管的动态特性——性能（-t-p-）"><a href="#4-【重点】MOS管的动态特性——性能（-t-p-）" class="headerlink" title="4. 【重点】MOS管的动态特性——性能（$t_p$）"></a>4. 【重点】MOS管的动态特性——性能（$t_p$）</h2><h3 id="1-电容的分类"><a href="#1-电容的分类" class="headerlink" title="1. 电容的分类"></a>1. 电容的分类</h3><p>MOS管的<strong>动态响应取决</strong>于：</p><ul><li><p><strong>本征电容</strong>：</p><ul><li>基本的MOS结构：<strong>结构电容</strong></li><li>沟道电荷：<strong>沟道电容</strong></li><li>漏源反向偏置的PN结耗尽电容：<strong>结电容</strong></li></ul><p>注意：<strong>除了结构电容外，其他两个电容是非线性、随电压变化的</strong></p></li><li><p><strong>寄生电容</strong>（连线和负载引起）</p></li></ul><h3 id="2-略解本征电容"><a href="#2-略解本征电容" class="headerlink" title="2. 略解本征电容"></a>2. 略解本征电容</h3><p>简单归类：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210907215650361.png" alt="image-20210907215650361" style="zoom: 67%;" /><p><strong>小贴士：$\color{red}{红色框框}$：结构电容；$\color{gray}{灰色框框}$：沟道电容；$\color{blue}{蓝色框框}$：结电容</strong></p><h4 id="1-两个覆盖（结构）电容："><a href="#1-两个覆盖（结构）电容：" class="headerlink" title="1. 两个覆盖（结构）电容："></a>1. <strong>两个</strong>覆盖（结构）电容：</h4><p>$$<br>C_{O}&#x3D;C_{GCO}+C_{GDO}&#x3D;2C_oW<br>$$</p><p>$$<br>C_{GCO}&#x3D;C_{GDO}&#x3D;C_{ox}x_dW&#x3D;C_oW<br>$$</p><p>覆盖电容是由于源漏横向扩散到栅氧下形成的寄生电容，故而有两个——<strong>栅源之间（$C_{GSO}$）和栅漏之间（$C_{GDO}$）</strong></p><p>由于这个电容是由于<strong>扩散形成的</strong>，只要器件做成之后就电容大小就确定，于是<strong>结构电容是三类电容中唯一可以确定确切大小的</strong></p><p>小贴士：由$C_{ox}&#x3D;{\varepsilon}_{ox}&#x2F;t_{ox}$，于是我们希望$C_{ox}$尽可能的大，因为根据$I_D-V_{DS}$的公式，$I_D\varpropto C_{ox}$</p><h4 id="2-三个沟道电容："><a href="#2-三个沟道电容：" class="headerlink" title="2. 三个沟道电容："></a>2. <strong>三个</strong>沟道电容：</h4><p>沟道电容，即<strong>栅到沟道之间的电容</strong>，称为$C_{GC}$，即  <strong>(Gate Channel）</strong>。其中，<br>$$<br>C_{GC}&#x3D;C_{GCB}+C_{GCS}+C_{GCD}<br>$$<br>即，栅至体、栅至源、栅至漏电容。</p><p>由于和<strong>沟道</strong>有关，又因为沟道形成和工作点有关，于是三个工作点下，$C_{GC}$不同。</p><center>不同工作区，沟道电容的<b>平均分布情况</b></center><table><thead><tr><th align="center">工作区域</th><th align="center">$C_{GCB}$</th><th align="center">$C_{GCS}$​</th><th align="center">$C_{GCD}$</th><th align="center">总沟道电容：$C_{GC}$</th></tr></thead><tbody><tr><td align="center">截止区</td><td align="center">$C_{ox}WL$</td><td align="center">0</td><td align="center">0</td><td align="center">$C_{ox}WL$</td></tr><tr><td align="center">线性区</td><td align="center">0</td><td align="center">$C_{ox}WL&#x2F;2$</td><td align="center">$C_{ox}WL&#x2F;2$</td><td align="center">$C_{ox}WL$</td></tr><tr><td align="center">饱和区</td><td align="center">0</td><td align="center">$(2&#x2F;3)C_{ox}WL$</td><td align="center">0</td><td align="center">$(2&#x2F;3)C_{ox}WL$</td></tr></tbody></table><p>以下进行粗略解释：</p><ol><li><p>截止区，<strong>沟道未形成</strong>，沟道电容只存在于栅体之间。</p></li><li><p>线性区，<strong>反型层形成</strong>，且栅源和栅漏反型层<strong>对称</strong>，故$C_{GCB}$&#x3D;$C_{GCD}$；</p><p>反型层的形成，屏蔽了栅体，故电容为0。</p></li><li><p>饱和区，<strong>沟道被夹断</strong>，电容只存在于栅源，另外两部分为0。</p></li></ol><p>关于表格中数值的由来：前面提到，<strong>沟道电容是随着电压时变、非线性的</strong>，无法用一个值直接表征。表格中的值，是利用<strong>逐段线性</strong>得到的一个模型值，故而表头称之为“平均分布情况”。</p><h4 id="3-两个（PN）结（耗尽层）电容："><a href="#3-两个（PN）结（耗尽层）电容：" class="headerlink" title="3. 两个（PN）结（耗尽层）电容："></a>3. <strong>两个</strong>（PN）结（耗尽层）电容：</h4><p>PN结电容是由于<strong>源-体和漏-体</strong>之间<strong>反向偏置</strong>造成的。</p><p>由于工艺上面，我们是在体上“挖一个坑“放漏和源，故而他们之间存在着”立体“的关系。</p><p>故而需要关注”四周立体接触“，如图所示，</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210907210303730.png" alt="image-20210907210303730"><br>$$<br>C_{diff}&#x3D;C_{bottom}+C_{sw}&#x3D;C_jL_SW+C_{jsw}(2L_S+W)<br>$$<br>下面对公式稍作解释：</p><ol><li><p><strong>结电容&#x3D;底板PN结电容+侧壁PN结电容</strong>，分为两部分是因为底板体电极是$P$掺杂，而侧壁体电极是$P^+$掺杂；而源&#x2F;漏都是$N^+$掺杂。</p></li><li><p>结电容是非线性的，反向偏置增强，结电容减小（<strong>反比</strong>）</p></li><li><p>这里不考虑”1“边（源&#x2F;漏-沟道）侧的侧边电容，故而只有1个$W$，而不是2个$W$。</p></li><li><p>$C_j$是单位面积底板结电容；$C_{jsw}$是单位周长侧壁结电容，$C_{jsw}&#x3D;C^{’}_{jsw}x_j$。</p></li><li><p><strong>由于侧壁的体电极掺杂浓度更大</strong>，故而$C^{’}_{jsw}&gt;C_j$</p></li></ol><h3 id="3-我们关注的【本征电容】有哪些"><a href="#3-我们关注的【本征电容】有哪些" class="headerlink" title="3. 我们关注的【本征电容】有哪些"></a>3. 我们关注的【本征电容】有哪些</h3><p>我们研究电容是为了利用$\tau&#x3D;RC$计算$t_P$的值，故而我们在意的是<strong>输入和输出通路上的电容</strong>。</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210907215642779.png" alt="image-20210907215642779" style="zoom: 67%;" /><h4 id="1-输入电容——栅极电容"><a href="#1-输入电容——栅极电容" class="headerlink" title="1. 输入电容——栅极电容"></a>1. 输入电容——栅极电容</h4><p>对于输入，一般采用<strong>栅极输入</strong>，即$C_{in}&#x3D;C_G$</p><p>经过上面的推导，可以知道<br>$$<br>C_G&#x3D;C_{O}+C_{GC}<br>$$<br>即<br>$$<br>C_G&#x3D;C_{GSO}+C_{GDO}+C_{GCB}+C_{GCS}+C_{GCD}<br>$$<br>即：栅电容&#x3D;2个覆盖电容+3个沟道电容</p><table><thead><tr><th align="center">工作区</th><th align="center">$C_{O}$：覆盖电容（固定的值）</th><th align="center">$C_{GC}$：沟道电容</th><th align="center">$C_G$</th></tr></thead><tbody><tr><td align="center">截止区</td><td align="center">$2C_oW$</td><td align="center">$C_{ox}WL$</td><td align="center">$2C_oW+C_{ox}WL$</td></tr><tr><td align="center">线性区</td><td align="center">$2C_oW$</td><td align="center">$C_{ox}WL$</td><td align="center">$2C_oW+C_{ox}WL$</td></tr><tr><td align="center">饱和区</td><td align="center">$2C_oW$</td><td align="center">$(2&#x2F;3)C_{ox}WL$</td><td align="center">$2C_oW+(2&#x2F;3)C_{ox}WL$</td></tr></tbody></table><center>不同工作状态下的栅极电容</center><h4 id="2-输出电容——漏极电容"><a href="#2-输出电容——漏极电容" class="headerlink" title="2.输出电容——漏极电容"></a>2.输出电容——漏极电容</h4><p>对于输出，一般采用<strong>漏极输出</strong>，即$C_{out}&#x3D;C_D$</p><p>经过上面的推导，可以知道<br>$$<br>C_D&#x3D;C_{GDO}+C_{Ddiff}+C_{GCD}<br>$$<br>又因在数集中，一般管子只工作在<strong>饱和区和截止区</strong>，而这两个区域的$C_{GCD}&#x3D;0$</p><p>即有<br>$$<br>C_D&#x3D;C_{GDO}+C_{Ddiff}&#x3D;C_{GDO}+C_{bottom}+C_{dw}<br>$$</p><p>即：漏电容&#x3D;1个覆盖电容+1个PN结电容</p><h3 id="4-寄生电阻"><a href="#4-寄生电阻" class="headerlink" title="4. 寄生电阻"></a>4. 寄生电阻</h3><p>源漏区的串联电阻。</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210907220832414.png" alt="image-20210907220832414" style="zoom:67%;" /><p>危害：</p><ol><li>当晶体管尺寸进一步缩小，会使结变浅、接触孔变小。使得这个影响更加显著。</li><li>当给定一个电压，由于分压作用，会使得漏极电流变小。</li></ol><p>改善：</p><ol><li>源漏极铺一层低电阻材料（如钨或者钛）</li></ol><h2 id="5-MOS器件模型"><a href="#5-MOS器件模型" class="headerlink" title="5. MOS器件模型"></a>5. MOS器件模型</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路（1）引论和版图基础</title>
    <link href="/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%881%EF%BC%89%E5%BC%95%E8%AE%BA%E5%92%8C%E7%89%88%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/01/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%EF%BC%881%EF%BC%89%E5%BC%95%E8%AE%BA%E5%92%8C%E7%89%88%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本人《数字集成电路设计》课程笔记，老师为王仁平。</p><p>文本主要讲述了数字集成电路的一些基本概念和流程，并对版图有一定的认识。</p><hr><span id="more"></span><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="1-数字设计中需解决的问题"><a href="#1-数字设计中需解决的问题" class="headerlink" title="1. 数字设计中需解决的问题"></a>1. 数字设计中需解决的问题</h3><ol><li><p>摩尔定律</p><p><strong>技术突破</strong>才能推动摩尔定律</p></li><li><p>特征尺寸</p><p>28nm是传统制程和先进制程的分界点</p></li><li><p>存储器容量</p><p>存储器的容量增大，意味着功耗增大，意味着稳定性下降（发热）。如果想要实现更大容量的突破，需要寻找<strong>新技术或者新架构</strong>使功耗不能超过<strong>功耗红线</strong></p></li><li><p>晶圆尺寸</p><p>晶圆尺寸增加，单位硅片数量增加，所需的技术越先进，最终成品芯片价格也越低</p><ul><li>技术突破</li><li><strong>大直径的硅片可以大大提高成品率</strong></li></ul></li></ol><h3 id="2-集成电路质量评价"><a href="#2-集成电路质量评价" class="headerlink" title="2. 集成电路质量评价"></a>2. 集成电路质量评价</h3><h4 id="1-成本"><a href="#1-成本" class="headerlink" title="1. 成本"></a>1. 成本</h4><p>$$<br>集成电路&#x3D;固定成本（研发、设备、公司、人工）+可变成本（制作芯片的成本）<br>$$</p><p>$$<br>可变成本&#x3D;\frac{芯片成本+芯片测试成本+封装成本}{最终测试成品率}<br>$$</p><p>$$<br>芯片成本&#x3D;\frac{晶圆成本}{每个圆片的芯片数×芯片成品率}<br>$$</p><p>$$<br>每个圆片的芯片数&#x3D;{\frac{\pi×圆片半径^2}{芯片面积}}-{\frac{\pi×圆片直径}{\sqrt{2×芯片面积}}}<br>$$</p><p>$$<br>芯片成品率&#x3D;{(1+\frac{电位面积的缺陷数×芯片面积}{\alpha})}^{-\alpha}<br>$$</p><p>注：、</p><p>①$\alpha$是取决于制造工艺复杂行参数，常取值3</p><p>②单位面积缺陷数常取值0.5~1个缺陷&#x2F;cm²</p><p>③<br>$$<br>芯片成本&#x3D;f(芯片面积)^4<br>$$</p><h4 id="2-稳定性与功能性"><a href="#2-稳定性与功能性" class="headerlink" title="2. 稳定性与功能性"></a>2. 稳定性与功能性</h4><p>噪声：电容耦合、电感耦合、地线耦合</p><h4 id="3-※※※【重点】性能——延时-t-P-、工作频率​​"><a href="#3-※※※【重点】性能——延时-t-P-、工作频率​​" class="headerlink" title="3. ※※※【重点】性能——延时$t_P$、工作频率​​"></a>3. ※※※【重点】性能——延时$t_P$、工作频率​​</h4><p>性能常与<strong>时钟周期、时钟频率</strong>相关</p><p><strong>重点</strong>：延时</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220501201832526.png" alt="image-20220501201832526" style="zoom:50%;" /><ol><li><p><strong>传播延时：输入和输入波形的50%翻转点之间的时间</strong></p><p>如图：</p><p>定义传播时间$t_p$​为<br>$$<br>t_p&#x3D;\frac{t_{pLH}+t_{pHL}}{2}<br>$$<br>一般而言，</p><p>①$t_{pLH}$和$t_{pHL}$不会完全相等</p><p>②如果要求传输延时＜$t$，则意味着$t_{pLH}&lt;t$并且$t_{pHL}&lt;t$</p></li><li><p>上升时间$t_r$​</p></li><li><p>下降时间$t_f$</p></li></ol><h4 id="4-功耗和能耗"><a href="#4-功耗和能耗" class="headerlink" title="4. 功耗和能耗"></a>4. 功耗和能耗</h4><p>取决的因素太多了。</p><p>常常有：瞬时功耗、峰值功耗（研究电源线尺寸）、平均功耗（研究冷却或者对电池的要求）</p><h3 id="3-数字IC基本概念"><a href="#3-数字IC基本概念" class="headerlink" title="3. 数字IC基本概念"></a>3. 数字IC基本概念</h3><h4 id="1-电压传输特性VTC（DC传输曲线）"><a href="#1-电压传输特性VTC（DC传输曲线）" class="headerlink" title="1. 电压传输特性VTC（DC传输曲线）"></a>1. 电压传输特性VTC（DC传输曲线）</h4><p>可接受的高电压、低电压区域：$V_{IH}$和$V_{IL}$​定义为<strong>VTC增益&#x3D;-1的点</strong></p><h4 id="2-噪声容限"><a href="#2-噪声容限" class="headerlink" title="2. 噪声容限"></a>2. 噪声容限</h4><h4 id="3-再生性"><a href="#3-再生性" class="headerlink" title="3. 再生性"></a>3. 再生性</h4><p>保证一个受干扰的信号经过若干个组合逻辑之后依旧回到一个额定电平（高或者低，不是不确定态）</p><h4 id="4-抗干扰能力"><a href="#4-抗干扰能力" class="headerlink" title="4. 抗干扰能力"></a>4. 抗干扰能力</h4><h4 id="5-方向性"><a href="#5-方向性" class="headerlink" title="5. 方向性"></a>5. 方向性</h4><h4 id="6-扇入和扇出"><a href="#6-扇入和扇出" class="headerlink" title="6.扇入和扇出"></a>6.扇入和扇出</h4><p>扇入和扇出个数和一些延迟有关</p><h3 id="4-IC全定制流程"><a href="#4-IC全定制流程" class="headerlink" title="4. IC全定制流程"></a>4. IC全定制流程</h3><pre><code class=" mermaid">graph TD设计指标 --&gt; 逻辑设计和优化 --&gt;优化后的门级电路图 --&gt; 工艺映射晶体管级原理图 --&gt; 原理图仿真 --&gt;版图绘制 --&gt; 后仿真波形分析 --&gt;优化</code></pre><h2 id="第二章-版图基础"><a href="#第二章-版图基础" class="headerlink" title="第二章 版图基础"></a>第二章 版图基础</h2><h3 id="1-CMOS版图"><a href="#1-CMOS版图" class="headerlink" title="1. CMOS版图"></a>1. CMOS版图</h3><ol><li><p>版图编辑工具：<code>virtuoso</code>、<code>max</code></p></li><li><p>工艺层的概念：将cmos使用中难以理解的<strong>掩膜</strong>转化为一组简单概念化的<strong>版图层</strong></p></li><li><p><strong>可伸缩的设计</strong>：将版图所有参数定义与**$\lambda$**，利用EDA工具使之在想要兼容的工艺间转换。如0.25转为0.18。早期的工艺中，这个缩放比例可以达到75%左右，随着如今器件尺寸的减小，该比例只有90%左右了。</p><p><strong>不足</strong>：①由于不同工艺之间的<strong>非线性</strong>，线性缩放仅在有限尺寸范围内；②<strong>可缩放规则是保守的</strong>，结果会使得标准单元尺寸过大或者过小。</p></li><li><p><strong>晶体管的尺寸由</strong>$\frac{W}{L}$<strong>指定</strong>。</p><p>给定一个工艺，<strong>最小线宽为</strong>$2\lambda$；</p><p><strong>最小尺寸为</strong> $1 \ unit &#x3D; 4\lambda&#x2F;2\lambda$；</p><p>$eg:$</p><p>对于0.25工艺，可知：$2\lambda&#x3D;0.25，L_{min}&#x3D;0.25，W_{min}&#x3D;4\lambda&#x3D;0.5$</p></li><li><p>在版图中，只要<strong>多晶硅穿过扩散区，就形成一个晶体管</strong></p></li><li><p>随着工艺的发展，<strong>电源电压</strong>$V_{DD}$<strong>呈现下降趋势</strong>。</p></li></ol><h3 id="2-设计规则检查"><a href="#2-设计规则检查" class="headerlink" title="2. 设计规则检查"></a>2. 设计规则检查</h3><ol><li><p>设计规则检查工具：<code>Calibre DRC</code></p></li><li><p>设定规则的目的：可以很容易的把电路的概念转换为硅上的几何关系。</p></li><li><p><code>Calibre</code>的规则相当于是行业的标准了。</p><p>其规则是基于<strong>边（edge）</strong>的DRC&#x2F;LVE工具，所有的计算都是基于<strong>边</strong>来计算的，其中”边“分为<strong>”内边“和”外边“</strong></p></li><li><p>常见的三个指令：</p><ul><li><code>internal</code>：检查多边形的<strong>内边距</strong></li><li><code>external</code>：检查多边形的<strong>外边距</strong></li><li><code>enclosure</code>：检查多边形的<strong>交迭</strong></li></ul></li></ol><h3 id="3-【重点】棍棒图"><a href="#3-【重点】棍棒图" class="headerlink" title="3.【重点】棍棒图"></a>3.【重点】棍棒图</h3><ol><li><p>要求：<strong>①将棍棒图转为管级电路图、并且写出输出表达式；②将管级电路图转化为棍棒图</strong></p></li><li><p><strong>特点</strong>：</p><ul><li>仅用<strong>象征性的符号</strong>表示电路的拓扑结构</li><li>不需要标尺寸大小</li><li>棍棒图中棍棒的位置很重要</li></ul></li><li><p><strong>棍棒图中的串并联</strong></p><p>以下为版图的：</p><ol><li><p>串联：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906215723057.png" alt="image-20210906215723057" style="zoom: 80%;" /></li><li><p>并联：</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210906220913771.png" alt="image-20210906220913771" style="zoom:80%;" /></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>《数字集成电路》课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字IC基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习（4）网络设定</title>
    <link href="/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%AE%9A/"/>
    <url>/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>李博明老师讲的Linux课程笔记。</p><p>系统为debian系统，主要内容包括：如何给linux系统连接上网络。</p><p>同时可以参考《树莓派nas电脑连接网络》一文。</p><hr><span id="more"></span><p>李博明老师安装Linux的流程</p><ol><li>安装Linux，使之可以开机，并且升级到最新版本保证没有系统的安全。</li><li>设定好网络。</li><li>安装X window，尽快进入中文界面</li><li>安装应用程序，如火狐、谷歌浏览器等等</li></ol><p>可见，虽然网络设定是第四章才开始做笔记，事实上应该是<strong>最先设定</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210905164742788.png" alt="李博明老师搭积木式的LINUX搭建"></p><p>对于树莓派，经过一段时间没有意义的折腾之后，先找<strong>HDMI线+屏幕</strong>先把树莓派点亮，然后再进行网络的设定。</p><p>说明：由于本次实验Linux版本，本身已经开启了SSH，也就是连上网络之后，就可以使用电脑利用SSH登录树莓派，于是本次并没有遇见SSH ping不上的问题，如果之后有遇到，在整理归纳。</p><h2 id="网络界面的命名方式"><a href="#网络界面的命名方式" class="headerlink" title="网络界面的命名方式"></a>网络界面的命名方式</h2><p>从<code>Debian 9</code>之后，网络界面舍弃了之前<code>eth0</code>、<code>wlan0</code>的命名方式，改用<strong>”可预测的网络界面名称“</strong>，如<code>enp4s0</code>、<code>wlp2s0</code>。</p><p>接下来”前两个字母“进行解释：</p><ol><li><code>en</code>：ethernet的意思，即最常见的有线网卡</li><li><code>sl</code>：serial line IP（slip）连线，比较少见</li><li><code>wl</code>：wlan，译为区域无线网络，一般见于笔记本电脑</li><li><code>ww</code>：wwan，译为广域无线网络，比较少见</li></ol><p>接下来”后面四个字母和数字“进行解释：</p><ol><li><code>o</code>：onboard index</li><li><code>s</code>：slot编号</li><li><code>x</code>：MAC address，即网卡卡号</li><li><code>p</code>：bus编号，可以用<code>lspci</code>看见</li><li><code>f</code>：function</li><li><code>d</code>：dev_id，即装置的ID</li></ol><p>根据以上的命名规则，有以下几个例子</p><ol><li>enp5s0：有线网卡，其<code>PCIe</code>编号为5，slot编号为0</li><li>wlp2s0：无线网卡，其<code>PCIe</code>编号为2，slot编号为0</li><li>slp2s1：SLIP网卡，其<code>PCIe</code>编号为2，slot编号为1</li><li>wwp4s0：光宇无线网卡，其<code>PCIe</code>编号为4，slot编号为0</li></ol><h2 id="有线网络设定档"><a href="#有线网络设定档" class="headerlink" title="有线网络设定档"></a>有线网络设定档</h2><p>Debian的网络设定档为</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>network/interfaces<br></code></pre></td></tr></table></figure><p>略（因为需要补充树莓派的笔记，而且没有实体机，单纯看虚拟机的设定档并没有用）</p><h2 id="树莓派无线网络的设定"><a href="#树莓派无线网络的设定" class="headerlink" title="树莓派无线网络的设定"></a>树莓派无线网络的设定</h2><p>首先拿到树莓派，把烧录了系统的SD卡插到树莓派上面，然后采用<strong>HDMI线+显示器</strong>的方法，先进入实体终端。</p><ol><li><p>查看无线网络是否有设定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;sudo&gt; iwconfig<br></code></pre></td></tr></table></figure><p>这个指令类似与<code>ifconfig</code>，但是<code>iwconfig</code>针对无线网络。</p><p>结果如下，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lo</span>        no wireless extensions.<br><br><span class="hljs-attribute">eth0</span>      no wireless extensions.<br><br><span class="hljs-attribute">wlan0</span>     IEEE <span class="hljs-number">802</span>.<span class="hljs-number">11</span>  ESSID:<span class="hljs-string">&quot;7\xE6\xA5\xBC\xE5\xAF\x9D\xE5\xAE\xA4\xE5\xBE\x88\xE9\xAB\x98&quot;</span>  <br>          <span class="hljs-attribute">Mode</span>:Managed  Frequency:<span class="hljs-number">2</span>.<span class="hljs-number">412</span> GHz  Access Point: <span class="hljs-number">54</span>:<span class="hljs-number">75</span>:<span class="hljs-number">95</span>:<span class="hljs-number">30</span>:<span class="hljs-number">0</span>E:<span class="hljs-number">0</span>D   <br>          <span class="hljs-attribute">Bit</span> Rate=<span class="hljs-number">15</span> Mb/s   Tx-Power=<span class="hljs-number">31</span> dBm   <br>          <span class="hljs-attribute">Retry</span> short limit:<span class="hljs-number">7</span>   RTS thr:<span class="hljs-literal">off</span>   Fragment thr:<span class="hljs-literal">off</span><br>          <span class="hljs-attribute">Encryption</span> key:<span class="hljs-literal">off</span><br>          <span class="hljs-attribute">Power</span> Management:<span class="hljs-literal">off</span><br>          <span class="hljs-attribute">Link</span> Quality=<span class="hljs-number">53</span>/<span class="hljs-number">70</span>  Signal level=-<span class="hljs-number">57</span> dBm  <br>          <span class="hljs-attribute">Rx</span> invalid nwid:<span class="hljs-number">0</span>  Rx invalid crypt:<span class="hljs-number">0</span>  Rx invalid frag:<span class="hljs-number">0</span><br>          <span class="hljs-attribute">Tx</span> excessive retries:<span class="hljs-number">192</span>  Invalid misc:<span class="hljs-number">0</span>   Missed beacon:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可知：<strong>无线网卡是wlan0</strong></p></li><li><p>（这一步设情况而定）激活网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;sudo&gt; ifconfig wlan0 up<br></code></pre></td></tr></table></figure><p>有些网卡需要激活，有些不用。</p></li><li><p><strong>扫描附近网络</strong>，这是我觉得最有用的</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">iwlist wlan0 <span class="hljs-built_in">scan</span><br></code></pre></td></tr></table></figure><p>这个指令很重要：</p><ul><li><p>你永远不知到你的附近网络名称中的短横是**”-“（减号）还是”_”（下划线）**，利用这个</p><p>如果只想知道网络的名称而不像知道其他的内容，则输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">iwlist wlan0 scan <span class="hljs-string">| grep ESSID</span><br></code></pre></td></tr></table></figure></li><li><p>永远不要使用中文名称的网络。</p><p>因为刚开始，你的树莓派还不能用中文输入、显示中文字符，如果是是中文的网络，意味着你连不上无线网络。</p></li></ul></li><li><p>设定无线网络（相当于我们写网络名称和密码）</p><p>设定档地址（一般都有这个档案，没有的话，可能需要自己新建）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">/etc/wp<span class="hljs-built_in">a_supplicant</span>/wp<span class="hljs-built_in">a_supplicant</span>.conf<br></code></pre></td></tr></table></figure><p>有的话结果如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs clean">## To use this file, you should run command <span class="hljs-string">&quot;systemctl disable network-manager&quot;</span> and reboot <span class="hljs-keyword">system</span>. (Do not uncomment this line!) ##<br><br>###country=CN<br>###ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>###update_config=<span class="hljs-number">1</span><br><br><br>## WIFI <span class="hljs-number">1</span> (Do not uncomment this line!)<br><br>###network=&#123;<br>###    ssid=<span class="hljs-string">&quot;wifi_name1&quot;</span><br>###    psk=<span class="hljs-string">&quot;wifi_password1&quot;</span><br>#    priority=<span class="hljs-number">1</span><br>#    id_str=<span class="hljs-string">&quot;wifi-1&quot;</span><br>###&#125;<br><br>## WIFI <span class="hljs-number">2</span> (Do not uncomment this line!)<br><br>#network=&#123;<br>#    ssid=<span class="hljs-string">&quot;wifi_name2&quot;</span><br>#    psk=<span class="hljs-string">&quot;wifi_password2&quot;</span><br>#    priority=<span class="hljs-number">2</span><br>#    id_str=<span class="hljs-string">&quot;wifi-2&quot;</span><br>#&#125;<br><br></code></pre></td></tr></table></figure><p>一般而言，只要将将上文中，有<code>###</code>的内容去掉注释，并且在<code>ssid</code>填入你<code>wifi</code>的名字（一般这个时候你是写不了中文的:(），在<code>psk</code>填入<code>wifi</code>密码（<code>wifi</code>密码终于一定不是中文了）。如果你有其他网络，就照着写另外一个。写完保存退出。</p></li><li><p>重启即可</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;sudo&gt;</span> <span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>【李博明】linux入门笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>李博明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习（3）系统硬件查询</title>
    <link href="/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>李博明老师讲的Linux课程笔记。</p><p>系统为debian系统，主要内容包括：如何查看硬件信息。</p><p>正确的硬件认识才能做出故障排除。</p><hr><span id="more"></span><p>正确的硬件认识才能做出故障排除</p><p>主要的硬件如下：</p><ol><li>CPU型号</li><li>存储器（Memory）容量</li><li>硬盘数量与容量</li><li>显卡</li><li>各种硬件型号与驱动（界面卡）</li></ol><h1 id="1-查看CPU型号"><a href="#1-查看CPU型号" class="headerlink" title="1. 查看CPU型号"></a>1. 查看CPU型号</h1><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">cat /proc/cpuinfo<br></code></pre></td></tr></table></figure><p>一般而言，这种信息的都比较长，常转换为<code>.log</code>的日志形式进行查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">~$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo &gt; cpuinfo.log</span><br><span class="hljs-meta prompt_">~$ </span><span class="language-bash">vim cpuinfo.log</span><br>...<br>...<br></code></pre></td></tr></table></figure><p>例1：</p><p><strong>树莓派4b：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">processor</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">BogoMIPS</span>: <span class="hljs-number">108</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Features</span>: fp asimd evtstrm crc32 cpuid<br><span class="hljs-attribute">CPU</span> implementer: <span class="hljs-number">0</span>x41<br><span class="hljs-attribute">CPU</span> architecture: <span class="hljs-number">8</span><br><span class="hljs-attribute">CPU</span> variant: <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">CPU</span> part: <span class="hljs-number">0</span>xd08<br><span class="hljs-attribute">CPU</span> revision: <span class="hljs-number">3</span><br><br><span class="hljs-attribute">processor</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">BogoMIPS</span>: <span class="hljs-number">108</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Features</span>: fp asimd evtstrm crc32 cpuid<br><span class="hljs-attribute">CPU</span> implementer: <span class="hljs-number">0</span>x41<br><span class="hljs-attribute">CPU</span> architecture: <span class="hljs-number">8</span><br><span class="hljs-attribute">CPU</span> variant: <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">CPU</span> part: <span class="hljs-number">0</span>xd08<br><span class="hljs-attribute">CPU</span> revision: <span class="hljs-number">3</span><br><br><span class="hljs-attribute">processor</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">BogoMIPS</span>: <span class="hljs-number">108</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Features</span>: fp asimd evtstrm crc32 cpuid<br><span class="hljs-attribute">CPU</span> implementer: <span class="hljs-number">0</span>x41<br><span class="hljs-attribute">CPU</span> architecture: <span class="hljs-number">8</span><br><span class="hljs-attribute">CPU</span> variant: <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">CPU</span> part: <span class="hljs-number">0</span>xd08<br><span class="hljs-attribute">CPU</span> revision: <span class="hljs-number">3</span><br><br><span class="hljs-attribute">processor</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">BogoMIPS</span>: <span class="hljs-number">108</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">Features</span>: fp asimd evtstrm crc32 cpuid<br><span class="hljs-attribute">CPU</span> implementer: <span class="hljs-number">0</span>x41<br><span class="hljs-attribute">CPU</span> architecture: <span class="hljs-number">8</span><br><span class="hljs-attribute">CPU</span> variant: <span class="hljs-number">0</span>x0<br><span class="hljs-attribute">CPU</span> part: <span class="hljs-number">0</span>xd08<br><span class="hljs-attribute">CPU</span> revision: <span class="hljs-number">3</span><br><br><span class="hljs-attribute">Hardware</span>: BCM2835<br><span class="hljs-attribute">Revision</span>: b03114<br><span class="hljs-attribute">Serial</span>: <span class="hljs-number">1000000055</span>f1022c<br><span class="hljs-attribute">Model</span>: Raspberry Pi <span class="hljs-number">4</span> Model B Rev <span class="hljs-number">1</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>由上文可知：</p><ol><li>树莓派4B为4核心&#x2F;线程处理器</li><li>Hardware：告诉我们树莓派4B的型号是BCM2835</li></ol><p>例2：</p><p><strong>个人电脑虚拟机：</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">processor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">vendor_id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GenuineIntel</span><br><span class="hljs-attribute">cpu family</span><span class="hljs-punctuation">:</span> <span class="hljs-string">6</span><br><span class="hljs-attribute">model</span><span class="hljs-punctuation">:</span> <span class="hljs-string">142</span><br><span class="hljs-attribute">model name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz</span><br><span class="hljs-attribute">stepping</span><span class="hljs-punctuation">:</span> <span class="hljs-string">9</span><br><span class="hljs-attribute">microcode</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0xde</span><br><span class="hljs-attribute">cpu MHz</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2711.999</span><br><span class="hljs-attribute">cache size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3072 KB</span><br><span class="hljs-attribute">physical id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">siblings</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">core id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">cpu cores</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">apicid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">initial apicid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">fpu</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yes</span><br><span class="hljs-attribute">fpu_exception</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yes</span><br><span class="hljs-attribute">cpuid level</span><span class="hljs-punctuation">:</span> <span class="hljs-string">22</span><br><span class="hljs-attribute">wp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yes</span><br><span class="hljs-attribute">flags</span><span class="hljs-punctuation">:</span> <span class="hljs-string">fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti ssbd ibrs ibpb stibp fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid mpx rdseed adx smap clflushopt xsaveopt xsavec xsaves arat md_clear flush_l1d arch_capabilities</span><br><span class="hljs-attribute">bugs</span><span class="hljs-punctuation">:</span> <span class="hljs-string">cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit</span><br><span class="hljs-attribute">bogomips</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5423.99</span><br><span class="hljs-attribute">clflush size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">64</span><br><span class="hljs-attribute">cache_alignment</span><span class="hljs-punctuation">:</span> <span class="hljs-string">64</span><br><span class="hljs-attribute">address sizes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">43 bits physical, 48 bits virtual</span><br><span class="hljs-attribute">power management</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">processor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">processor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">processor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br>...<br></code></pre></td></tr></table></figure><p>由上文可知：</p><ol><li>虚拟机有四个线程（processor）</li><li><code>vendor_id</code>：该CPU是Intel做的</li><li><code>model name</code>：CPU型号是i5-7200U；运行速度2.50GHz，这个可以在cpu MHz得到验证。</li><li><code>cpu MHz</code>: CPU的运行速度。一般现代的多核CPU每个核的运行速度是不同的，但是由于此处是虚拟机，故速度相同（文中未列出）。不同的CPU运行速度旨在根据系统需求调整CPU运转速率，当不需要大量的计算的时候，可以节约能耗。</li><li><code>cache size</code>：内存大小为3072KB</li><li><code>siblings</code>：此处告诉我们CPU有两个同胞。如果siblings&#x3D;cpu cores，说明CPU的超执行绪（ HT, Hyper- Threading）没有打开。如果打开的话，则siblings&#x3D;2×cpu cores</li><li><code>cpu cores</code>：CPU的核心数</li><li><code>flags</code>：可以认为是CPU支持的指令集，或者说是CPU支持的功能</li><li><code>bugs</code>：指CPU存在的硬件bug；这几个bug是长久以来就存在的了，如今都是使用软件的方式规避掉硬件的bug。（这些bug的存在并不会影响日常使用）</li><li><code>bogomips</code>：Linux对于CPU的测速标准。这个标准并不是准确评判标准。简单而言，该数值越大，CPU跑的越快。</li></ol><h1 id="2-查看磁盘挂载、使用情况"><a href="#2-查看磁盘挂载、使用情况" class="headerlink" title="2. 查看磁盘挂载、使用情况"></a>2. 查看磁盘挂载、使用情况</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsblk<br>df -kh<br>free<br></code></pre></td></tr></table></figure><h1 id="3-查看界面卡"><a href="#3-查看界面卡" class="headerlink" title="3. 查看界面卡"></a>3. 查看界面卡</h1><p>拆机查看硬件型号已经成为过去：</p><ol><li>如今的主机大多数已经封装，为了芯片的散热，往往芯片外面有风扇、散热片等，拆机查看硬件型号也更加复杂。</li><li>而且，如见芯片功能愈加强大，音效卡、网卡往往也整合到系统芯片中，如南北桥，此时拆机也看不见具体的硬件型号。</li></ol><h2 id="3-1-初步判别"><a href="#3-1-初步判别" class="headerlink" title="3.1 初步判别"></a>3.1 初步判别</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lspci<br></code></pre></td></tr></table></figure><p>由于本人没有Linux实机，只能用虚拟机代替（虚拟机和实体机差别巨大）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">00</span>.<span class="hljs-number">0</span> Host bridge: Intel Corporation <span class="hljs-number">440</span>BX/ZX/DX - <span class="hljs-number">82443</span>BX/ZX/DX Host bridge (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">01</span>.<span class="hljs-number">0</span> PCI bridge: Intel Corporation <span class="hljs-number">440</span>BX/ZX/DX - <span class="hljs-number">82443</span>BX/ZX/DX AGP bridge (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">07</span>.<span class="hljs-number">0</span> ISA bridge: Intel Corporation <span class="hljs-number">82371</span>AB/EB/MB PIIX4 ISA (rev <span class="hljs-number">08</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">07</span>.<span class="hljs-number">1</span> IDE interface: Intel Corporation <span class="hljs-number">82371</span>AB/EB/MB PIIX4 IDE (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">07</span>.<span class="hljs-number">3</span> Bridge: Intel Corporation <span class="hljs-number">82371</span>AB/EB/MB PIIX4 ACPI (rev <span class="hljs-number">08</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">07</span>.<span class="hljs-number">7</span> System peripheral: VMware Virtual Machine Communication Interface (rev <span class="hljs-number">10</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">0</span>f.<span class="hljs-number">0</span> VGA compatible controller: VMware SVGA II Adapter<br><span class="hljs-attribute">00</span>:<span class="hljs-number">10</span>.<span class="hljs-number">0</span> SCSI storage controller: LSI Logic / Symbios Logic <span class="hljs-number">53</span>c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">11</span>.<span class="hljs-number">0</span> PCI bridge: VMware PCI bridge (rev <span class="hljs-number">02</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">15</span>.<span class="hljs-number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">16</span>.<span class="hljs-number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">17</span>.<span class="hljs-number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">0</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">1</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">2</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">3</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">4</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">5</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">6</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">00</span>:<span class="hljs-number">18</span>.<span class="hljs-number">7</span> PCI bridge: VMware PCI Express Root Port (rev <span class="hljs-number">01</span>)<br><span class="hljs-attribute">02</span>:<span class="hljs-number">00</span>.<span class="hljs-number">0</span> USB controller: VMware USB1.<span class="hljs-number">1</span> UHCI Controller<br><span class="hljs-attribute">02</span>:<span class="hljs-number">01</span>.<span class="hljs-number">0</span> Ethernet controller: Advanced Micro Devices, Inc.<span class="hljs-meta"> [AMD] 79c970 [PCnet32 LANCE] (rev 10)</span><br><span class="hljs-meta">02:02.0 Multimedia audio controller: Ensoniq ES1371/ES1373 / Creative Labs CT2518 (rev 02)</span><br><span class="hljs-meta">02:03.0 USB controller: VMware USB2 EHCI Controller</span><br><span class="hljs-meta">02:05.0 SATA controller: VMware SATA AHCI controller</span><br></code></pre></td></tr></table></figure><p>对上文进行说明：</p><ol><li><code>Host bridge</code>：北桥（<code>DRAM</code>控制晶片）</li><li><code>PCI bridge</code>：南桥（<code>PCIe</code>控制晶片）。如图所示，如今南桥和北桥已经合并到同一颗晶片中，其生产商为Intel，型号为<code>440BX/ZX/DX-8244BX/ZX/DX</code></li><li><code>VGA compatible controller</code>：集成显卡型号</li><li><code>Ethernet controller</code>：网卡</li><li><code>USB controller</code>：USB控制器</li><li><code>Multimedia audio controller</code>：音效卡</li><li><code>SATA controller</code>：<code>SATA </code>控制器， 磁盘控制器</li></ol><h2 id="3-2-进一步了解——驱动模组"><a href="#3-2-进一步了解——驱动模组" class="headerlink" title="3.2 进一步了解——驱动模组"></a>3.2 进一步了解——驱动模组</h2><h3 id="3-2-1-了解不同的界面卡和驱动程序"><a href="#3-2-1-了解不同的界面卡和驱动程序" class="headerlink" title="3.2.1 了解不同的界面卡和驱动程序"></a>3.2.1 了解不同的界面卡和驱动程序</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lspci -k</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">00:00.0 Host bridge:</span> <span class="hljs-string">Intel</span> <span class="hljs-string">Corporation</span> <span class="hljs-string">440BX/ZX/DX</span> <span class="hljs-bullet">-</span> <span class="hljs-string">82443BX/ZX/DX</span> <span class="hljs-string">Host</span> <span class="hljs-string">bridge</span> <span class="hljs-string">(rev</span> <span class="hljs-number">01</span><span class="hljs-string">)</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">Virtual</span> <span class="hljs-string">Machine</span> <span class="hljs-string">Chipset</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">agpgart-intel</span><br><span class="hljs-attr">00:01.0 PCI bridge:</span> <span class="hljs-string">Intel</span> <span class="hljs-string">Corporation</span> <span class="hljs-string">440BX/ZX/DX</span> <span class="hljs-bullet">-</span> <span class="hljs-string">82443BX/ZX/DX</span> <span class="hljs-string">AGP</span> <span class="hljs-string">bridge</span> <span class="hljs-string">(rev</span> <span class="hljs-number">01</span><span class="hljs-string">)</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">00:0f.0 VGA compatible controller:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">SVGA</span> <span class="hljs-string">II</span> <span class="hljs-string">Adapter</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">SVGA</span> <span class="hljs-string">II</span> <span class="hljs-string">Adapter</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">vmwgfx</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">vmwgfx</span><br><span class="hljs-attr">00:10.0 SCSI storage controller:</span> <span class="hljs-string">LSI</span> <span class="hljs-string">Logic</span> <span class="hljs-string">/</span> <span class="hljs-string">Symbios</span> <span class="hljs-string">Logic</span> <span class="hljs-string">53c1030</span> <span class="hljs-string">PCI-X</span> <span class="hljs-string">Fusion-MPT</span> <span class="hljs-string">Dual</span> <span class="hljs-string">Ultra320</span> <span class="hljs-string">SCSI</span> <span class="hljs-string">(rev</span> <span class="hljs-number">01</span><span class="hljs-string">)</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">LSI</span> <span class="hljs-string">Logic</span> <span class="hljs-string">Parallel</span> <span class="hljs-string">SCSI</span> <span class="hljs-string">Controller</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">mptspi</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">mptspi</span><br><span class="hljs-string">...</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">02:00.0 USB controller:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">USB1.1</span> <span class="hljs-string">UHCI</span> <span class="hljs-string">Controller</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">USB1.1</span> <span class="hljs-string">UHCI</span> <span class="hljs-string">Controller</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">uhci_hcd</span><br><span class="hljs-attr">02:01.0 Ethernet controller:</span> <span class="hljs-string">Advanced</span> <span class="hljs-string">Micro</span> <span class="hljs-string">Devices,</span> <span class="hljs-string">Inc.</span> [<span class="hljs-string">AMD</span>] <span class="hljs-string">79c970</span> [<span class="hljs-string">PCnet32</span> <span class="hljs-string">LANCE</span>] <span class="hljs-string">(rev</span> <span class="hljs-number">10</span><span class="hljs-string">)</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">Advanced</span> <span class="hljs-string">Micro</span> <span class="hljs-string">Devices,</span> <span class="hljs-string">Inc.</span> [<span class="hljs-string">AMD</span>] <span class="hljs-string">PCnet</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Fast</span> <span class="hljs-string">79C971</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">pcnet32</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">pcnet32</span><br><span class="hljs-attr">02:02.0 Multimedia audio controller:</span> <span class="hljs-string">Ensoniq</span> <span class="hljs-string">ES1371/ES1373</span> <span class="hljs-string">/</span> <span class="hljs-string">Creative</span> <span class="hljs-string">Labs</span> <span class="hljs-string">CT2518</span> <span class="hljs-string">(rev</span> <span class="hljs-number">02</span><span class="hljs-string">)</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">Ensoniq</span> <span class="hljs-string">Audio</span> <span class="hljs-string">PCI</span> <span class="hljs-string">64V/128/5200</span> <span class="hljs-string">/</span> <span class="hljs-string">Creative</span> <span class="hljs-string">CT4810/CT5803/CT5806</span> [<span class="hljs-string">Sound</span> <span class="hljs-string">Blaster</span> <span class="hljs-string">PCI</span>]<br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">snd_ens1371</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">snd_ens1371</span><br><span class="hljs-attr">02:03.0 USB controller:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">USB2</span> <span class="hljs-string">EHCI</span> <span class="hljs-string">Controller</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">USB2</span> <span class="hljs-string">EHCI</span> <span class="hljs-string">Controller</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">ehci-pci</span><br><span class="hljs-attr">02:05.0 SATA controller:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">SATA</span> <span class="hljs-string">AHCI</span> <span class="hljs-string">controller</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">VMware</span> <span class="hljs-string">SATA</span> <span class="hljs-string">AHCI</span> <span class="hljs-string">controller</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">ahci</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">ahci</span><br></code></pre></td></tr></table></figure><p>其中最重要的有两行：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Kernel driver in use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">模组名称</span><br><span class="hljs-attribute">Kernel modules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">模组名称</span><br></code></pre></td></tr></table></figure><p>其中：</p><p><code>Kernel modules:</code> 指该硬件需要什么样的驱动程序模组才能驱动</p><p><code>Kernel driver in use:</code>目前正在使用这个模组驱动该硬件</p><p>如果没有<code>Kernel driver in use</code>，则说明该驱动模组并没有载入。</p><h3 id="3-2-2-观察目前系统载入的核心模组"><a href="#3-2-2-观察目前系统载入的核心模组" class="headerlink" title="3.2.2 观察目前系统载入的核心模组"></a>3.2.2 观察目前系统载入的核心模组</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lsmod</span><br></code></pre></td></tr></table></figure><p>该命令执行的结果，并不按照”字母“排序</p><p>如果想要按照”字母“进行排序，则执行（有缺点：标题<code>Module ...</code>也会参与排序）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| sort</span><br></code></pre></td></tr></table></figure><p>从结果来看，可以看到上文<code>Kernel driver in use:</code>提到的许多模组。同时可以看到该模组目前有没有被其他模组使用（<code>by</code>栏），这取决了模组之间的<strong>相依</strong>关系</p><h2 id="3-3-载入、删除核心模组"><a href="#3-3-载入、删除核心模组" class="headerlink" title="3.3 载入、删除核心模组"></a>3.3 载入、删除核心模组</h2><p>如果我们需要的模组（假设模组名为AAA）没有在<code>lsmod</code>中出现，我们就需要自己<strong>安装</strong>，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe AAA<br></code></pre></td></tr></table></figure><p>如果想要<strong>移除</strong>，则执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rmmod AAA<br></code></pre></td></tr></table></figure><p>如果该模组和其他模组有相依关系（其他模组正在使用着该模组），可能无法移除，此时只能将这些模组一并移除。</p><p>一般而言，如果模组出了问题，我们<strong>不希望</strong>通过关机重启的方法进行修复，我们希望使用其他的办法对模组进行修复。</p><h1 id="4-使用dmesg查看系统信息"><a href="#4-使用dmesg查看系统信息" class="headerlink" title="4. 使用dmesg查看系统信息"></a>4. 使用<code>dmesg</code>查看系统信息</h1><p><code>dmesg</code>报告相当的长，我们一般采用<code>dmesg &gt; filename.log</code>，再利用<code>vi</code>或者<code>vim</code>进行阅读。</p><h2 id="4-1-编译核心"><a href="#4-1-编译核心" class="headerlink" title="4.1 编译核心"></a>4.1 编译核心</h2><p>如下文</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[    0.000000]</span> <span class="hljs-selector-tag">Linux</span> <span class="hljs-selector-tag">version</span> <span class="hljs-number">5.10</span><span class="hljs-selector-class">.42-Release-OPENFANS</span>+<span class="hljs-number">20210611</span><span class="hljs-selector-tag">-v8</span> (root<span class="hljs-variable">@cavium</span>) (gcc-<span class="hljs-number">10.2</span>.<span class="hljs-number">0</span> (GCC) <span class="hljs-number">10.2</span>.<span class="hljs-number">0</span>, GNU ld (GNU Binutils for Ubuntu) <span class="hljs-number">2.26</span>.<span class="hljs-number">1</span>) <span class="hljs-selector-id">#1</span> <span class="hljs-selector-tag">SMP</span> <span class="hljs-selector-tag">PREEMPT</span> <span class="hljs-selector-tag">Fri</span> <span class="hljs-selector-tag">Jun</span> <span class="hljs-number">11</span> <span class="hljs-number">17</span>:<span class="hljs-number">19</span>:<span class="hljs-number">45</span> <span class="hljs-selector-tag">CST</span> <span class="hljs-number">2021</span><br></code></pre></td></tr></table></figure><p>由上文可知，Linux核心的版本是5.10.42，编译核心的人是<code>root@cavium</code>，使用的是<code>gcc-10.2.0</code>编译的</p><h2 id="4-2-CPU信息"><a href="#4-2-CPU信息" class="headerlink" title="4.2 CPU信息"></a>4.2 CPU信息</h2><p>（前面也可以看到，这里不赘述）</p><h2 id="4-3-网络信息"><a href="#4-3-网络信息" class="headerlink" title="4.3 网络信息"></a>4.3 网络信息</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[    3.499713]</span> pcnet32 <span class="hljs-number">0000</span>:<span class="hljs-number">02</span>:<span class="hljs-number">01.0</span> ens33: renamed <span class="hljs-keyword">from</span> eth0<br></code></pre></td></tr></table></figure><p>可见，驱动模组是<code>pcnet32</code></p><p>使用<code>lspci -k</code>，可见</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">02:01.0 Ethernet controller:</span> <span class="hljs-string">Advanced</span> <span class="hljs-string">Micro</span> <span class="hljs-string">Devices,</span> <span class="hljs-string">Inc.</span> [<span class="hljs-string">AMD</span>] <span class="hljs-string">79c970</span> [<span class="hljs-string">PCnet32</span> <span class="hljs-string">LANCE</span>] <span class="hljs-string">(rev</span> <span class="hljs-number">10</span><span class="hljs-string">)</span><br><span class="hljs-attr">Subsystem:</span> <span class="hljs-string">Advanced</span> <span class="hljs-string">Micro</span> <span class="hljs-string">Devices,</span> <span class="hljs-string">Inc.</span> [<span class="hljs-string">AMD</span>] <span class="hljs-string">PCnet</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Fast</span> <span class="hljs-string">79C971</span><br><span class="hljs-attr">Kernel driver in use:</span> <span class="hljs-string">pcnet32</span><br><span class="hljs-attr">Kernel modules:</span> <span class="hljs-string">pcnet32</span><br></code></pre></td></tr></table></figure><p>其中，<code>Kernel driver in use</code>是<code>pcnet32</code></p><p>使用<code>lsmod</code>，可见</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Module</span>Size Used by<br><span class="hljs-attribute">pcnet32</span>    <span class="hljs-number">45056</span>    <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>其中，<code>pcnet32</code>已经被加载</p><h2 id="4-3-硬盘信息"><a href="#4-3-硬盘信息" class="headerlink" title="4.3 硬盘信息"></a>4.3 硬盘信息</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dns">[    <span class="hljs-number">4.123960</span>] sd <span class="hljs-number">32:0:0:0</span>: Attached scsi generic sg1 type <span class="hljs-number">0</span><br>[    <span class="hljs-number">4.123986</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] <span class="hljs-number">41943040</span> <span class="hljs-number">512</span>-byte logical blocks: (<span class="hljs-number">21</span>.<span class="hljs-number">5</span> GB/<span class="hljs-number">20</span>.<span class="hljs-number">0</span> GiB)<br>[    <span class="hljs-number">4.124201</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] Write Protect is off<br>[    <span class="hljs-number">4.124206</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] Mode Sense: <span class="hljs-number">61 00 00 00</span><br>[    <span class="hljs-number">4.124770</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] Cache data unavailable<br>[    <span class="hljs-number">4.124774</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] Assuming drive cache: write through<br>[    <span class="hljs-number">4.124880</span>] sd <span class="hljs-number">32:0:1:0</span>: Attached scsi generic sg2 type <span class="hljs-number">0</span><br>[    <span class="hljs-number">4.125500</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] <span class="hljs-number">314572800</span> <span class="hljs-number">512</span>-byte logical blocks: (<span class="hljs-number">161</span> GB/<span class="hljs-number">150</span> GiB)<br>[    <span class="hljs-number">4.125659</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] Write Protect is off<br>[    <span class="hljs-number">4.125664</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] Mode Sense: <span class="hljs-number">61 00 00 00</span><br>[    <span class="hljs-number">4.125989</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] Cache data unavailable<br>[    <span class="hljs-number">4.125995</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] Assuming drive cache: write through<br>[    <span class="hljs-number">4.127227</span>]  sda: sda1<br>[    <span class="hljs-number">4.128478</span>]  sdb: sdb1<br>[    <span class="hljs-number">4.138067</span>] sd <span class="hljs-number">32:0:0:0</span>: [sda] Attached SCSI disk<br>[    <span class="hljs-number">4.139102</span>] sd <span class="hljs-number">32:0:1:0</span>: [sdb] Attached SCSI disk<br></code></pre></td></tr></table></figure><p>可以看到，一共有两个硬盘：<code>sda</code>、<code>sdb</code>，还可以看到硬盘容量。</p><h1 id="5-dmidecode查看系统信息"><a href="#5-dmidecode查看系统信息" class="headerlink" title="5. dmidecode查看系统信息"></a>5. <code>dmidecode</code>查看系统信息</h1><p><code>dmidecode</code>是一个可以解码主机BIOS的DMI&#x2F;SMBIOS内的信息，输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dmidecode</span><br></code></pre></td></tr></table></figure><p>该命令的输出很长，但是十分重要。</p><h2 id="5-1-BIOS信息"><a href="#5-1-BIOS信息" class="headerlink" title="5.1 BIOS信息"></a>5.1 BIOS信息</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">BIOS Information</span><br><span class="hljs-attribute">Vendor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Phoenix Technologies LTD</span><br><span class="hljs-attribute">Version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">6.00</span><br><span class="hljs-attribute">Release Date</span><span class="hljs-punctuation">:</span> <span class="hljs-string">07/29/2019</span><br><span class="hljs-attribute">Address</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0xEA480</span><br><span class="hljs-attribute">Runtime Size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">88960 bytes</span><br><span class="hljs-attribute">ROM Size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">64 kB</span><br><span class="hljs-attribute">Characteristics</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">ISA is supported</span><br><span class="hljs-attribute">PCI is supported</span><br><span class="hljs-attribute">PC Card (PCMCIA) is supported</span><br><span class="hljs-attribute">PNP is supported</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">BIOS Revision</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4.6</span><br><span class="hljs-attribute">Firmware Revision</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.0</span><br></code></pre></td></tr></table></figure><p>内容包括BIOS的版本（6.00）、厂商（Phoenix Technologies LTD）、释出日期（07&#x2F;29&#x2F;2019）、其所支持的版本等等</p><h2 id="5-2-主机信息"><a href="#5-2-主机信息" class="headerlink" title="5.2 主机信息"></a>5.2 主机信息</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">System Information<br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure><h2 id="5-3-主板信息"><a href="#5-3-主板信息" class="headerlink" title="5.3 主板信息"></a>5.3 主板信息</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Base </span><span class="hljs-keyword">Board </span>Information<br>...<br></code></pre></td></tr></table></figure><h2 id="5-4-CPU信息"><a href="#5-4-CPU信息" class="headerlink" title="5.4 CPU信息"></a>5.4 CPU信息</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">Processor Information<br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure><h2 id="5-5-缓存信息（有相关的补充）"><a href="#5-5-缓存信息（有相关的补充）" class="headerlink" title="5.5 缓存信息（有相关的补充）"></a>5.5 缓存信息（有相关的补充）</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span> Information<br>Socket Designation: L1<br><span class="hljs-params">...</span><br><span class="hljs-keyword">Cache</span> Information<br>Socket Designation: L2<br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>包括一阶缓存、二阶缓存等等…</p><p>补充说明：cache（缓存）</p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20220501195400330.png" alt="image-20220501195400330" style="zoom:50%;" /><p>电脑的所有指令中，话得时间最长的是存档，之后就是读档。</p><p>有些存储器的地址特别常用，就会优先存到Cache中。实际的读写中，由于不同Level的Cache存储的地址不同，于是产生了击中（Hit）和失误（Miss）的概念。</p><h2 id="5-6-内存条（tw：记忆体、US：Momery）信息"><a href="#5-6-内存条（tw：记忆体、US：Momery）信息" class="headerlink" title="5.6 内存条（tw：记忆体、US：Momery）信息"></a>5.6 内存条（tw：记忆体、US：Momery）信息</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Memory Device</span><br></code></pre></td></tr></table></figure><p>小贴士：如果电脑有多个内存条，我们希望购买同一个厂家、同一个型号、同一个批次、同一个容量的内存条，这样搭建的服务器稳定。  </p><p>等等…信息</p>]]></content>
    
    
    <categories>
      
      <category>【李博明】linux入门笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>李博明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习（2）文档结构</title>
    <link href="/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>李博明老师讲的Linux课程笔记。</p><p>系统为debian系统，主要内容包括：linux文档结构（也就是各个文件是干嘛的）</p><hr><span id="more"></span><h1 id="1-文档结构略图"><a href="#1-文档结构略图" class="headerlink" title="1. 文档结构略图"></a>1. 文档结构略图</h1><p>.—————————————————————————————————————根目录（档案最上层）<br>├── bin————————————————————————————–给所有使用者使用之必要执行档<br>├── boot———————————————————————开机核心及boot loader（grub&#x2F;）存放目录<br>│   └── grub——————————————————————————–boot loader（grub&#x2F;）存放目录<br>├── cdrom<br>├── dev<br>├── etc<br>│   └── X11<br>├── home<br>├── lib<br>│   └── modules<br>├── lib64<br>├── lost+found<br>├── media<br>├── mnt<br>├── opt<br>├── proc<br>├── sbin<br>├── sys<br>├── tmp<br>├── usr<br>│   ├── bin<br>│   ├── games<br>│   ├── include<br>│   ├── lib<br>│   ├── local<br>│   │   ├── bin<br>│   │   ├── etc<br>│   │   ├── games<br>│   │   ├── include<br>│   │   ├── lib<br>│   │   ├── man -&gt; share&#x2F;man<br>│   │   ├── sbin<br>│   │   ├── share<br>│   │   └── src<br>│   ├── sbin<br>│   ├── share<br>│   └── src<br>└── var<br>     ├── cache<br>     ├── backups<br>     ├── log<br>     ├── locked<br>     └── spool</p><h1 id="2-x2F-bin、-x2F-usr-x2F-bin、-x2F-usr-x2F-local-x2F-bin"><a href="#2-x2F-bin、-x2F-usr-x2F-bin、-x2F-usr-x2F-local-x2F-bin" class="headerlink" title="2. &#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin"></a>2. &#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin</h1><p>这三个目录均存放<strong>可执行档</strong>，其差别在于：</p><ul><li><code>/bin</code>：放最基本、最必要执行的可执行档以供<strong>单人模式</strong>使用者使用。即可认为<strong>相当重要、最基础、没有这个没法进行Linux操作</strong>。比如：<code>ls</code>、<code>mkdir</code>、<code>cat</code>…等指令</li><li><code>/usr/bin</code>：大部分的可执行档，这些执行档并不是必须的。比如：<code>zip</code>、<code>vim</code>、<code>shell</code></li><li><code>/usr/local/bin</code>：<strong>使用者自行安装的可执行档</strong>。比如：<code>iverilog</code></li></ul><p>小贴士：为何要分<code>/bin</code>和<code>/usr/bin</code>两个文件呢？久远以前，用磁带进行存储，磁带容量的限制。如今，二者已经趋于合并，如centos</p><h1 id="3-x2F-sbin、-x2F-usr-x2F-sbin、-x2F-usr-x2F-local-x2F-sbin"><a href="#3-x2F-sbin、-x2F-usr-x2F-sbin、-x2F-usr-x2F-local-x2F-sbin" class="headerlink" title="3. &#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin"></a>3. &#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin</h1><p>类似于<code>/bin</code>、<code>/usr/bin</code>、<code>/usr/local/bin</code></p><ul><li><code>/sbin</code>：放最基本、最必要执行的<strong>系统管理</strong>可执行档以供<strong>系统管理员</strong>使用。比如：<code>ifconfig</code>、<code>fdisk</code></li><li><code>/usr/sbin</code>：给应用程序使用的系统管理工具。比如：<code>sshd</code></li><li><code>/usr/local/sbin</code>：用户自行安装的系统管理工具。目前没有接触到，比如略。</li></ul><h1 id="4-x2F-boot"><a href="#4-x2F-boot" class="headerlink" title="4. &#x2F;boot"></a>4. &#x2F;boot</h1><p>存放<strong>Linux的核心</strong>，粗略介绍几个文件。</p><ul><li><p><strong>config-xxxx文档</strong>：</p><p>核心编译设定档，该设定档方便我们依照其设定自行编译Linux核心。</p></li><li><p><strong>initrd.img-xxxx文档</strong>：</p><p>核心的initrd镜像档，其中，initrd是INItial RamDisk的简写。这是开机时所载入的一个小档案系统，负责载入系统驱动程序，最终引导核心完成开机流程。</p><p>通俗点理解，比如我们需要使用光盘启动。此时，驱动程序是在光盘上面的，而我们如果无法识别这是什么种类的光盘、驱动光盘，就没有办法使用光盘载入驱动程序。该镜像文档边存储了一些最常见的驱动程序，用于协助载入驱动程序。当系统驱动程序载入完成之后，就可以将控制权移交给核心，完成开机流程。</p></li><li><p><strong>System.map-xxxx文档</strong>：</p><p>档案中存放了核心所需要的符号表（Symbol Table）。这个和与核心开发有关，此处略。</p></li><li><p><strong>vmlinuz-xxxx文档</strong>：真正编译完的Linux核心。</p></li></ul><h2 id="x2F-boot-x2F-grub"><a href="#x2F-boot-x2F-grub" class="headerlink" title="&#x2F;boot&#x2F;grub"></a>&#x2F;boot&#x2F;grub</h2><p>比较重要的<code>/boot/grub/grub.cfg</code>文档，它是<strong>开机设定档</strong>，使用者可以参考里面的设定了解自己的电脑是如何开机的。</p><h1 id="5-x2F-dev"><a href="#5-x2F-dev" class="headerlink" title="5. &#x2F;dev"></a>5. &#x2F;dev</h1><p>&#x2F;dev文档存放了Linux的<strong>装置档案</strong>。</p><p>何为装置档？我们可以认为在Linux系统中，每一种装置都化身为一个文档，对于相应文档的操作就是对于相应装置的操作。</p><h2 id="5-1-装置类别"><a href="#5-1-装置类别" class="headerlink" title="5.1 装置类别"></a>5.1 装置类别</h2><p>在终端窗口输入 <code>ls -la</code>，可以获取如以下例子的列表。</p><table><thead><tr><th align="center">d</th><th align="center">rwxr-xr-x</th><th align="center">2</th><th align="center">root</th><th align="center">root</th><th align="center">4096</th><th align="center">9月 3 2021</th><th align="center">my_dir</th></tr></thead><tbody><tr><td align="center">类别</td><td align="center">属性</td><td align="center">连结的节点数</td><td align="center">所有人</td><td align="center">群组</td><td align="center">大小</td><td align="center">最后的修改时间</td><td align="center">文件名</td></tr></tbody></table><p>其中，第一个就是<strong>类别</strong>。以下进行解释。</p><table><thead><tr><th align="left">类别</th><th>说明</th></tr></thead><tbody><tr><td align="left"><strong>-</strong></td><td>正常文档</td></tr><tr><td align="left"><strong>d</strong>(irectory)</td><td>目录（俗称文件夹）</td></tr><tr><td align="left"><strong>l</strong>(ink)</td><td>链接档（可理解为win中的快捷方式）</td></tr><tr><td align="left"><strong>c</strong>(haracter)<strong>&#x2F;u</strong></td><td>字元档，一种装置档案（只会出现在&#x2F;dev）。字元档就是一次传输字元，<strong>没有缓冲</strong>，以串行方式进行通信。比如<strong>鼠标、键盘、虚拟终端机（shell）</strong></td></tr><tr><td align="left"><strong>b</strong>(lock)</td><td>区块档，一种装置档案（只会出现在&#x2F;dev）。区块档是指系统在传输资料时，以块为单位进行传输。区块档有<strong>缓存</strong>，因此在传输数据的过程中，先传输到缓存在传输到真正的设备。比如<strong>硬盘、光碟、U盘</strong>。</td></tr><tr><td align="left"><strong>s</strong>(ocket)</td><td>网络通信连结的端点。略</td></tr><tr><td align="left"><strong>p</strong>(ipe)</td><td>称为导管或者FIFO的装置。略</td></tr></tbody></table><p>其中最常见的两种装置档——字元档和区块档。</p><p><strong>字元档</strong>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>...<br>crw-------1 root tty   13,63 9月 3 15：34 tty#终端机<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /dev/input</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>...<br>crw-rw----1 root input 13,63 9月 3 15：34 event0#事件（如键盘等）<br>crw-rw----1 root input 13,32 9月 3 15：34 mouse0    #鼠标<br>...<br></code></pre></td></tr></table></figure><p><strong>区块档</strong>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /dev/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>...<br>crw-rw----1 root cdrom 21, 0 9月 3 15：34 sr0#光碟<br>crw-rw----1 root disk   8, 0 9月 3 15：34 sda#硬盘<br>crw-rw----1 root disk   8, 1 9月 3 15：34 sdb<br>...<br></code></pre></td></tr></table></figure><p><strong>小贴士</strong>：</p><p>①在终端中执行<code>lsblk</code>、<code>df -kh</code>，可以查看硬盘的挂载和使用情况</p><p>②在终端中执行<code>file &lt;filename&gt;</code>、<code>stat &lt;filename&gt;</code>，可以查看文件信息</p><h2 id="5-2-Major-Number-和Mimor-Number"><a href="#5-2-Major-Number-和Mimor-Number" class="headerlink" title="5.2 Major Number 和Mimor Number"></a>5.2 Major Number 和Mimor Number</h2><p>装置档和不同的文件（-、d、l）不同，原本表示<strong>大小</strong>的地方，不在表示大小，而是Major Number 和Mimor Number。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">crw</span>-rw----<span class="hljs-number">1</span> root cdrom <span class="hljs-number">21</span>, <span class="hljs-number">0</span> <span class="hljs-number">9</span>月 <span class="hljs-number">3</span> <span class="hljs-number">15</span>：<span class="hljs-number">34</span> sr0<br></code></pre></td></tr></table></figure><p>如上文所示的”21，0“。那何为Major Number 和Mimor Number？</p><p>此处仅仅引入这两个概念，不做深入探究。因为这并非普通用户需要知道的，而是给写驱动的用户看的。</p><h2 id="5-3-虚拟终端机和实体终端机"><a href="#5-3-虚拟终端机和实体终端机" class="headerlink" title="5.3 虚拟终端机和实体终端机"></a>5.3 虚拟终端机和实体终端机</h2><h3 id="5-3-1-实体终端机"><a href="#5-3-1-实体终端机" class="headerlink" title="5.3.1 实体终端机"></a>5.3.1 实体终端机</h3><p>Linux或者说Unix系统，是一个<strong>多人多工</strong>的操作系统。也就是一台电脑，可以多人登录并且同时使用。</p><p>在远古时期，一台服务器上面会连接多个终端机（可以理解为一台主机+多个屏幕）。</p><p>一台装好系统的Linux电脑，本身就自带可供6个人使用的终端机。使用<kbd>alt</kbd>+<kbd>F1</kbd>~<kbd>alt</kbd>+<kbd>F6</kbd>可以在6个终端机之间切换。</p><p><strong>实体终端机占用的位置是 <code>/dev</code></strong></p><p>如下所示，即”shi“账号，通过两个实体终端机连入主机。</p><p>所谓是实体终端机，就是看得到、摸得到鼠标键盘的机器。比如：显示器+鼠标键盘、手机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>...<br>crw-------1 shi tty   13,63 9月 3 15：34 tty1#终端机<br>crw-------1 shi tty   13,63 9月 3 15：34 tty2#终端机<br>...<br></code></pre></td></tr></table></figure><h3 id="5-3-2-虚拟终端机"><a href="#5-3-2-虚拟终端机" class="headerlink" title="5.3.2 虚拟终端机"></a>5.3.2 虚拟终端机</h3><p>简单而言，<strong>虚拟终端机</strong>就是在你鼠标右键，”打开终端“所打开的终端。</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210903185451635.png" alt="image-20210903185451635"></p><p>**虚拟终端机所占的位置在<code>/dev/pts</code>**（pts：pseudo terminal slave），</p><p>如下所示：此处打开了两个虚拟终端机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /dev/pts</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l</span><br>crw--w----1 shi  tty   136,0 9月 3 15：34 0#终端机<br>crw--w----1 shi  tty   136,2 9月 3 15：34 1#终端机<br>c---------  1 root root    5,2 9月 3 15：34 ptmx<br>...<br></code></pre></td></tr></table></figure><p>在某个虚拟终端机，输入<code>tty</code>，如下所示，表示这个虚拟终端化身为&#x2F;dev&#x2F;pts&#x2F;2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tty</span></span><br>/dev/pts/2<br>...<br></code></pre></td></tr></table></figure><h2 id="5-4-x2F-dev下的串行线"><a href="#5-4-x2F-dev下的串行线" class="headerlink" title="5.4 &#x2F;dev下的串行线"></a>5.4 &#x2F;dev下的串行线</h2><p>ttys和tty的很像，在&#x2F;dev中显示为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">crw</span>-rw----<span class="hljs-number">1</span> root dialout   <span class="hljs-number">4</span>,<span class="hljs-number">86</span> <span class="hljs-number">9</span>月 <span class="hljs-number">3</span> <span class="hljs-number">15</span>：<span class="hljs-number">34</span> ttys23#串行线<br></code></pre></td></tr></table></figure><p>ttyS专门用于网络连接，如今常用于<strong>外界电路板&#x2F;开发板</strong></p><h2 id="5-5-x2F-dev下的USB设备"><a href="#5-5-x2F-dev下的USB设备" class="headerlink" title="5.5 &#x2F;dev下的USB设备"></a>5.5 &#x2F;dev下的USB设备</h2><p>USB设备存在于<code>/dev/input</code>下面</p><h2 id="5-6-x2F-dev下其他有趣的设备"><a href="#5-6-x2F-dev下其他有趣的设备" class="headerlink" title="5.6 &#x2F;dev下其他有趣的设备"></a>5.6 &#x2F;dev下其他有趣的设备</h2><ol><li><p><code>/dev/null</code></p><p>”黑洞“，可以接收任何信息，但是并不会产生任何输出。永远不会满。</p><p>应用的地方嘛~比如在”开机时，会产生许多的log信息，这些信息不需要呈现给用户，就可以把这些信息扔到’黑洞‘中“。</p><p>如<code>/etc/init.d/exim4</code>程序片段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">if pidofproc -p &quot;$QRPIDFILE&quot; &quot;$DAEMON&quot; &gt;/dev/null; then<br>log_action_end_msg 0 &quot;running&quot;<br></code></pre></td></tr></table></figure><p>再如：把<code>ls - l /dev</code>的所有输出内容扔到黑洞中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /dev &gt; /dev/null</span><br></code></pre></td></tr></table></figure></li><li><p><code>/dev/zero</code></p><p>专门产生”空字节“，常和<code>dd</code>指令一起使用</p><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=test.img bs=1M count=1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建以一个名为test.img的文件，其他大小为1MB，其内容全部用0填充，只执1次</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用hexdump查看文件（以16进制查看文件）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexdump test.img</span> <br>000000 0000 0000 0000 0000 0000<br>*<br>010000<br><span class="hljs-meta prompt_">#</span><span class="language-bash">文件全部用0x00填充</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="6-x2F-etc"><a href="#6-x2F-etc" class="headerlink" title="6. &#x2F;etc"></a>6. &#x2F;etc</h1><p>&#x2F;etc存放<strong>整个系统的设定</strong>，包括网络设定、开机设定、服务器设定等等。</p><p>注意：如果作Linux系统的备份的时候，<strong>需要注意备份&#x2F;etc</strong></p><h2 id="x2F-etc-x2F-init-d"><a href="#x2F-etc-x2F-init-d" class="headerlink" title="&#x2F;etc&#x2F;init.d"></a>&#x2F;etc&#x2F;init.d</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">drwxr-xr-x 2 root root 4096 &lt;time&gt; init.d<br></code></pre></td></tr></table></figure><p>存放所有系统启动的服务，包括初始化网络、键盘对应等等</p><h1 id="7-x2F-etc-x2F-X11"><a href="#7-x2F-etc-x2F-X11" class="headerlink" title="7. &#x2F;etc&#x2F;X11"></a>7. &#x2F;etc&#x2F;X11</h1><p>与x window有关。该目录就是用于设定x window相关的，其中包括 XServer的设定和视窗管理员(Window Manager)的设定</p><h2 id="7-1-x2F-etc-x2F-skel"><a href="#7-1-x2F-etc-x2F-skel" class="headerlink" title="7.1 &#x2F;etc&#x2F;skel"></a>7.1 &#x2F;etc&#x2F;skel</h2><p>该目录是一个<strong>型版目录</strong>，当我们新增一个使用者时，系统会将此型版目录的内容一字不漏的复制过去每一个使用者的家目录。这样一来，我们基于可以不必为每一个新增使用者设置一些环境设定档。</p><h2 id="7-2-x2F-etc-x2F-rc-d"><a href="#7-2-x2F-etc-x2F-rc-d" class="headerlink" title="7.2 &#x2F;etc&#x2F;rc*.d"></a>7.2 &#x2F;etc&#x2F;rc*.d</h2><p>包括了<code>rc0.d</code>~&#96;&#96;rc6.d<code>和</code>rcS.d<code>。这些文档存放的内容是来告诉Linux在那个</code>runlevel<code>时要执行哪些工作。所谓的</code>runlevel&#96;&#96;，是指<strong>系统在开机时进入哪个层级</strong>，这个可以维基百科一下。</p><p>需记住的是：</p><p>​rc0.d ——runlevel0：关机</p><p>​rc1.d ——runlevel1：单一使用者模式。常用于系统管理员进行维修，不希望其他使用者进入。</p><p>​其他略</p><p>​rc6.d ——runlevel6：重新开机</p><h1 id="8-x2F-home-和-x2F-root"><a href="#8-x2F-home-和-x2F-root" class="headerlink" title="8. &#x2F;home 和 &#x2F;root"></a>8. &#x2F;home 和 &#x2F;root</h1><p>分别表示使用者家目录和管理员家目录。</p><h1 id="9-x2F-lib、-x2F-usr-x2F-lib、-x2F-usr-x2F-local-x2F-lib"><a href="#9-x2F-lib、-x2F-usr-x2F-lib、-x2F-usr-x2F-local-x2F-lib" class="headerlink" title="9. &#x2F;lib、&#x2F;usr&#x2F;lib、&#x2F;usr&#x2F;local&#x2F;lib"></a>9. &#x2F;lib、&#x2F;usr&#x2F;lib、&#x2F;usr&#x2F;local&#x2F;lib</h1><p>用于存放<strong>动态连接函数库</strong>。</p><p><strong>Linux中，即为<code>.so</code>或者<code>.a</code>文件。在win系统中，即为<code>.dll</code>文件</strong></p><p>所谓的动态连接函数库，是指但我们程序运行的时候才需要连接的函数库。</p><p>用win系统的理解，可以如此理解：</p><p>游戏运行的时候需要<code>DirectX </code>（DirectX 是 Windows 中的一组组件，允许软件（主要且尤其是游戏）直接与视频和音频硬件结合使用。），一般游戏打包的时候是不将这个组件放到游戏包里面的。如果将所有的组件放到游戏包中，会使得游戏包十分的臃肿。于是常常将一些通用的组件&#x2F;库让用户自己安装。游戏运行需要的时候，<strong>动态链接</strong>用户的组件&#x2F;库即可。如此，即使1000个游戏，也只需要1个库即可，而不需要将库都放到1000个游戏中。（<strong>共享</strong>的概念）</p><p>&#x2F;lib：系统程序才会用到的动态连接函数库以及核心组件。</p><p>&#x2F;usr&#x2F;lib：动态连接函数库存放目录。</p><p>&#x2F;usr&#x2F;local&#x2F;lib：使用者自行安装的动态连接函数库存放目录。</p><h1 id="10-x2F-mnt、-x2F-media"><a href="#10-x2F-mnt、-x2F-media" class="headerlink" title="10. &#x2F;mnt、&#x2F;media"></a>10. &#x2F;mnt、&#x2F;media</h1><p>均使用来挂在<strong>存储媒体</strong>的目录，存储媒体可能是SD卡、U盘等。</p><p>没有挂载的时候，目录是空的。</p><h1 id="11-x2F-opt、-x2F-usr-x2F-local"><a href="#11-x2F-opt、-x2F-usr-x2F-local" class="headerlink" title="11. &#x2F;opt、&#x2F;usr&#x2F;local"></a>11. &#x2F;opt、&#x2F;usr&#x2F;local</h1><p>均是用来存放<strong>自行安装的软件</strong></p><p>其差别在于：</p><ul><li>&#x2F;opt用来保存外加的应用程序软件套件</li><li>&#x2F;usr&#x2F;local是给系统管理员安装软件的位置</li></ul><p>按照李博明老师的作法，大型商用软件（如EDA）等工具统一安装在&#x2F;opt目录下；而自行安装的小型工具（Firefox浏览器）则统一安装在&#x2F;usr&#x2F;local目录下。</p><h1 id="12-x2F-proc、-x2F-sys"><a href="#12-x2F-proc、-x2F-sys" class="headerlink" title="12. &#x2F;proc、&#x2F;sys"></a>12. &#x2F;proc、&#x2F;sys</h1><p>两个档案有相似之处，同样都十分重要。</p><h2 id="12-1-x2F-proc"><a href="#12-1-x2F-proc" class="headerlink" title="12.1 &#x2F;proc"></a>12.1 &#x2F;proc</h2><p>存放<strong>核心及进程所需要的虚拟档案文件</strong>，意思是&#x2F;proc反应了当前系统的状态。</p><p>如：</p><ol><li>cpuinfo：查看CPU型号、CPU核心等信息</li><li>diskstats：目前磁盘状态</li><li>devices：目前设备装置的状态</li><li>dma：目前DMA的状态</li><li>interrupts：目前系统中断的状态</li><li>meninfo：目前存储器的状态</li><li>modules：目前系统载入模组的状态</li><li>uptime：目前系统启动时间、空闲时间状态</li><li>version：目前系统核心状态</li></ol><p>由于&#x2F;proc中的文档大多为纯文字档，使用<code>cat</code>即可进行浏览。</p><h2 id="12-2-x2F-sys"><a href="#12-2-x2F-sys" class="headerlink" title="12.2 &#x2F;sys"></a>12.2 &#x2F;sys</h2><p>&#x2F;sys是在Linux核心第2.6版之后出现的目录，主要作为<strong>即插即用的设定</strong>。</p><p>也可以查看一些系统的状态。</p><p>具体遇到之后再详查。</p><h1 id="13-x2F-tmp"><a href="#13-x2F-tmp" class="headerlink" title="13. &#x2F;tmp"></a>13. &#x2F;tmp</h1><p>用<strong>存放程序执行时的一些暂存档</strong></p><p>每个使用者均有读写的权限。</p><p>但是<strong>不要将重要的数据存放在此处</strong>，因为此目录的内容在重启之后就不见了</p><p>等同于window下的 C:\Temp目录</p><h1 id="14-x2F-usr"><a href="#14-x2F-usr" class="headerlink" title="14. &#x2F;usr"></a>14. &#x2F;usr</h1><p>最杂、最集大成的目录。</p><p>约等于window系统下，”C:\Window”和”C:\Program Files”两个目录的混合体。</p><p>下面对一些重要的目录进行介绍。</p><h2 id="14-1-x2F-usr-x2F-bin"><a href="#14-1-x2F-usr-x2F-bin" class="headerlink" title="14.1 &#x2F;usr&#x2F;bin"></a>14.1 &#x2F;usr&#x2F;bin</h2><p>存放使用者需要的一些可执行档，这些可执行档不是系统必要的执行档</p><h2 id="14-2-x2F-usr-x2F-games"><a href="#14-2-x2F-usr-x2F-games" class="headerlink" title="14.2 &#x2F;usr&#x2F;games"></a>14.2 &#x2F;usr&#x2F;games</h2><p>玩游戏</p><h2 id="14-3-x2F-usr-x2F-include"><a href="#14-3-x2F-usr-x2F-include" class="headerlink" title="14.3 &#x2F;usr&#x2F;include"></a>14.3 &#x2F;usr&#x2F;include</h2><p>C语言所必须包含的档头目录，即.h文件。</p><h2 id="14-4-x2F-usr-x2F-lib"><a href="#14-4-x2F-usr-x2F-lib" class="headerlink" title="14.4 &#x2F;usr&#x2F;lib"></a>14.4 &#x2F;usr&#x2F;lib</h2><p>存放懂动态连接函数库的目录</p><h2 id="14-5-x2F-usr-x2F-local"><a href="#14-5-x2F-usr-x2F-local" class="headerlink" title="14.5 &#x2F;usr&#x2F;local"></a>14.5 &#x2F;usr&#x2F;local</h2><p>存放管理员自行安装的软件，一般存放比较小的软件或者工具（个人觉得1G以下丢可以存放在这个）</p><h2 id="14-6-x2F-usr-x2F-local-x2F-bin"><a href="#14-6-x2F-usr-x2F-local-x2F-bin" class="headerlink" title="14.6 &#x2F;usr&#x2F;local&#x2F;bin"></a>14.6 &#x2F;usr&#x2F;local&#x2F;bin</h2><p>使用者自行安装的可执行档</p><h2 id="14-7-x2F-usr-x2F-local-x2F-include"><a href="#14-7-x2F-usr-x2F-local-x2F-include" class="headerlink" title="14.7 &#x2F;usr&#x2F;local&#x2F;include"></a>14.7 &#x2F;usr&#x2F;local&#x2F;include</h2><p>使用者自行安装的C语言的档头文件，即.h文件</p><h2 id="14-8-x2F-usr-x2F-local-x2F-lib"><a href="#14-8-x2F-usr-x2F-local-x2F-lib" class="headerlink" title="14.8 &#x2F;usr&#x2F;local&#x2F;lib"></a>14.8 &#x2F;usr&#x2F;local&#x2F;lib</h2><p>使用者自行安装的动态连接函数库</p><h2 id="14-9-x2F-usr-x2F-local-x2F-sbin"><a href="#14-9-x2F-usr-x2F-local-x2F-sbin" class="headerlink" title="14.9 &#x2F;usr&#x2F;local&#x2F;sbin"></a>14.9 &#x2F;usr&#x2F;local&#x2F;sbin</h2><p>使用者自行安装的关于系统管理的可执行档</p><h2 id="14-10-x2F-usr-x2F-local-x2F-share"><a href="#14-10-x2F-usr-x2F-local-x2F-share" class="headerlink" title="14.10 &#x2F;usr&#x2F;local&#x2F;share"></a>14.10 &#x2F;usr&#x2F;local&#x2F;share</h2><p>使用者自行安装的共享档案的目录，没有安装即为空目录</p><h2 id="14-11-x2F-usr-x2F-sbin"><a href="#14-11-x2F-usr-x2F-sbin" class="headerlink" title="14.11 &#x2F;usr&#x2F;sbin"></a>14.11 &#x2F;usr&#x2F;sbin</h2><p>给应用程序使用的系统管理相关的可执行档</p><h2 id="14-12-x2F-usr-x2F-share"><a href="#14-12-x2F-usr-x2F-share" class="headerlink" title="14.12 &#x2F;usr&#x2F;share"></a>14.12 &#x2F;usr&#x2F;share</h2><p>与系统架构无关的资料档案目录。<em>如，中文字体文件</em></p><h2 id="14-13-x2F-usr-x2F-src"><a href="#14-13-x2F-usr-x2F-src" class="headerlink" title="14.13 &#x2F;usr&#x2F;src"></a>14.13 &#x2F;usr&#x2F;src</h2><p>linux原始码编译目录（主要是Linux核心），主要用来存放Linux原始码。</p><p>如果修习有关<strong>Linux嵌入式开发</strong>相关的内容，则会用到</p><h1 id="15-x2F-var"><a href="#15-x2F-var" class="headerlink" title="15. &#x2F;var"></a>15. &#x2F;var</h1><p>是黑客入侵系统后第一个需要<strong>处理</strong>的目录，有时候，一些重要的系统进程也要用到该目录。</p><h2 id="15-1-x2F-var-x2F-log"><a href="#15-1-x2F-var-x2F-log" class="headerlink" title="15.1 &#x2F;var&#x2F;log"></a>15.1 &#x2F;var&#x2F;log</h2><p>主要记录系统的日志档（log）目录，包含了使用者自某一个IP登录系统、是否成功登录系统以及失败等信息。这些信息可以有助于我们跟踪黑客是否正在入侵我们的系统。故而黑客入侵的第一件事情就是删除该目录，从而隐藏自己的行踪。而对于管理员而言，管理员需要确保该目录资料的存在，从而追踪系统的登录状态。以下介绍几个重要的日志档。</p><h3 id="15-1-1-x2F-var-x2F-log-x2F-auth-log"><a href="#15-1-1-x2F-var-x2F-log-x2F-auth-log" class="headerlink" title="15.1.1 &#x2F;var&#x2F;log&#x2F;auth.log"></a>15.1.1 &#x2F;var&#x2F;log&#x2F;auth.log</h3><p>此档案十分重要，它告诉我们<strong>有什么人连进我们的系统、有谁取到了root的权限、有人试图连接我们的系统但是失败等记录</strong>。如果遇到黑客入侵，我们需要第一检查这个文件。</p><p>需要注意的是该文件的权限如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r-----1 syslog adm  <span class="hljs-number"> 9690 </span>9月<span class="hljs-number"> 3 </span>15：34 auth.log<br></code></pre></td></tr></table></figure><p>因此需要取得<strong>adm群组或者管理员root的权限</strong>才能观看此档案。</p><h3 id="15-1-2-x2F-var-x2F-log-x2F-dmseg"><a href="#15-1-2-x2F-var-x2F-log-x2F-dmseg" class="headerlink" title="15.1.2 &#x2F;var&#x2F;log&#x2F;dmseg"></a>15.1.2 &#x2F;var&#x2F;log&#x2F;dmseg</h3><p>相关指令dmseg，遇到再说。</p><h3 id="15-1-3-x2F-var-x2F-log-x2F-lastlog"><a href="#15-1-3-x2F-var-x2F-log-x2F-lastlog" class="headerlink" title="15.1.3 &#x2F;var&#x2F;log&#x2F;lastlog"></a>15.1.3 &#x2F;var&#x2F;log&#x2F;lastlog</h3><p>当我们执行<code>last</code>指令时，可以看见系统登入的使用者以及何时登入、从哪里登录的信息。</p><h3 id="15-1-4-x2F-var-x2F-log-x2F-Xorg-0-log"><a href="#15-1-4-x2F-var-x2F-log-x2F-Xorg-0-log" class="headerlink" title="15.1.4 &#x2F;var&#x2F;log&#x2F;Xorg.0.log"></a>15.1.4 &#x2F;var&#x2F;log&#x2F;Xorg.0.log</h3><p>系统启动X Window之后留下来的日志信息。</p><h2 id="15-2-x2F-var-x2F-cache"><a href="#15-2-x2F-var-x2F-cache" class="headerlink" title="15.2 &#x2F;var&#x2F;cache"></a>15.2 &#x2F;var&#x2F;cache</h2><p>存于暂存资料。其中有一个重要的子目录<code>/var/cache/apt</code>用来存储我们下载的<code>.deb</code>档。当我们使用指令<code>apt-get install 套件名</code>下载下来的<code>.deb</code>文档就存储在这个目录下。</p><p>使用指令<code>apt-get clean</code>可以对下载完已经安装的套件的.deb文件进行清理（类似于删除安装包）。</p><p>使用指令<code>df -h</code>或者<code>du -sh *</code>可以查看空间使用量</p><h2 id="15-3-x2F-var-x2F-mail"><a href="#15-3-x2F-var-x2F-mail" class="headerlink" title="15.3 &#x2F;var&#x2F;mail"></a>15.3 &#x2F;var&#x2F;mail</h2><p>存放每个使用者的电子邮件，一旦使用者收信之后，其邮件内容就会从此目录中删除。</p><h2 id="15-4-x2F-var-x2F-lock"><a href="#15-4-x2F-var-x2F-lock" class="headerlink" title="15.4 &#x2F;var&#x2F;lock"></a>15.4 &#x2F;var&#x2F;lock</h2><p>有些程序执行的过程中，要求只能只有一个该程序执行，不得有分身程序同时执行的规定。</p><p>最常见的例子是<code>aptitude</code>，该程序一次只能有一个在执行中的进程，否则系统的软件安装&#x2F;移除就会乱掉。因此在<code>aptitude</code>程序执行的时候，会在<code>/var/lock</code>中新建一个<code>aptitude</code>档案，告诉系统当前<code>aptitude</code>正在执行，此时如果还有人要再执行<code>aptitude</code>的话，系统就会发生错误。</p><h2 id="15-5-x2F-var-x2F-spool"><a href="#15-5-x2F-var-x2F-spool" class="headerlink" title="15.5 &#x2F;var&#x2F;spool"></a>15.5 &#x2F;var&#x2F;spool</h2><p>这是一个暂存的空间，这边存储的时候程序还没执行完的资料。</p><p>比如，在打印机进行打印的时候，未打印的文件就会暂存在该目录下，一一排队等待打印。</p><p>当然这个目录并不是一个程序专享的。其他程序的一些未执行的资料文件也会存放在该目录下。</p><h1 id="16-关于Linux文件备份问题"><a href="#16-关于Linux文件备份问题" class="headerlink" title="16 关于Linux文件备份问题"></a>16 关于Linux文件备份问题</h1><p>当我需要重装Linux系统的时候，我需要备份哪些文件？</p><p>文件备份原则是：</p><center><b>不能拷贝到的资料一定要备份</b></center><p>&#x2F;bin：不需要</p><p>&#x2F;dev：不需要</p><p>&#x2F;etc：需要。系统设定档。对于稳定的服务器而言，需要进行的实时的更新修补漏洞，而对于更新系统之后的相关设定（希望还原原本系统的功能 ），需要依照原本的系统设定进行设定。这些设定是个人的，网络上找不到的。</p><p>&#x2F;home：需要。个人文档，包括个人作业、论文等重要的资料，一定要备份。而且需要多备份！！！</p><p>&#x2F;opt：需要。虽然对于很多软件，网络上均可以下载得到，但是很多软件安装十分的麻烦，于是最好还是备份。</p><p>&#x2F;root：根据情况进行备份。一般而言，我们将资料存在自己的家目录（&#x2F;home）中，而不存储在&#x2F;root下。</p><p>&#x2F;sbin：不需要。</p><p>&#x2F;var：需要备份。&#x2F;var中存储了十分重要的日志信息（log），当系统由于黑客入侵或者其他外界因素遭到破坏，此时主机处于<strong>不安全状态</strong>，此时需要日志信息进行辅助修补主机的漏洞，确保新装的或者更新维护之后的主机是安全可靠的。</p><p><strong>重点三个文件</strong>：</p><ol><li>你的资料</li><li>你的设定档</li><li>你的log档</li></ol>]]></content>
    
    
    <categories>
      
      <category>【李博明】linux入门笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>李博明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习（1）软件安装与移除</title>
    <link href="/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A7%BB%E9%99%A4/"/>
    <url>/2022/04/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A7%BB%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p>李博明老师讲的Linux课程笔记。</p><p>系统为debian系统，主要内容包括：①镜像站的设定、②软件的安装</p><hr><span id="more"></span><p>市面上常见的两种Linux发行版——基于RedHat、基于Debian的Linux系统</p><ol><li><p>RedHat：①收费的RedHat商用版；②社区开发（2020年无了）Centos</p><p>软件管理安装相关的工具：rpm、yum</p></li><li><p>Debian：①Debian本家；②Ubuntu</p><p>软件管理安装相关的工具：apt、aptitude</p></li></ol><p>本笔记以Debian系列为例。</p><p>ps：</p><ol><li>中文乱码解决办法：<code>export LC_ALL=C</code></li></ol><h1 id="1-APT镜像站设定"><a href="#1-APT镜像站设定" class="headerlink" title="1. APT镜像站设定"></a>1. APT镜像站设定</h1><h2 id="1-1-nslookup：域名解析"><a href="#1-1-nslookup：域名解析" class="headerlink" title="1.1 nslookup：域名解析"></a>1.1 <code>nslookup</code>：域名解析</h2><p><code>nslookup</code>：DNS域名解析</p><p>具体效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210903111503945.png" alt="image-20210903111503945"></p><p>对百度的域名进行解析，居然有<code>www.a.shifen.com</code>的域名，具体的故事可以了解一下。</p><p>说到这个命令可以对于我们设置镜像站，了解镜像站的域名有所帮助。</p><h2 id="1-2-选取镜像站"><a href="#1-2-选取镜像站" class="headerlink" title="1.2 选取镜像站"></a>1.2 选取镜像站</h2><p>由于本人通过台湾李博明老师的课程进行linux的基础学习，他对于镜像站的选取有以下两个要素。（不一定适用于大陆）</p><ul><li>选近不选远</li><li>选公立单位而不选私立单位</li></ul><h2 id="1-3-APT镜像站的设定——略解-list文件"><a href="#1-3-APT镜像站的设定——略解-list文件" class="headerlink" title="1.3 APT镜像站的设定——略解.list文件"></a>1.3 APT镜像站的设定——略解.list文件</h2><p>APT设定档位置：<code>etc/apt/source.list</code></p><p><code>sources.list</code>的格式和写法</p><ol><li>以字符<code>#</code>开头的行代表该行是一行注释</li><li>不以<code>#</code>开头的行是<code>apt repository</code>，它的格式为：<ol><li><code>deb</code>： 二进制包仓库（已经编译好了）</li><li><code>deb-src</code>： 二进制包的源码库（原始码套件，一般注释起来）</li><li><code>URI</code>：库所在的地址，可以是网络地址，也可以是本地的镜像地址</li><li><code>codename</code>： Ubuntu版本的代号。可以用命令<code>lsb_release -sc</code>来查看当前系统的代号。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Debian本家系统的版本号是由《玩具总动员》里面的角色命名的。">[1]</span></a></sup></li><li><code>components</code>： 软件的性质（free或non-free等）</li></ol></li></ol><p><code>deb</code>的语法：<strong>deb URI section1 section2</strong></p><p>以Ubuntu为例（一种颜色代表一个部分，如图四个部分），</p><p><img src="https://cdn.jsdelivr.net/gh/mohun-8052/pic/image-20210903120839207.png" alt="image-20210903120839207"></p><p>这边仅了解。其他略</p><h1 id="2-APT软件安装与移除"><a href="#2-APT软件安装与移除" class="headerlink" title="2. APT软件安装与移除"></a>2. APT软件安装与移除</h1><h2 id="2-1-APT操作说明——apt-get"><a href="#2-1-APT操作说明——apt-get" class="headerlink" title="2.1 APT操作说明——apt-get"></a>2.1 APT操作说明——<code>apt-get</code></h2><ol><li><p><code>apt-get update</code></p><p><strong>更新目前套件状态</strong></p></li><li><p><code>apt-get upgrade</code></p><p><strong>更新系统旧版套件，以及修补有漏洞的套件</strong></p><p>（一般上机，先做<code>update</code>后作<code>upgrade</code>确保系统的安全）</p></li><li><p><code>apt-get install (-y) PKG_NAME</code></p></li></ol><h2 id="2-2-APT操作说明——aptitude（选单模式）"><a href="#2-2-APT操作说明——aptitude（选单模式）" class="headerlink" title="2.2 APT操作说明——aptitude（选单模式）"></a>2.2 APT操作说明——<code>aptitude</code>（选单模式）</h2><ol><li><p>安装<code>aptitude</code></p><p><code>apt-get install aptitude</code></p></li><li><p>命令行呼出界面</p><p><code>aptitude</code></p></li><li><p>由于是界面操作，操作相对简单。网上可以找到资料，于是此处略</p></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Debian本家系统的版本号是由《玩具总动员》里面的角色命名的。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>【李博明】linux入门笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>李博明</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
